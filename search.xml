<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>idea热更新</title>
      <link href="/2021/04/01/idea-%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2021/04/01/idea-%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="idea热更新手段"><a href="#idea热更新手段" class="headerlink" title="idea热更新手段"></a>idea热更新手段</h1><p>由于在调试或者开发程序的时候，经常会遇到一个小小的bug改半天的情况，所以要一遍又一遍的重启项目，小一点的项目还好，稍微那种起一次就得花一分钟的程序改起bug来简直就是要命。还好，idea有一个收费插件”JRebel”,可以让我们热更新</p><h2 id="下载JRelbel"><a href="#下载JRelbel" class="headerlink" title="下载JRelbel"></a>下载JRelbel</h2><p>在setting=&gt; plugins路径下，搜索 JRelbel，安装</p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>打开<a href="https://jrebel.qekang.com/，按照操作激活即可。" target="_blank" rel="noopener">https://jrebel.qekang.com/，按照操作激活即可。</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过JRebel的方式启动，当需要更新项目的时候，按下ctrl + shift + F9即可</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue走过的那些坑</title>
      <link href="/2021/03/25/vue%E8%B5%B0%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>/2021/03/25/vue%E8%B5%B0%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="vue走过的那些坑"><a href="#vue走过的那些坑" class="headerlink" title="vue走过的那些坑"></a>vue走过的那些坑</h1><h2 id="vue修改数组"><a href="#vue修改数组" class="headerlink" title="vue修改数组"></a>vue修改数组</h2><p>当我们想修改原数组的某一个元素的值得时候，并不会使页面动态渲染。</p><p>像是这样：</p><pre><code class="html">&lt;!-- 截取重要字段 --&gt;&lt;div v-for=(item ,index) in data&gt;{{item}}&lt;/div&gt;&lt;button @click=&quot;change&quot;&gt;修改&lt;button&gt;&lt;script&gt;data(){    return {        data:[1,2,2,3]    }}methods:{    change(){        this.data[2] = 5    }}&lt;/script&gt;</code></pre><p>array[index] = value，vue扫描不到数组的变化。<br>下面提供了三个解决办法：</p><ol><li><strong>this.$set(arrat,index,value)</strong> （个人不是很喜欢）</li><li>array = newArray (之前用axios做过，但是现在还不是很确定是否可以用)</li><li>array.splice(index,1,newValue) (个人推荐)</li></ol><h2 id="关于vue中import的那些事"><a href="#关于vue中import的那些事" class="headerlink" title="关于vue中import的那些事"></a>关于vue中import的那些事</h2><p>再写vue的项目的时候，import导入其他组件和export的组合是最常用的了。</p><p>那么就那我的项目为例子，我的项目导入了iview</p><pre><code class="javascript">import { Button, Table, Message, Input } from &#39;iview&#39;import &#39;iview/dist/styles/iview.css&#39;;</code></pre><p>可以看到 这个组件是从根路径出发的，而且这个路径是从node_moudle这个文件夹内找的，如果不熟悉node_moudle，可以看我之前的vue入门博客。</p><p>而且，我们可以看到，导入的组件是拿{}包裹这的，我们要知道，一般的组件像是vue官网上的那些，我们都是不拿{}包裹的。</p><blockquote><p>那么，这两种方式有区别么？</p></blockquote><p>答案是有的，{}导入的组件，需要用export {xxx,xxx,xxx}导出，而不需要{}的则需要用export default ‘xxx’导出，而且 default 不可以导出多个，也就是说，我们可以因为某些逻辑将一些组件写在一个js文件中，然后用{}导出</p><h2 id="关于vuex传参的一些事情"><a href="#关于vuex传参的一些事情" class="headerlink" title="关于vuex传参的一些事情"></a>关于vuex传参的一些事情</h2><p>之前没有说vuex，这里说一下它的传参问题吧。对于我来说,vuex其实就可以看成一个静态的类，类里面分成四个模块</p><p>state =&gt;  存放data的</p><p>getters =&gt; get函数，获取变量的</p><p>mutataions =&gt; set函数，设置变量的</p><p>actions =&gt; 具体函数实现，比如利用axios之后将数据利用mutations提交的，也算是一个变相的set的函数吧</p><h3 id="数据取不到？-一直undefined"><a href="#数据取不到？-一直undefined" class="headerlink" title="数据取不到？ 一直undefined?"></a>数据取不到？ 一直undefined?</h3><p>本以为按照上面的做法去弄来着，但是当我在做完登陆功能，将token存到state里面，然后在axios封装的js文件将token取出来并且当作header的时候，数据一直是undefined,机智的我发现事情并不这么简单。吓得我马上开始了百度。</p><hr><blockquote><p>不出意料的是，百度总会在将你想要查询的东西替换成你最不想要的结果</p></blockquote><p>查了一顿，啥也没查出来，其实一堆文章都阐述了这个问题，但是他们大多都是将什么token存入到localStorage里面。是的，这也是一个解决办法，不过我以后的getter不还是取不到数据么！</p><p>无奈下，打开gayhub,随便down一个大佬的vue项目，偷偷观察下(大佬不愧是大佬，代码结构清晰明了)。我发现大佬们的vuex代码无非是这种结构</p><p><img src="https://s2.ax1x.com/2019/10/11/uHU6zV.png" alt></p><p>moudles -&gt;  存放我们需要的一些数据，但是和上面我们想的不同的是，这些moudles里面并没有getters。而是单独抽出来了一个getters文件<br>getters -&gt; 抽象出来的getters对象</p><p>index -&gt; 注册moudles和getters组件</p><blockquote><p>需要主要的是，这个getters组件是全局的，而我们在moudles里面写的state的局部的，所以仍然还是取不到任何东西，因此我们需要指明moudle名字<br>例如： avatarId: state =&gt; state.user.avatarId  和别的不一样的是，它在state后面又指明了user作用域</p></blockquote><h3 id="mutataions只接受一个参数"><a href="#mutataions只接受一个参数" class="headerlink" title="mutataions只接受一个参数"></a>mutataions只接受一个参数</h3><p>这个问题其实困扰了我一会，因为如果你在actions里面写这样的话</p><p>commit(“xxx”, 变量1，变量2)</p><p>并且那个xxx的函数是(state,变量1，变量2)的时候，是不会报错的！而且只接收变量1，其余的自动undefined，一开始我还以为是我的变量不对呢，后来才发现是这的原因，不过这样解决办法也很明显了，我们可以弄一个复杂json过去，就像这样</p><p>commit(“xxx”,{1:xx,2:xx})</p><p>然后接收的时候正常接收就行，注意！一定用一个变量名接收，血与泪的教训啊。。。。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Jpa 启动流程分析</title>
      <link href="/2021/03/03/Spring-Data-Jpa-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2021/03/03/Spring-Data-Jpa-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Data-Jpa-启动流程分析"><a href="#Spring-Data-Jpa-启动流程分析" class="headerlink" title="Spring Data Jpa 启动流程分析"></a>Spring Data Jpa 启动流程分析</h1><h2 id="EnableJpaRepositories"><a href="#EnableJpaRepositories" class="headerlink" title="EnableJpaRepositories"></a>EnableJpaRepositories</h2><p>目的是导入JpaRepositoriesRegistrar这个配置类</p><pre><code class="java">@Import(JpaRepositoriesRegistrar.class)public @interface EnableJpaRepositories {    String[] basePackages() default {};</code></pre><blockquote><p>通过JpaRepositoriesRegistrar的继承一步一步的往上走，发现最终实现了Spring 的ImportBeanDefinitionRegistrar接口</p></blockquote><pre><code class="java">class JpaRepositoriesRegistrar extends RepositoryBeanDefinitionRegistrarSupport {protected Class&lt;? extends Annotation&gt; getAnnotation() {  //给定EnableJpaRepositories注解return EnableJpaRepositories.class;}@Override protected RepositoryConfigurationExtension getExtension() {    // 这个方法是通知给Spring 我这此次注册的是JpaRepositoryBeanFactoryreturn new JpaRepositoryConfigExtension();}}</code></pre><blockquote><p>ImportBeanDefinitionRegistrar的作用就是自定义扫描文件将符合条件的注册成Bean</p></blockquote><p>下面这个是扫描文件的实现方法，我截取了一些重要片段</p><pre><code class="java">public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry) {        AnnotationRepositoryConfigurationSource configurationSource = new AnnotationRepositoryConfigurationSource(                annotationMetadata, getAnnotation(), resourceLoader, environment, registry);        RepositoryConfigurationExtension extension = getExtension();        RepositoryConfigurationUtils.exposeRegistration(extension, registry, configurationSource);        RepositoryConfigurationDelegate delegate = new RepositoryConfigurationDelegate(configurationSource, resourceLoader,                environment);        // 看方法名字就知道 注册仓库        delegate.registerRepositoriesIn(registry, extension);    }</code></pre><blockquote><p>最重要的还是注册Bean，我们跟着registerRepositoriesIn方法进去</p></blockquote><blockquote><p>方法注释：<br>Registers the found repositories in the given <strong>BeanDefinitionRegistry</strong>.<br>注释说的很明显了，通过那个BeanDefinitionRegistry注册那些发现的仓库</p></blockquote><pre><code class="java">extension.registerBeansForRoot(registry, configurationSource);        RepositoryBeanDefinitionBuilder builder = new RepositoryBeanDefinitionBuilder(registry, extension,                configurationSource, resourceLoader, environment);        List&lt;BeanComponentDefinition&gt; definitions = new ArrayList&lt;&gt;();        StopWatch watch = new StopWatch();        watch.start();        //这里查了一下资料，configurations获取了所有的仓库接口        Collection&lt;RepositoryConfiguration&lt;RepositoryConfigurationSource&gt;&gt; configurations = extension                .getRepositoryConfigurations(configurationSource, resourceLoader, inMultiStoreMode);        Map&lt;String, RepositoryConfiguration&lt;?&gt;&gt; configurationsByRepositoryName = new HashMap&lt;&gt;(configurations.size());        // 下面应该是说通过读取各种情况下的配置文件去导入仓库列表        for (RepositoryConfiguration&lt;? extends RepositoryConfigurationSource&gt; configuration : configurations) {            configurationsByRepositoryName.put(configuration.getRepositoryInterface(), configuration);            BeanDefinitionBuilder definitionBuilder = builder.build(configuration);            extension.postProcess(definitionBuilder, configurationSource);            if (isXml) {                extension.postProcess(definitionBuilder, (XmlRepositoryConfigurationSource) configurationSource);            } else {                extension.postProcess(definitionBuilder, (AnnotationRepositoryConfigurationSource) configurationSource);            }            AbstractBeanDefinition beanDefinition = definitionBuilder.getBeanDefinition();            String beanName = configurationSource.generateBeanName(beanDefinition);            beanDefinition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, configuration.getRepositoryInterface());            registry.registerBeanDefinition(beanName, beanDefinition);            definitions.add(new BeanComponentDefinition(beanDefinition, beanName));        }        potentiallyLazifyRepositories(configurationsByRepositoryName, registry, configurationSource.getBootstrapMode());        watch.stop();        return definitions;</code></pre><blockquote><p>上面的大概意思就是说，我通过 读取了所有用户仓库的接口，然后definitionBuilder用这个注册了一个JpaRepositoryFactoryBean<br>然后等spring初始化的时候就会创建JpaRepositoryFactoryBean这种类型的Bean了</p></blockquote><blockquote><p>通过查阅资料得知，spring 一开始就要初始化BeanFactory</p></blockquote><h2 id="RepositoryBeanDefinitionRegistrarSupport"><a href="#RepositoryBeanDefinitionRegistrarSupport" class="headerlink" title="RepositoryBeanDefinitionRegistrarSupport"></a>RepositoryBeanDefinitionRegistrarSupport</h2><p>上面我们一步步的将我们的用户仓库注册到Spring中，那我们的的那些Crud操作是如何自动代理到我们自定义的接口中呢？</p><p>这就要重新到JpaRepositoriesRegistrar这个类来说了，他里面new了一个很重要的类JpaRepositoryConfigExtension</p><pre><code class="java">@Override    public String getRepositoryFactoryBeanClassName() {        return JpaRepositoryFactoryBean.class.getName();    }</code></pre><blockquote><p>我们可以看到这里获得了JpaRepositoryFactoryBean的名字，这个方法是用在一个DefaultRepositoryConfiguration的类里面的<br>DefaultRepositoryConfiguration 的注释写着Default implementation of RepositoryConfiguration.<br>我们可以知道他其实是RepositoryConfiguration的实现</p></blockquote><p>那么，这个RepositoryConfiguration我们又是在哪里用到的呢?</p><blockquote><p>正式上面我们提到的registerBeansForRoot方法。</p></blockquote><pre><code class="java">Map&lt;String, RepositoryConfiguration&lt;?&gt;&gt;     Map&lt;String, RepositoryConfiguration&lt;?&gt;&gt; configurationsByRepositoryName = new HashMap&lt;&gt;(configurations.size());configurationsByRepositoryName.put(configuration.getRepositoryInterface(), configuration);</code></pre><blockquote><p>这个我们就很清楚了，我们通过registerBeansForRoot读取到用户仓库，然后通过上面的函数注册成JpaRepositoryFactoryBean，然后再托管到Spring容器里面。</p></blockquote><p>那现在的重点就是 JpaRepositoryFactoryBean这个东西</p><h2 id="JpaRepositoryFactoryBean"><a href="#JpaRepositoryFactoryBean" class="headerlink" title="JpaRepositoryFactoryBean"></a>JpaRepositoryFactoryBean</h2><p>经过查阅知道 afterPropertiesSet()这个函数是重点，他是创建仓库的入口。在哪里进行<strong>动态代理</strong></p><p>下面是afterPropertiesSet()方法执行过程中用到的一个重要函数，意思就是生成仓库</p><pre><code class="java">public &lt;T&gt; T getRepository(Class&lt;T&gt; repositoryInterface, RepositoryFragments fragments) {        RepositoryMetadata metadata = getRepositoryMetadata(repositoryInterface);        RepositoryComposition composition = getRepositoryComposition(metadata, fragments);        RepositoryInformation information = getRepositoryInformation(metadata, composition);        validate(information, composition);        Object target = getTargetRepository(information);        // Create proxy        ProxyFactory result = new ProxyFactory();        result.setTarget(target);        result.setInterfaces(repositoryInterface, Repository.class, TransactionalProxy.class);        if (MethodInvocationValidator.supports(repositoryInterface)) {            result.addAdvice(new MethodInvocationValidator());        }        result.addAdvice(SurroundingTransactionDetectorMethodInterceptor.INSTANCE);        result.addAdvisor(ExposeInvocationInterceptor.ADVISOR);        postProcessors.forEach(processor -&gt; processor.postProcess(result, information));        result.addAdvice(new DefaultMethodInvokingMethodInterceptor());        ProjectionFactory projectionFactory = getProjectionFactory(classLoader, beanFactory);        result.addAdvice(new QueryExecutorMethodInterceptor(information, projectionFactory));        composition = composition.append(RepositoryFragment.implemented(target));        result.addAdvice(new ImplementationMethodExecutionInterceptor(composition));        T repository = (T) result.getProxy(classLoader);        return repository;    }</code></pre><p>上面的方法中也有注释，creat proxy。真相大白。<br>ProxyFactory result = new ProxyFactory();</p><h2 id="不通过-EnableJpaRepositories注解，JPA如何自动配置"><a href="#不通过-EnableJpaRepositories注解，JPA如何自动配置" class="headerlink" title="不通过@EnableJpaRepositories注解，JPA如何自动配置"></a>不通过@EnableJpaRepositories注解，JPA如何自动配置</h2><p>我发现我的spring boot 项目中即使不写@EnableJpaRepositories注解，照样可以启动成功。</p><p>经过查阅知道 spring boot 里面有一个 spring-boot-autoconfigure包，包里面有一个spring.factories配置文件，里面就有Jpa的相关配置，所以即使不加注解，照样可以成功。</p><p><a href="https://imgtu.com/i/6AJrsH" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/03/6AJrsH.png" alt="6AJrsH.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> spring data jpa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring data jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于springboot自动注入相关经验</title>
      <link href="/2021/02/24/%E5%85%B3%E4%BA%8Espringboot%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C/"/>
      <url>/2021/02/24/%E5%85%B3%E4%BA%8Espringboot%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="关于spring-boot-注入相关经验"><a href="#关于spring-boot-注入相关经验" class="headerlink" title="关于spring boot 注入相关经验"></a>关于spring boot 注入相关经验</h1><hr><p>这里是最近重新学习Spring boot关于注入相关的经验博客，特此记录一下：</p><h2 id="JdbcTemplate注入"><a href="#JdbcTemplate注入" class="headerlink" title="JdbcTemplate注入"></a>JdbcTemplate注入</h2><p>在学习java web的时候，有使用过一个叫jdbcTemplate的东西。所以下面这个代码极为熟悉：</p><pre><code class="java">@Configurationpublic class Springconfig { @Bean    public JdbcTemplate jdbcTemplate(){        return new JdbcTemplate();    }}</code></pre><p>首先要说几点就是，这个@Configuration是必须要写的，如果没有写，这个Bean是不生效的。</p><p>我们创建了一个jdbcTemplate的单例，接下来是怎么注入的问题。</p><p>我一开始写的代码是这样的。</p><pre><code class="java">class xxx{    @Autowired    JdbcTemplate jdbc;}</code></pre><p>这里其实是错误的，因为他会自动注入Springboot里面的这个类，我问了一下我的师傅，他和我说：</p><p>这是因为xxx这个类没有托管给Spring工厂，加一个@Component就OK了</p><h2 id="多数据源注入"><a href="#多数据源注入" class="headerlink" title="多数据源注入"></a>多数据源注入</h2><p>我最近弄cdc的时候需要用到多数据源，下面是注入时的一些小经验</p><pre><code class="yaml">spring:  datasource:    dynamic:      primary: target      batch:        driver-class-name: com.mysql.cj.jdbc.Driver        jdbc-url: jdbc:mysql://localhost:3306/springbatch?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC        username: root        password: 123      origin:        driver-class-name: com.mysql.cj.jdbc.Driver        jdbc-url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false        username: root        password: 123      target:        driver-class-name: com.mysql.cj.jdbc.Driver        jdbc-url: jdbc:mysql://localhost:3306/target_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false        username: root        password: 123</code></pre><p>创建一个config</p><pre><code class="java">@Configurationpublic class DataSourceConfig {    @Bean(&quot;batchDataSource&quot;)    @ConfigurationProperties(&quot;spring.datasource.dynamic.batch&quot;)    public DataSource batchDataSource(){        return DataSourceBuilder.create().build();    }    @Bean(&quot;originSource&quot;)    @ConfigurationProperties(&quot;spring.datasource.dynamic.origin&quot;)    public DataSource originDataSource(){        xxx    }    @Bean(&quot;targetSource&quot;)    @ConfigurationProperties(&quot;spring.datasource.dynamic.target&quot;)    @Primary    public DataSource targetDataSource(){       xxx    }}</code></pre><blockquote><p>说个重要的，当你的Bean后面写了名称的时候，如果想注入这个东西，你需要用到下面的代码</p></blockquote><pre><code class="java">// 第一种@Autowired@@Qualifier(&quot;batchDataSource&quot;) DataSource dataSource;//第二种method(@Qualifier(&quot;batchDataSource&quot;) DataSource dataSource){}</code></pre><p>总之@Qualifier这个注解一定要会</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring security实现前后端分离的登陆与认证</title>
      <link href="/2021/02/13/spring-security%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E9%99%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
      <url>/2021/02/13/spring-security%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E7%99%BB%E9%99%86%E4%B8%8E%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>强烈推荐兄弟们看这个帖子<a href="https://www.jianshu.com/p/d5ce890c67f7" target="_blank" rel="noopener">Spring Security做JWT认证和授权</a></p></blockquote><p>我的毕设项目是类斗鱼软件开发，所以我为了给我的项目增加亮点，权限认证与授权肯定就不能用之前的过滤器来弄了，现在我决定使用spring security来接管我的项目。具体源码已经上传<a href="https://github.com/adroitwolf/spring-security-auth-example">Github</a></p><h2 id="spring-security认证流程"><a href="#spring-security认证流程" class="headerlink" title="spring security认证流程"></a>spring security认证流程</h2><ol><li><p>用户使用用户名和密码进行登录。</p></li><li><p>Spring Security将获取到的用户名和密码封装成一个实现了Authentication接口的UsernamePasswordAuthenticationToken。</p></li><li><p>将上述产生的token对象传递给AuthenticationManager进行登录认证。</p></li><li><p>AuthenticationManager认证成功后将会返回一个封装了用户权限等信息的Authentication对象。</p></li><li><p>通过调用SecurityContextHolder.getContext().setAuthentication(…)将AuthenticationManager返回的Authentication对象赋予给当前的SecurityContext。</p></li></ol><h2 id="spring-security的基本组件与流程"><a href="#spring-security的基本组件与流程" class="headerlink" title="spring security的基本组件与流程"></a>spring security的基本组件与流程</h2><p>我们首先要知道，spring security是一个一个的过滤器，他的过滤流程是下面这样：</p><p><a href="https://imgtu.com/i/yjsC8J" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/25/yjsC8J.png" alt="yjsC8J.png"></a></p><h2 id="spring-security重要组件"><a href="#spring-security重要组件" class="headerlink" title="spring security重要组件"></a>spring security重要组件</h2><h3 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h3><p>首先就是我们的<strong>UsernamePasswordAuthenticationFilter</strong>,按照我的理解是，只要你在后面的configure函数里面设定了表单登录，你就得走着个过滤器，并且我们一般都会设置那个。</p><p>他这个过滤器的关键函数就是attemptAuthentication，源码如下：</p><pre><code class="java">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) {            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());        } else {            String username = this.obtainUsername(request);            String password = this.obtainPassword(request);            if (username == null) {                username = &quot;&quot;;            }            if (password == null) {                password = &quot;&quot;;            }            username = username.trim();            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);            this.setDetails(request, authRequest);            return this.getAuthenticationManager().authenticate(authRequest);        }    }</code></pre><p>不算是很复杂，我们看到我们最熟悉的username和password，也就是说，他其实就是一个将请求获取一下用户名和密码的东西。</p><p>所以，我自定义了这个文件，代码如下：</p><pre><code class="java">public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {    @Autowired    @Override    public void setAuthenticationManager(AuthenticationManager authenticationManager) {        super.setAuthenticationManager(authenticationManager);    }        public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response){        JSONObject json = null;        try {            json = ServletUtils.getRequestJsonObject(request);        } catch (IOException e) {            throw  new AppException(&quot;服务器错误,请重试&quot;);        }//        获取json值        String username = json.getString(&quot;username&quot;);        String password = json.getString(&quot;password&quot;);        if (username == null) {            username = &quot;&quot;;        }        if (password == null) {            password = &quot;&quot;;        }        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);        this.setDetails(request, authRequest);        return this.getAuthenticationManager().authenticate(authRequest);    }}</code></pre><p>这个ServletUtils请具体看我的源码，具体作用就是将请求过来的参数转化成为Json对象</p><h3 id="登录成功和登录失败以及未登录"><a href="#登录成功和登录失败以及未登录" class="headerlink" title="登录成功和登录失败以及未登录"></a>登录成功和登录失败以及未登录</h3><ul><li>登陆失败：AuthenticationFailureHandler</li><li>登陆成功：AuthenticationSuccessHandler</li><li>未登录：AuthenticationEntryPoint</li><li>403没有权限: AccessDeniedHandler</li></ul><p>这三个是可以自定义状态返回结果，都需要自定义</p><h3 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h3><p>我们将上面的东西都写完了，最后就是要组装了，集成上面这个类，实现configure方法，就可以做到这一点。</p><pre><code class="java">@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Autowired    LoginSuccessHandler loginSuccessHandler;    @Autowired    LoginFailedHandler loginFailedHandler;    @Autowired    AuthenticationEntryPoint anonymousAuthenticationEntryPoint;    @Bean    public UserDetailsService userDetailsService(){        return new UsrServiceImpl();    }//    @Autowired//    UsernamePasswordAuthenticationFilter customAuthenticationFilter;    @Bean    CustomAuthenticationFilter customAuthenticationFilter() throws Exception {        CustomAuthenticationFilter filter = new CustomAuthenticationFilter();        filter.setAuthenticationSuccessHandler(loginSuccessHandler);        filter.setFilterProcessesUrl(&quot;/loginUsr&quot;);        filter.setAuthenticationManager(authenticationManager());        filter.setAuthenticationFailureHandler(loginFailedHandler);        return filter;    }    @Bean    @Override    protected AuthenticationManager authenticationManager() throws Exception {        return super.authenticationManager();    }        @Bean    public BCryptPasswordEncoder getPW(){        return new BCryptPasswordEncoder();    }    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.userDetailsService(userDetailsService());    }    @Override    protected void configure(HttpSecurity http) throws Exception {        http.csrf().and().cors().disable();        http                .authorizeRequests()                .antMatchers(&quot;/authTest&quot;).permitAll()                .anyRequest().authenticated()                .and()              .and()                .formLogin()//                .loginPage(&quot;/login&quot;)                .loginProcessingUrl(&quot;/loginUsr&quot;)                .permitAll();        http.exceptionHandling().authenticationEntryPoint(anonymousAuthenticationEntryPoint);        http.addFilterAt(customAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);    }    @Override    public void configure(WebSecurity web) throws Exception {//  这个会在上面的过滤器执行之前执行        web.ignoring().antMatchers(&quot;/loginUsr&quot;);    }}</code></pre><h3 id="configure里面的注意事项"><a href="#configure里面的注意事项" class="headerlink" title="configure里面的注意事项"></a>configure里面的注意事项</h3><p>这个我单独拿出来说，因为特别重要</p><ol><li><p>由于我们不需要Spring security自带的登录页面，所以.loginPage()我们不需要写！！</p></li><li><p>这个.loginUsr我们不需要写一个controller，因为我们在访问这个网址的时候，spring security自动将请求进入这几个过滤器</p></li><li>.loginUsr需要在web.ignoring().antMatchers(“/loginUsr”);这段代码里面放行，而不是用 http.antMatchers里面写！</li><li>因为我们自定义了UsernamePassword..那个过滤器，所以他的认证管理器如果我们new一个的话，他会直接报错，因为这个时候他自己的认证管理器已经指向不明确了。</li></ol><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p>上面只是告诉你了如何登录，现在就是我们的授权问题。<br>我的想法是，登录成功之后，返回给用户一个jwt，然后用户在请求头上面带着这个jwt直接验证。后端收到之后如果你这个jwt没有问题，直接放行，不需要去数据库再次进行验证(核心目标)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring boot </tag>
            
            <tag> spring security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot集成swagger2</title>
      <link href="/2021/02/11/springboot%E9%9B%86%E6%88%90swagger2/"/>
      <url>/2021/02/11/springboot%E9%9B%86%E6%88%90swagger2/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-boot集成swagger2"><a href="#spring-boot集成swagger2" class="headerlink" title="spring boot集成swagger2"></a>spring boot集成swagger2</h1><h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><pre><code class="java">@EnableSwagger2@Configurationpublic class Swagger2Config {    @Bean    public Docket CreateRestfulApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;run.app.controller&quot;))                .paths(PathSelectors.any())                .build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;ADROITWOLF博客API&quot;)                .description(&quot;多用户博客门户网站&quot;)                .termsOfServiceUrl(&quot;https://adroitwolf.github.io&quot;)                .version(&quot;1.0&quot;)                .build();    }}</code></pre><blockquote><p>里面的basePackage改成自己的controller路径</p></blockquote><h2 id="具体使用方法"><a href="#具体使用方法" class="headerlink" title="具体使用方法"></a>具体使用方法</h2><p>这里贴一个使用示例：</p><pre><code class="java"> @GetMapping(&quot;/query&quot;)    @ApiOperation(&quot;管理员审核文章列表&quot;)    public BaseResponse getListByExample(){       xxx                                 }</code></pre><h2 id="生成API"><a href="#生成API" class="headerlink" title="生成API"></a>生成API</h2><p>访问：IP:port/swagger-ui.html</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的使用心得</title>
      <link href="/2021/02/08/git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2021/02/08/git%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用心得"><a href="#git的使用心得" class="headerlink" title="git的使用心得"></a>git的使用心得</h1><p>由于考研失利，最近重新拾起了java项目。在学spring cloud的时候想到了单点登录，之后就想到了spring security OAuth 2。于是在大改我的blog项目之前，先要弄一个example源码试试看。但是之前总是用git的可视化界面，现在想装个B,用命令行编写的时候，突然发现自己的命令全忘了，于是学习了一会git命令。并且用这个博客记录下来。</p><hr><h2 id="本地电脑连接远程github"><a href="#本地电脑连接远程github" class="headerlink" title="本地电脑连接远程github"></a>本地电脑连接远程github</h2><p>其实这个做法主要就是在你本地生成ssh密钥，然后将公钥给你的远程账号就ok了。</p><ol><li>下载和配置Git</li></ol><p>去官网下载个git，之后再命令行界面type git出现一堆结果就证明成功了。</p><pre><code class="bash">git config --global user.name &quot;YOUR NAME&quot;git config --global user.email &quot;YOUR EMAIL&quot;</code></pre><p>网上都说下载完之后要配置名字邮箱，不过这两个和你的git账号没有关系，随便写就行。</p><blockquote><p>更新与3/1/2021,其实上面的那个邮箱还是有点用的，如果你这里配置的用户名和邮箱和你的git账号不一致的话，git push的时候你的Git账号里面是没有contribution的</p></blockquote><ol start="2"><li>生成 ssh<br>首先我们要有我们的ssh命令，在windows里面生成ssh的rsa密钥，具体命令如下：</li></ol><pre><code class="bash">ssh-keygon -t rsa -c &quot;&quot;# 引号里面是邮箱，外国人有毛病，什么玩意都要弄个邮箱，我就直接为null了</code></pre><p>生成的ssh文件一般都在 ~/.ssh/里面</p><p><a href="https://imgchr.com/i/yUg8pj" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/08/yUg8pj.png" alt="yUg8pj.png"></a></p><p>我们打开我们的git-&gt; settings -&gt; ssh….<br>将我们的pub公钥上传上去就ok了</p><blockquote><p>注意，git项目中有三种方式可以下载下来：</p><ol><li>HTTPS(这个和上面的ssh没有关系，第一次push还是要输入面)</li><li>SSH</li><li>zip包</li></ol></blockquote><h2 id="git创建过程中得基本命令"><a href="#git创建过程中得基本命令" class="headerlink" title="git创建过程中得基本命令"></a>git创建过程中得基本命令</h2><p>我首先在自己得本地创建了idea工程，之后去git里面创建仓库repos。<br>其实，git里面有新手引导，我们一步步得看。<br><a href="https://imgchr.com/i/yUR3yn" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/08/yUR3yn.png" alt="yUR3yn.png"></a></p><p>首先进入我们得仓库目录，创建README文件，之后git init 进行初始化仓库。</p><blockquote><p>git branch -M main  这个意思是将你本地得分支改名字，我这里初始得就是master，我就不改了</p></blockquote><p>我这里由于idea有add功能么，我就没有add我的idea文件，直接add的readme,之后就是commit 进行提交。</p><blockquote><p>git remote add origin xxxxx 这个意思是添加一下这个仓库可以remote的路径.注意 remote里面可以存多个url，毕竟你的git和gitee可以同时存仓库。 origin是在存在本地的名字，相当于id，到时候我们直接pull或者Push的时候直接带着id就可以了。</p></blockquote><p>后面我们发现git push 后面加了一个-u 这个是绑定一个默认远程仓库，以后还想要push这个仓库直接git push命令即可。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>有的时候，我们并不想把一些ide之类的自动生成的文件push上去，所以我们可以编写一个忽略文件。</p><p>但是有的时候写上这个之后，发现并不起作用，所以我们需要清空git的缓存，并重新添加。</p><pre><code class="bash">git rm -r --cached .</code></pre><h2 id="多个git项目配置"><a href="#多个git项目配置" class="headerlink" title="多个git项目配置"></a>多个git项目配置</h2><p>需求： 当我们在不同的项目中可能需要不同的git账户，或者需要不同的用户名和邮箱。</p><p>解决方法：<br><strong>方法一</strong><br>打开项目的.git/config文件夹，增加下面的内容即可：</p><pre><code class="text">[user]    name = xxx    email = xxx@xxx.com</code></pre><p><strong>方法二</strong></p><pre><code class="bash">git config user.name &quot;YOUR NAME&quot;git config  user.email &quot;YOUR EMAIL&quot;</code></pre><blockquote><p>注意 这个和之前全局的名字邮箱命令相比少了–global，也就是全局配置文件。这个是局部配置文件里面修改的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring mvc常见的拦截器与过滤器</title>
      <link href="/2021/02/02/spring-mvc%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2021/02/02/spring-mvc%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-mvc常见的拦截器与过滤器"><a href="#spring-mvc常见的拦截器与过滤器" class="headerlink" title="spring mvc常见的拦截器与过滤器"></a>spring mvc常见的拦截器与过滤器</h1><h2 id="由于最近面试比较多，所以要临时抱佛脚巩固一下基础知识"><a href="#由于最近面试比较多，所以要临时抱佛脚巩固一下基础知识" class="headerlink" title="由于最近面试比较多，所以要临时抱佛脚巩固一下基础知识"></a>由于最近面试比较多，所以要临时抱佛脚巩固一下基础知识</h2><p>在聊Filter和handler之前呢，我们要清楚spring mvc的请求流程</p><blockquote><p>url -&gt; preFilter -&gt; preHandler -&gt; DispatcherServlet -&gt; requestMapping -&gt; postHandler -&gt; afterCompletion -&gt; doFilter</p></blockquote><p>大概是上面的流程，我们也可以用下面的图来表示</p><p><a href="https://imgchr.com/i/yejN6K" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/01/yejN6K.png" alt="yejN6K.png"></a></p><p>只要记住 Filter<br>最开始就要启动就行了</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>这里我只说一下spring mvc里面常见的Filter </p><ul><li>GenericFilterBean</li></ul><p>org.springframework.web.filter.GenericFilterBean.java</p><pre><code class="java">public abstract class GenericFilterBean implements        Filter, BeanNameAware, EnvironmentAware, ServletContextAware, InitializingBean, DisposableBean {    @Override    public final void setBeanName(String beanName) {        this.beanName = beanName;    }    @Override    public void setEnvironment(Environment environment) {        this.environment = environment;    }    @Override    public final void setServletContext(ServletContext servletContext) {        this.servletContext = servletContext;    }    @Override    public void afterPropertiesSet() throws ServletException {        initFilterBean();    }}//......</code></pre><blockquote><p>这个类主要实现了spring生命周期的几个接口，方便作为bean纳入IOC容器管理。</p></blockquote><ul><li>OncePerRequestFilter<br>spring 里面所有的Filter 都默认继承这个东西，意思是只用一次的Filter</li></ul><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p>HandlerInterceptor</p><p>这个接口定义了三个方法，preHandle，postHandle，afterCompletion</p><ul><li>preHandle<br>这个里头返回false，则会停止继续往下执行</li><li>postHandle<br>后处理回调方法，实现处理器的后处理，但在渲染视图之前执行，可以在这里额外往视图添加额外的变量等(在preHandle成功执行完，返回true的情况下执行)</li><li>afterCompletion<br>在preHandle成功执行完，返回true的情况下执行.整个请求处理完毕回调方法，即在视图渲染完毕时回调</li></ul><h1 id="补充-spring-boot过滤器FilterRegistrationBean"><a href="#补充-spring-boot过滤器FilterRegistrationBean" class="headerlink" title="补充 spring boot过滤器FilterRegistrationBean"></a>补充 spring boot过滤器FilterRegistrationBean</h1><p>由于 Filter写的多了之后，我们要设置一下启动顺序，原来的Filter类实现了OncePreFilter接口之后加个@WebFilter就行了，现在不行了，这个东西不能设置启动顺序，所以需要这个我称之为过滤器的注册中心的东西注册一下</p><p>下面，贴出java常见的过滤器注册代码</p><pre><code class="java">@Configurationpublic class DemoConfiguration {    @Bean    public FilterRegistrationBean&lt;Test1Filter&gt; RegistTest1(){        //通过FilterRegistrationBean实例设置优先级可以生效        //通过@WebFilter无效        FilterRegistrationBean&lt;Test1Filter&gt; bean = new FilterRegistrationBean&lt;Test1Filter&gt;();        bean.setFilter(new Test1Filter());//注册自定义过滤器        bean.setName(&quot;flilter1&quot;);//过滤器名称        bean.addUrlPatterns(&quot;/*&quot;);//过滤所有路径        bean.setOrder(1);//优先级，最顶级        return bean;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统心得(随时更新)</title>
      <link href="/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BF%83%E5%BE%97/"/>
      <url>/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统心得-随时更新"><a href="#计算机操作系统心得-随时更新" class="headerlink" title="计算机操作系统心得(随时更新)"></a>计算机操作系统心得(随时更新)</h1><p>由于最近正在找工作，所以会偶尔看到一些面试题，而这些面试题其实好多都是来自大学里面的一些基础知识。由于大学时候看不起那些，所以只能现在恶补一下(后悔)。</p><hr><h2 id="进程大家族之-孤儿进程和僵尸进程"><a href="#进程大家族之-孤儿进程和僵尸进程" class="headerlink" title="进程大家族之 孤儿进程和僵尸进程"></a>进程大家族之 孤儿进程和僵尸进程</h2><p>今天刷到了一个公众号里面的文章，其中一个Linux命令是关于 top的进程监控命令，不由得想起了大学时候学过的孤儿进程和僵尸进程，特此记录一下：</p><ul><li>孤儿进程</li></ul><p>想象一下孤儿的字面意思，就是没有了爹和妈。这样比较好理解一下程序中的具体含义：</p><p>子进程还在进行中，父进程呢？ 啪 ！ 结束了。他们的pid 突然就结束了，这样子进程没有了爹妈就变成了孤儿进程</p><ul><li>僵尸进程</li></ul><p>僵尸的字面意思是什么？ 死而未僵。<br>在程序里面的含义就是，你父进程 Fork了子进程，结果呢，没有wait或者waitAll回收他们，子进程进行完毕之后，没有回收，他们子进程的状态描述符就依然存在于系统之中</p><h2 id="内存家族之-内存泄漏和内存溢出"><a href="#内存家族之-内存泄漏和内存溢出" class="headerlink" title="内存家族之 内存泄漏和内存溢出"></a>内存家族之 内存泄漏和内存溢出</h2><p>内存泄漏和内存溢出其实我个人感觉是密不可分的，为啥嘞？且听我道来~</p><ul><li><p>内存泄漏</p><p>意思就是内存里面有太多的没用垃圾(不用，但是没有释放的对象，最让我印象深刻的就是c语言里面的malloc 函数，你创建完了但是没有release),让你感觉你的可用内存越来越少。</p></li></ul><ul><li>内存溢出(OOM)</li></ul><p>Java程序员最不想看到的Exception，OOM可以算一个了，通俗的来讲就是内存不够了，但是现在立马需要一个大的内存，结果就是溢出了。</p><blockquote><p>我的个人感觉来说，好多时候，其实在Java程序在运行的过程中，就是由于代码编写不规范等原因，造成的内存泄漏，从来导致了OOM</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 操作系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下查看进程相关信息命令</title>
      <link href="/2021/01/23/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/01/23/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Alibaba项目构建(二)</title>
      <link href="/2021/01/22/Spring-Cloud-Alibaba%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA(%E4%BA%8C)/"/>
      <url>/2021/01/22/Spring-Cloud-Alibaba%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Alibaba项目构建-二"><a href="#Spring-Cloud-Alibaba项目构建-二" class="headerlink" title="Spring Cloud Alibaba项目构建(二)"></a>Spring Cloud Alibaba项目构建(二)</h1><hr><h2 id="nacos下的微服务通信"><a href="#nacos下的微服务通信" class="headerlink" title="nacos下的微服务通信"></a>nacos下的微服务通信</h2><p>我们在上一篇文章中写了provider模块，并且加载到了nacos的服务列表上面，这次我们开始创建消费者</p><p>还是和之前一样创建consumer模块，并且加载pom包，写application项目，创建启动类，这里不再赘述。</p><h3 id="RestTemplate方式"><a href="#RestTemplate方式" class="headerlink" title="RestTemplate方式"></a>RestTemplate方式</h3><p>经过查阅nacos文档发现，Http方式有两种请求方式，一种是RestTemplate(说白了就是一个Http请求的API，演示而已，基本项目不适用),另一种是Feign方式(一个假的Http客户端，比较高级，开发中可以使用)，这里先使用RestTemplate方式演示</p><h4 id="创建Bean对象"><a href="#创建Bean对象" class="headerlink" title="创建Bean对象"></a>创建Bean对象</h4><p>我们先创建一个config文件夹，里面存RestTemplateBean,因为之前我开发SSM的时候，bean都是写在配置文件中的，所以才没有放到实体文件夹中。</p><pre><code class="java">/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2021 2021/1/21 10:17 * Description: nacos消费者配置 */@Configurationpublic class NacosConsumerConfig {    /**    * 功能描述: 相当于 SSM中 &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;    * @Return: org.springframework.web.client.RestTemplate    * @Author: WHOAMI    * @Date: 2021/1/21 10:20     */    @Bean    @LoadBalanced    public RestTemplate restTemplate(){        return new RestTemplate();    }}</code></pre><blockquote><p>LoadBalanced 注解是负载均衡的意思</p></blockquote><h4 id="创建Contoller"><a href="#创建Contoller" class="headerlink" title="创建Contoller"></a>创建Contoller</h4><p>Bean写好了，接下来就是自动注入。注意我们必须创建一个常量的RestTemplate，我们需要考虑到线程安全，所以Controller代码如下：</p><pre><code class="java">/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2021 2021/1/22 10:21 * Description: 消费者cobtroller */@RestControllerpublic class DemoController {    private final RestTemplate restTemplate;    @Autowired    public DemoController(RestTemplate restTemplate) {        this.restTemplate = restTemplate;    }    @GetMapping(value = &quot;/demo/{string}&quot;)    public String consumerdemoString(@PathVariable(&quot;string&quot;)String string ){        return restTemplate.getForObject(&quot;http://demo-provider/demo/&quot;+string,String.class);    }}</code></pre><blockquote><p>restTemplate.getForObject完成了一次Http请求</p></blockquote><p>启动项目，访问链接，完成!</p><h3 id="Feign方式"><a href="#Feign方式" class="headerlink" title="Feign方式"></a>Feign方式</h3><p>我们发现还得写一个Bean,是不是显得很臃肿？我们可不可以写一个接口？Feign提供了解决方案</p><p>首先我们要在我们的consumer项目的pom文件中填写Feign的依赖</p><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>在启动类里面写上 @EnableFeignClients，并且创建一个service文件夹，创建接口服务</p><p>代码如下：</p><pre><code class="java">/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2021 2021/1/22 10:51 * Description: Feign方法请求服务 */@FeignClient(&quot;demo-provider&quot;)public interface DemoService {    @GetMapping(&quot;/demo/{string}&quot;)    String demoString(@PathVariable(&quot;string&quot;)String string);}</code></pre><p>其中FeignClient里面的名字就是服务的名字，接着就像是我们的平常调用service接口那样调用即可。</p><h2 id="nacos的动态配置中心"><a href="#nacos的动态配置中心" class="headerlink" title="nacos的动态配置中心"></a>nacos的动态配置中心</h2><p>在上一篇文章中我们提到，nacos实现了可以在外部修改配置，不需要工程重新启动的功能我们现在可以配置一下:</p><ol><li>首先，在我们想要编辑的模块下面的配置里面添加这样的依赖</li></ol><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><ol start="2"><li>之后我们需要打开我们的nacos设置界面</li></ol><p><a href="https://imgchr.com/i/so0VRf" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/22/so0VRf.png" alt="so0VRf.png"></a></p><p>在这里我们添加配置文件 </p><p><a href="https://imgchr.com/i/soDF8P" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/22/soDF8P.png" alt="soDF8P.png"></a></p><blockquote><p>名字随便起，但是格式一定是像上面的箭头所指的一致。之后就只需要把我们服务中的配置文件里面的内容复制粘贴下就好了</p></blockquote><ol start="3"><li>下一步我们要编写一个文件 “ bootstrap.properties”文件</li></ol><blockquote><p>我们要知道spring boot项目文件加载顺序是<br>bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml</p></blockquote><p>所以我们知道有的时候我们明明在application配置文件中写了东西但是没有加载进去，可能就是因为优先级太低没有读取的原因</p><pre><code class="properties">spring.application.name=demo-consumerspring.cloud.nacos.config.server-addr=192.168.3.10:8848spring.cloud.nacos.config.file-extension=yamlspring.profiles.active=dev</code></pre><p>启动，测试访问服务，成功</p><blockquote><p>由于我们项目在实际的jar包启动一般都是这样的 java -jar xxx.jar –spring.profile.active=prod/dev 所以我们的配置文件一般不写启动环境设置，而是不同的环境不同的配置文件</p></blockquote><h3 id="nacos动态刷新"><a href="#nacos动态刷新" class="headerlink" title="nacos动态刷新"></a>nacos动态刷新</h3><p>我们可以测试一下他的动态刷新功能，我们刚才的nacos配置文件下面随便填点东西，例：test.name=”张巨根”</p><p>然后我们在我们想要获取配置的测试controller类下面添加<strong>@RefreshScope</strong>注解，之后通过@Value注解获取配置就可以了。</p><p>如果在nacos修改配置之后，页面刷新会动态显示配置</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派的一档子事儿</title>
      <link href="/2021/01/14/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%B8%80%E6%A1%A3%E5%AD%90%E4%BA%8B%E5%84%BF/"/>
      <url>/2021/01/14/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%B8%80%E6%A1%A3%E5%AD%90%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派的一档子事儿"><a href="#树莓派的一档子事儿" class="headerlink" title="树莓派的一档子事儿"></a>树莓派的一档子事儿</h1><p>昨晚导师给我们安排了一下毕业设计的事儿，我选了一个类斗鱼的毕业设计。查找了半天资料，打算用obs进行推流，然后nginx+ rmtp协议搭建一个linux流服务器。<br>但是由于我的电脑空间实在不够用了，重新启动一个Linux虚拟机恐怕要了我的电脑的老命。无奈只能翻一下家里的垃圾对，终于找到了一个学校比赛时候获得的一个树莓派1B(100块都不到)。我就想着直接用那个搭个单机版的不就ok了？</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>都2021年了，还用带有GUI的linux?</p><blockquote><p>那肯定是terminal香啊</p></blockquote><p>然后我去<a href="https://www.raspberrypi.org/software/operating-systems/" target="_blank" rel="noopener">官网</a>下了一个Lite版本的系统压缩包，一共不到200M</p><h3 id="写入系统镜像"><a href="#写入系统镜像" class="headerlink" title="写入系统镜像"></a>写入系统镜像</h3><p>由于好久没用了，所以又翻箱倒柜的找到了几年前的读卡器，插上读卡器，MiniTools软件格式一下分区，然后下载了一个专门写入镜像的<a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">软件</a></p><h2 id="准备启动"><a href="#准备启动" class="headerlink" title="准备启动"></a>准备启动</h2><p>写入分区之后，直接插到家里的路由器LAN口上，打开后台管理，查看一下上网列表<br><a href="https://imgchr.com/i/sapfaR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/14/sapfaR.png" alt="sapfaR.png"></a></p><blockquote><p>不用这个也可以，用ipscan扫一下网段Ip就行，主要是确定树莓派的Ip</p></blockquote><p>我啪的一下，打开了xshell，很快啊！</p><blockquote><p>树莓派默认账户：pi  密码：raspberry</p></blockquote><p>可是后来xshell被连接拒绝，百度一下知道树莓派OS默认拒绝ssh，所以重新连接sd卡，在根目录下面新建一个ssh文件</p><p>重新连接OK!</p><h2 id="账号问题"><a href="#账号问题" class="headerlink" title="账号问题"></a>账号问题</h2><p>由于我们登陆的是pi用户，所以有的时候下载软件或者修改配置文件的时候就显得很鸡肋，所以启动我们的root用户就显得极为重要</p><pre><code class="bash">sudo passwd root # 给root设置密码su root #切换root用户</code></pre><p>之后，我们还是没法用root远程ssh登陆，是因为树莓派这家伙又是默认禁止了</p><pre><code class="bash">vi /etc/ssh/sshd_config/Authentication # 查找认证</code></pre><p><a href="https://imgchr.com/i/sai1eg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/14/sai1eg.png" alt="sai1eg.png"></a></p><p>修改上面那一坨为：</p><pre><code># Authentication:LoginGraceTime 120PermitRootLogin yesStrictModes yes</code></pre><h3 id="重启sshd服务"><a href="#重启sshd服务" class="headerlink" title="重启sshd服务"></a>重启sshd服务</h3><pre><code class="bash">systemctl restart sshd</code></pre><p>当然为了安全着想，你也可以每次涉及到重要命令的时候前面添加一下sudo，不过对我来说就是特别麻烦了。</p><h2 id="IP地址？"><a href="#IP地址？" class="headerlink" title="IP地址？"></a>IP地址？</h2><p>我们需要给树莓派设置静态IP,至于为什么…你自己体会，笔者不多说</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法心得</title>
      <link href="/2021/01/09/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/"/>
      <url>/2021/01/09/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="算法心得"><a href="#算法心得" class="headerlink" title="算法心得"></a>算法心得</h1><h2 id="选择排序与冒泡排序之间的关系"><a href="#选择排序与冒泡排序之间的关系" class="headerlink" title="选择排序与冒泡排序之间的关系"></a>选择排序与冒泡排序之间的关系</h2><p>这几天学习算法，发现了一个有意思的现象。选择排序与冒泡排序的时间复杂度都是O(n^2)</p><p>并且呢，冒泡排序是两两相邻的去比较。而选择排序是一次比较所有。</p><pre><code class="java">/**    * 功能描述: 选择排序算法  --&gt; int[] 是引用传递，即使不return input的指也会改变    * @Param: [input]     * @Return: int[]    * @Author: ADROITWOLF    * @Date: 2021/2/27 21:33     */    public static int[] selectSort(int [] input){        int min = 0;        for (int i =0;i&lt;input.length;i++ ){            min = i;            for(int j = i+1;j&lt;input.length;j++){                 min = input[min] &gt; input[j] ? j:min;            }            if(i != min){ //说明最小值已经是那啥了                int tmp = input[i];                input[i] = input[min];                input[min] = tmp;            }        }        return input;    }    /**    * 功能描述: 冒泡排序    * @Param: [input]    * @Return: int[]    * @Author: ADROITWOLF    * @Date: 2021/2/27 21:56     */    public static int[] bubbleSort(int [] input){        for (int i=0;i&lt;input.length;i++){            for(int j=0;j&lt;input.length-1;j++){                if(input[j] &gt; input[j+1]){                    int tmp = input[j];                    input [j] = input[j+1];                    input[j+1] = tmp;                }            }        }        return input;    }</code></pre><h2 id="为什么HashMap的时间复杂度可以为O-1"><a href="#为什么HashMap的时间复杂度可以为O-1" class="headerlink" title="为什么HashMap的时间复杂度可以为O(1)"></a>为什么HashMap的时间复杂度可以为O(1)</h2><p>通过《算法图解》这本书得知，散列表的查找时间复杂度是O(1)。具体实现方法是将输入数据和索引坐标做一个映射，并且散列表是通过数组来实现存储的，数组的查找时间复杂度为O(1)。HashMap的底层实现原理也是利用的散列表，所以他的时间复杂度为O(1).</p><p>并且，HashMap的使用极为广泛：</p><ol><li>用作去重</li><li>作为缓存</li><li>映射查找遍历。</li></ol><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>尾递归说白了就是，在函数的后面直接return 自己，且没有任何的计算操作。举个例子：</p><pre><code class="java">public int recursion(int a){    if xxx{        return 1;    }else{        return recursion(a*x);    }}</code></pre><blockquote><p>我们都知道递归会将函数压栈，不仅消耗大量的时间，而且有很大的不确定性，稳定性无法保证。<br>尾递归，则是编译器自动的将不重复调用栈，而是直接覆盖函数栈，使空间复杂度从O(n)变成了O(1)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署云服务器</title>
      <link href="/2021/01/08/hexo%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/01/08/hexo%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo部署云服务器"><a href="#hexo部署云服务器" class="headerlink" title="hexo部署云服务器"></a>hexo部署云服务器</h1><p>之前我的hexo是直接部署到git上面的，但是随着我的VPN到期，访问博客的速度是越来越慢，最后打算直接部署到linux服务器上。</p><h2 id="项目环境准备"><a href="#项目环境准备" class="headerlink" title="项目环境准备"></a>项目环境准备</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>服务器上面需要安装git，创建一个空仓库，然后利用钩子监控，每次有push过来直接clone到nginx的文件夹里面。</p><pre><code class="bash">yum install -y git </code></pre><h3 id="git用户"><a href="#git用户" class="headerlink" title="git用户"></a>git用户</h3><p>再有就是我们不能直接利用root用户来远程push，这样权限太大了，我们需要直接创建用户，这里我直接创建git用户</p><pre><code class="bash">usradd gitpasswd git</code></pre><p>这里的用户都是git组里面的，具体查询可以根据id命令或者groups命令查询。</p><p>我们还需要SSH连接，这时候可以参考我的博文：SSH免密这篇文章</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx用来代理服务器，下载安装nginx的文章我其他的文章有写</p><p>我们这里指定/var/blog文件夹为Hexo部署之后的文件夹</p><p>我们用git用户远程部署，所以需要将此文件夹设置成git用户</p><blockquote><p>这一步非常重要</p></blockquote><pre><code class="bash">chown -R git:git /var/blog        #组:用户</code></pre><h2 id="准备上传"><a href="#准备上传" class="headerlink" title="准备上传"></a>准备上传</h2><p>我们需要登陆我们的git用户</p><pre><code class="bash">su git cd /home/git</code></pre><h3 id="创建一个裸git项目"><a href="#创建一个裸git项目" class="headerlink" title="创建一个裸git项目"></a>创建一个裸git项目</h3><pre><code class="bash">git init -bare  blog.gitcd blog.git</code></pre><p><a href="https://imgchr.com/i/sKasUg" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/sKasUg.png" alt="sKasUg.png"></a></p><h3 id="创建钩子"><a href="#创建钩子" class="headerlink" title="创建钩子"></a>创建钩子</h3><pre><code class="bash">vi ./hooks/post-receive# 下面为文件内容，可以直接粘贴,注意下面的注释后面一定要跟回车#!/bin/bashgit  --work-tree=/var/blog --git-dir=/home/git/blog.git checkout -f# 保存退出</code></pre><h3 id="本地Hexo配置文件修改"><a href="#本地Hexo配置文件修改" class="headerlink" title="本地Hexo配置文件修改"></a>本地Hexo配置文件修改</h3><p>先备份一份本地_config配置文件，然后打开，拉到最底</p><p>里面有这些项：</p><pre><code>deploy:  # 类型  type: git  # 仓库  repo: 用户@服务器IP或域名地址:服务器上面创建的仓库绝对地址  # 分支  branch: master</code></pre><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>打开服务器的nginx的conf里面的nginx.conf文件</p><p>创建一个server</p><p><a href="https://imgchr.com/i/sKdfWd" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/sKdfWd.png" alt="sKdfWd.png"></a></p><p>重启 </p><pre><code class="bash">nginx -s reload</code></pre><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>上传命令</p><p>本地Hexo </p><pre><code class="bash">hexo g -d</code></pre><p>查看/var/blog里面出现文件,配置成功</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh免密</title>
      <link href="/2021/01/08/ssh%E5%85%8D%E5%AF%86/"/>
      <url>/2021/01/08/ssh%E5%85%8D%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh免密"><a href="#ssh免密" class="headerlink" title="ssh免密"></a>ssh免密</h1><p>最近由于经常用linux，尤其是git这一方面，需要经常的push项目，而没有ssh的时候经常会需要登陆密码登陆，很麻烦。</p><p>查了一堆文章后，写了下面最适合我的这篇文章</p><p>首先我们要有我们的ssh命令，在windows里面生成ssh的rsa密钥，具体命令如下：</p><pre><code class="bash">ssh-keygon -t rsa -c &quot;&quot;# 引号里面是邮箱，外国人有毛病，什么玩意都要弄个邮箱，我就直接为null了</code></pre><p>生成的ssh文件在 /c/Users/用户名/.ssh/里面，其中带.pub的为公钥，不带的为私钥</p><p>之后我们要在我们的服务器上，创建一个想要本地服务器登陆的账号：</p><pre><code class="bash">usradd git #由于我这里是为了用Git,所以直接创建的gitpasswd git #root用户创建密码</code></pre><p>创建成功之后打开我们的Windows里面的git工具，然后输入下面的命令，将本地的公钥上传到服务器上面</p><pre><code class="bash">ssh-copy-id git@192.168.3.99# 用户名@ip地址</code></pre><p><a href="https://imgchr.com/i/sKA00O" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/sKA00O.png" alt="sKA00O.png"></a></p><p>输入密码后，成功</p><blockquote><p>这个命令的原理是 将 /c/Users/用户名/.ssh/id_rsa.pub 里面的内容复制到 远程服务器git用户的 /home/git/.ssh/authorized_keys文件里面最后一行中,如果不想用命令直接手动操作也可以。</p></blockquote><h2 id="测试ssh连接命令"><a href="#测试ssh连接命令" class="headerlink" title="测试ssh连接命令"></a>测试ssh连接命令</h2><pre><code class="bash">ssh -v git@192.168.3.99</code></pre><p><a href="https://imgchr.com/i/sKEaCj" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/sKEaCj.png" alt="sKEaCj.png"></a></p><p>上面图片可以看出我们正在密钥校验，成功之后可直接登入服务器。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装nacos</title>
      <link href="/2021/01/08/Centos7%E5%AE%89%E8%A3%85nacos/"/>
      <url>/2021/01/08/Centos7%E5%AE%89%E8%A3%85nacos/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装nacos"><a href="#Centos7安装nacos" class="headerlink" title="Centos7安装nacos"></a>Centos7安装nacos</h1><p>打开nacos<a href="https://nacos.io/zh-cn/docs/quick-start.html" target="_blank" rel="noopener">官网首页</a></p><p>在这里我们不使用git,而是直接用wget命令获取最新版本,所以我们需要先下载启动环境</p><blockquote><p>请直接参考我的博客项目 Centos7安装java和maven</p></blockquote><p>安装完环境之后我们需要下载并安装nacos<br><a href="https://imgchr.com/i/snBwi4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/snBwi4.png" alt="snBwi4.png"></a></p><p>去github下载你想要下载的版本，这里我下载的是1.4.0版本</p><pre><code class="bash">wget https://github.com/alibaba/nacos/releases/download/1.4.0/nacos-server-1.4.0.tar.gz</code></pre><p><strong>解压</strong></p><pre><code class="bash">tar -zxvf nacos-server-1.4.0.tar.gz -C /usr/local/</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code class="bash">cd /usr/local/nacos/bin./startup.sh -m standalone# 以单机模式启动</code></pre><h2 id="运行相关"><a href="#运行相关" class="headerlink" title="运行相关"></a>运行相关</h2><p>账号密码： </p><blockquote><p>nacos/nacos</p></blockquote><p>网址：</p><p>IP:8848/nacos</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Alibaba项目构建(一)</title>
      <link href="/2021/01/08/Spring-Cloud-Alibaba%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA(%E4%B8%80)/"/>
      <url>/2021/01/08/Spring-Cloud-Alibaba%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Alibaba项目构建-一"><a href="#Spring-Cloud-Alibaba项目构建-一" class="headerlink" title="Spring Cloud Alibaba项目构建(一)"></a>Spring Cloud Alibaba项目构建(一)</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>由于我之前的eblog单机版本的springboot版本为2.1.4,所以之后的所有的项目都以该项目版本为基础。</p><p><a href="https://imgchr.com/i/sWb0ld" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sWb0ld.png" alt="sWb0ld.png"></a></p><p>我们打开spring官网里面的spring cloud alibaba的api界面，这里我选择的是2.1.2版本 spring cloud 是GreenwichSR5版本</p><table><thead><tr><th>Spring Cloud Version</th><th>Spring Cloud Alibaba Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>Spring Cloud Hoxton.SR3</td><td>2.2.1.RELEASE</td><td>2.2.5.RELEASE</td></tr><tr><td>Spring Cloud Hoxton.RELEASE</td><td>2.2.0.RELEASE</td><td>2.2.X.RELEASE</td></tr><tr><td>Spring Cloud Greenwich</td><td>2.1.2.RELEASE</td><td>2.1.X.RELEASE</td></tr><tr><td>Spring Cloud Finchley</td><td>2.0.2.RELEASE</td><td>2.0.X.RELEASE</td></tr><tr><td>Spring Cloud Edgware</td><td>1.5.1.RELEASE</td><td>1.5.X.RELEASE</td></tr></tbody></table><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>由于我们搞的是微服务，所以首先要有一个父工程来规定依赖版本</p><p>我们首先创建一个maven工程，将packaging设置成pom</p><p>下面是我的父工程的pom示例</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.cloud&lt;/groupId&gt;    &lt;artifactId&gt;eblog&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;description&gt;eblog父项目&lt;/description&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;        &lt;spring.cloud.alibaba.version&gt;2.1.0.RELEASE&lt;/spring.cloud.alibaba.version&gt;        &lt;spring.cloud.version&gt;Greenwich.SR5&lt;/spring.cloud.version&gt;    &lt;/properties&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;             &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;${spring.cloud.alibaba.version}&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;${spring.cloud.version}&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="与nacos整合"><a href="#与nacos整合" class="headerlink" title="与nacos整合"></a>与nacos整合</h2><blockquote><p>建议查看nacos<a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">官方网站</a>springcloud整合的官方文档</p></blockquote><blockquote><p>保证首先将nacos服务打开，如果没有安装请查看博客内相关安装教程</p></blockquote><p>首先我们创建一个名字为<strong>provider</strong>的模块用来注册(其实正常项目中所有的项目大部分都是注册到注册中心的，这里只是为了演示，只写了一个模块)，创建pom文件</p><blockquote><p>最终的文件目录为下图：</p></blockquote><p><a href="https://imgchr.com/i/sfew9g" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sfew9g.png" alt="sfew9g.png"></a></p><h3 id="nacos-jar包说明"><a href="#nacos-jar包说明" class="headerlink" title="nacos jar包说明"></a>nacos jar包说明</h3><ul><li>config 配置中心<br>  通过搜索文章我发现有 nacos …config依赖，经过查询发现，这是一个nacos服务中的一个动态配置的东西，相当于咱们的springboot中的application.yml这样一个东西。但是我们知道，修改application不是得重启springboot么，这样太麻烦了，所以config可以动态修改里面的东西。</li><li>discovery 服务注册/发现</li></ul><p>总的来说，我们做微服务肯定会有服务注册和发现的，这个就是来做这个的。</p><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>并且在父工程中的pom里面写入下面的，如果ide自动生成则无视：</p><pre><code class="pom">&lt;modules&gt;        &lt;module&gt;provider&lt;/module&gt;&lt;/modules&gt;</code></pre><p>provider文件中的pom为下面所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;eblog&lt;/artifactId&gt;        &lt;groupId&gt;com.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;provider&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;!--nacos discovery依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>我们spring boot项目需要程序入口：</p><p>创建上图中的文件目录，并创建java文件<br>源代码如下:</p><pre><code class="java">package com.cloud.demo.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2021 2021/1/20 20:36 * Description: 项目启动入口 */@SpringBootApplication@EnableDiscoveryClientpublic class ProviderApplication {    public static void main(String args[]){        SpringApplication.run(ProviderApplication.class,args);    }}</code></pre><ul><li>SpringBootApplication 注解是springboot的扫描类</li><li>EnableDiscoveryClient 注解是nacos扫描类</li></ul><h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p>我随便写一个controller的demo</p><pre><code class="java">package com.cloud.demo.provider.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2021 2021/1/20 20:42 * Description: 测试控制层 */@RestControllerpublic class DemoContoller {    @GetMapping(value = &quot;/demo/{string}&quot;)    public String demoTesting(@PathVariable(&quot;string&quot;) String string){        return &quot;hello&quot; + string;    }}</code></pre><h3 id="resources文件"><a href="#resources文件" class="headerlink" title="resources文件"></a>resources文件</h3><p>resources文件中的application.yml文件：</p><pre><code class="yml">spring:  application:    name: demo-provider  cloud:    nacos:      discovery:        server-addr: 192.168.3.10:8848        # 这里面的nacos地址是你自己的nacos-server的地址server:  port: 8081# 健康监控management:  endpoints:    web:      exposure:        include: &#39;*&#39;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先启动这个provider模块项目</p><p>访问网址并成功返回内容：<br><a href="https://imgchr.com/i/sfm3PU" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sfm3PU.png" alt="sfm3PU.png"></a></p><p>打开nacos管理面板，打开服务列表，如下图所示，则代表注册成功</p><p><a href="https://imgchr.com/i/sfmtM9" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/20/sfmtM9.png" alt="sfmtM9.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站业务架构的演变</title>
      <link href="/2021/01/07/%E7%BD%91%E7%AB%99%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98/"/>
      <url>/2021/01/07/%E7%BD%91%E7%AB%99%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8F%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx的那些事儿</title>
      <link href="/2021/01/05/nginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2021/01/05/nginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx的那些事儿"><a href="#nginx的那些事儿" class="headerlink" title="nginx的那些事儿"></a>nginx的那些事儿</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>下面的是我的nginx里面的一些重点的配置<br><code>`</code><br>http {<br>    upstream eblogserver{<br>        server eblog_server_1:8099 weight=1;<br>        server eblog_server_2:8098 weight=2;<br>    }</p></blockquote><pre><code>server {    listen       80;    server_name  localhost;    location / {        try_files $uri $uri/ /index.html last;        root /usr/share/nginx/html;        index  index.html;    }    location ^~ /server/ {    # 保证服务器访问的是真实ip地址    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;          proxy_pass http://eblogserver/;    }}</code></pre><p>}</p><pre><code>    我们要知道nginx是一个反向代理(说是这样说，其实就是代理一下服务器，正想代理就是代理客户端相当于我们的vpn)我们要清楚下面几个重点的关键字* http{} 用来嵌套多个server ：即我们的http请求，和配置代理缓存等等的web服务* server{} 用来处理http请求    * listen 监听端口    * upstream 里面用来写反向代理服务器的地址和权重    * location 后面跟正则表达式，用来处理用户请求的网址        * proxy_pass 反向代理的入口和上面的upstream一起用配置文件写好了，如何看写的正不正确，用下面的命令```bash./nginx -t (测试文件) -c(指定配置文件路径) ../conf/redis.conf</code></pre><p>如果显示successful，则证明nginx配置正确</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装nginx</title>
      <link href="/2021/01/05/centos7%E5%AE%89%E8%A3%85nginx/"/>
      <url>/2021/01/05/centos7%E5%AE%89%E8%A3%85nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装nginx"><a href="#Centos7安装nginx" class="headerlink" title="Centos7安装nginx"></a>Centos7安装nginx</h1><p>首先去官网下载想要的版本然后解压到linux上面</p><p>解压之后是这样的</p><p><a href="https://imgchr.com/i/sF6dHJ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/05/sF6dHJ.png" alt="sF6dHJ.png"></a></p><blockquote><p>这里面configure 就相当于我们windows上面的exe安装包</p></blockquote><ul><li>我们需要知道的是，nginx是编译安装的，不像tomcat那样，解压之后直接可以使用。</li></ul><ul><li>nginx是在c语言编译的，所以我们开始先安装所需要的环境</li></ul><blockquote><p>centos版本</p><pre><code class="bash">yum install -y gcc gcc-c++ pcre pcre-devel zlib  zlib-devel openssl-devel</code></pre></blockquote><blockquote><p>debain版本<br><code>`</code>bash<br>sudo apt-get install build-essential</p></blockquote><p>sudo apt-get install libtool</p><p>sudo apt-get install libpcre3 libpcre3-dev</p><p>sudo apt-get install zlib1g-dev</p><p>sudo apt-get install openssl</p><p>apt-get install libssl-dev</p><pre><code>接下来 安装nginx 具体命令为：```bash./configure --prefix=/usr/local/nginx# prefix指的是安装路径</code></pre><p>然后nginx会检查环境，完全通过后</p><pre><code class="bash">make &amp;&amp; make install #先编译，然后安装</code></pre><h2 id="nginx-的常用命令"><a href="#nginx-的常用命令" class="headerlink" title="nginx 的常用命令"></a>nginx 的常用命令</h2><ul><li>启动命令： ./sbin/nginx</li><li>重启命令： ./sbin/nginx -s reload</li><li>停止命令: ./sbin/nginx -s stop</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux网络(一)</title>
      <link href="/2020/03/06/linux%E7%BD%91%E7%BB%9C-%E4%B8%80/"/>
      <url>/2020/03/06/linux%E7%BD%91%E7%BB%9C-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="linux网络-一"><a href="#linux网络-一" class="headerlink" title="linux网络 (一)"></a>linux网络 (一)</h1><h2 id="ISO-OSI七层模型"><a href="#ISO-OSI七层模型" class="headerlink" title="ISO/ OSI七层模型"></a>ISO/ OSI七层模型</h2><p><img src="https://s2.ax1x.com/2020/03/06/3qcSXj.png" alt></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>现实设备： 网卡，网线，中继器，集线器</p><blockquote><p>注意，电脑上的MAC地址是PC的物理地址,IP地址是PC的逻辑地址</p></blockquote><p>作用:传输bit流</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>现实设备： 交换机,网桥 -&gt; 可以隔离冲突域</p><p>作用：将数据封装成帧</p><p>特点：arp   数据纠错 -&gt; 比如说 CSMA协议    </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>作用：提供逻辑地址</p><p>现实设备： 路由器</p><p>特点：路由选择协议 RIP、ICMP</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>特点：TCP UDP 流量控制、差错检测</p><p>作用：确定端口号</p><blockquote><p>端口 0-65535</p></blockquote><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>作用； 机器码 - 应用层编码 互相转换</p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>TCP/IP模型为实际应用的模型</p><p><img src="https://s2.ax1x.com/2020/03/07/3Oodyt.png" alt></p><h2 id="数据封装过程"><a href="#数据封装过程" class="headerlink" title="数据封装过程"></a>数据封装过程</h2><p><img src="https://s2.ax1x.com/2020/03/07/3ObnAK.png" alt></p><h2 id="数据包包头"><a href="#数据包包头" class="headerlink" title="数据包包头"></a>数据包包头</h2><h3 id="IP包头"><a href="#IP包头" class="headerlink" title="IP包头"></a>IP包头</h3><p>需要注意的是IP包头是至少20字节</p><p><img src="https://s2.ax1x.com/2020/03/07/3OLalQ.png" alt></p><h3 id="TCP包头"><a href="#TCP包头" class="headerlink" title="TCP包头"></a>TCP包头</h3><p><img src="https://s2.ax1x.com/2020/03/07/3Ovj8f.png" alt></p><h3 id="UDP包头"><a href="#UDP包头" class="headerlink" title="UDP包头"></a>UDP包头</h3><p><img src="https://s2.ax1x.com/2020/03/07/3OxZxU.png" alt></p><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>A类：1.0.0.0 - 126.255.255.255  私有IP 10.0.0.0 - 10.255.255.255</p><p>B类 128.0.0.0 - 191.255.255.255 私有IP 172.16.0.0-172.31.255.255</p><p>C类 192.0.0.0 - 223.255.255.255 私有IP 192.168.0.0 - 192.168.255.255</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>这里注意CIDR子网掩码的用法</p><p>网络号的求法： ip地址和子网掩码与运算</p><h2 id="TCP为什么需要三次握手和四次挥手"><a href="#TCP为什么需要三次握手和四次挥手" class="headerlink" title="TCP为什么需要三次握手和四次挥手"></a>TCP为什么需要三次握手和四次挥手</h2><p>在探讨这个问题之前，我们需要知道下面几个细节:</p><ol><li>TCP是全双工的，全双工我们至少需要两条信道，用来Host To Host的操作。</li><li>SYN是请求同步的意思，主机A需要向主机B发送数据</li><li>ACK是接收的意思，这个用来回复SYN请求。<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><a href="https://imgtu.com/i/cxEAvd" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/25/cxEAvd.png" alt="cxEAvd.png"></a></li></ol><p>如上图所示主机A 像主机B发送请求需要在<strong>自己的信道</strong>发送数据</p><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>主机B同意刚才A过来的同步请求，并且也像主机A请求需要在自己的信道发送数据(全双工的体现)。也就是说他的回复是ACK SYN</p><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>主机A通过B过来的请求</p><h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h3><p>主机A决定断开<strong>自己信道</strong>，FIN = 1</p><h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h3><p>主机B收到主机A的请求，但是，这里先不断开自己的信道，因为有可能自己还要发送数据，所以只收到数据ACK=1</p><h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h3><p>主机B决定断开自己信道，FIN=1</p><h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h3><p>主机A收到请求 ACK=1</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈401和403的区别</title>
      <link href="/2020/02/27/%E6%B5%85%E8%B0%88401%E5%92%8C403%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/27/%E6%B5%85%E8%B0%88401%E5%92%8C403%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈HTTP状态码401和403之间的区别"><a href="#浅谈HTTP状态码401和403之间的区别" class="headerlink" title="浅谈HTTP状态码401和403之间的区别"></a>浅谈HTTP状态码401和403之间的区别</h1><p>最近重新整理自己的项目底层机制，在处理401和403状态代码的时候产生了一点疑问，这两个到底有什么区别，因为这两个状态码都有权限不足的意思。那么什么时候用401，什么时候用403呢？</p><p>经过找了一番资料，自己整理了一下自己的理解，并记录下来。</p><p>我们先看一下状态码相对应的英文</p><blockquote><p>403  FORBIDDEN<br>401 UNAUTHORIZED</p></blockquote><p>这两个通过英文你可以看出点东西来，403状态码是未认证的，而401则是禁止的。</p><p>而且我找了一些工作的朋友们，一般网页用户在没有登陆的时候弹出来的都是403,或者用户尝试访问管理员权限的api时，也会弹出403。<br>而401则是禁止访问一些资源，比如sql注入等安全问题。</p><p>也就是说，和身份认证权限相关的都是403，而和服务器资源相关的则是401。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java里面的Set集合坑</title>
      <link href="/2019/11/29/java%E9%87%8C%E9%9D%A2%E7%9A%84Set%E9%9B%86%E5%90%88%E5%9D%91/"/>
      <url>/2019/11/29/java%E9%87%8C%E9%9D%A2%E7%9A%84Set%E9%9B%86%E5%90%88%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="java里面的Set集合坑"><a href="#java里面的Set集合坑" class="headerlink" title="java里面的Set集合坑"></a>java里面的Set集合坑</h1><p>Set的定义已经很清楚了，他的集合里面是不允许有重复变量的。<br>所以,Set更适合集合去重。</p><p>但是在最近我做每日最热文章的时候，出现了一个小bug，就是在redis里面取数据的时候，被继承的父类是不能被写入数据的。</p><p>下面看我的例子</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructor@ToStringpublic final class PopularBlog extend BlogStatus{    String blogName;}@Data@AllArgsConstructor@NoArgsConstructor@ToStringpublic class BlogStatus {    private Long id;    private Integer clickcount;}</code></pre><p>redis这样是取不出来id和clickcount的，但是我的blogName故意设置的有一样的数据，所以就会直接被去重。</p><p>所以，必须放弃继承，改写成这样</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructor@ToStringpublic final class PopularBlog {    String blogName;    private Long id;    private Integer clickcount;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot2.0集成Quartz</title>
      <link href="/2019/11/29/springboot2-0%E9%9B%86%E6%88%90Quartz/"/>
      <url>/2019/11/29/springboot2-0%E9%9B%86%E6%88%90Quartz/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-2-0-集成Quartz"><a href="#Spring-Boot-2-0-集成Quartz" class="headerlink" title="Spring Boot 2.0 集成Quartz"></a>Spring Boot 2.0 集成Quartz</h1><p>这几天制作博客的文章点击量的任务,我们需要定时将redis的缓存存到数据库，所以定时任务调度是绝对少不了的了。</p><h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>先说一下Quartz的核心架构吧<br><img src="https://s2.ax1x.com/2019/11/29/QkbOII.png" alt></p><p>我们要清楚里面的重点</p><p>Job-&gt; 我们需要让Quartz做些什么<br>JobDetail -&gt; Quartz完成什么任务，任务名称等详细信息<br>Trigger-&gt; Quartz多久调度一次什么任务</p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>导入jar包</p><pre><code class="xml">&lt;!--定时任务--&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;      &lt;/dependency&gt;</code></pre><p>写定时任务</p><blockquote><p>定时任务的关键就是需要继承QuartzJobBean类，然后实现executeInternal方法</p></blockquote><pre><code class="java">import lombok.extern.slf4j.Slf4j;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.quartz.QuartzJobBean;import run.app.entity.model.BlogStatus;import run.app.service.BlogStatusService;import java.text.SimpleDateFormat;import java.util.Date;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/11/29 14:06 * Description: 文章点击量定时任务 */@Slf4jpublic class ClickBlogTask extends QuartzJobBean {    @Autowired    BlogStatusService blogStatusService;    private SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-ss hh:mm:ss&quot;);    @Override    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {        log.info(&quot;ClickTask收录-------- {}&quot;, sdf.format(new Date()));        blogStatusService.transClikedCountFromRedis2DB();    }}</code></pre><p>写Quartz配置文件</p><pre><code class="java">import org.quartz.*;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import run.app.listner.ClickBlogTask;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/11/29 14:03 * Description: Quartz配置文件 */@Configurationpublic class QuartzConfig {    private static final String CLICK_TASK_IDENTITY = &quot;ClickTaskQuartz&quot;;    @Bean    public JobDetail clickQuartzDetail(){        return JobBuilder.newJob(ClickBlogTask.class).withIdentity(CLICK_TASK_IDENTITY).build();    }    @Bean    public Trigger clickQuartzTrigger(){        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()                .withIntervalInSeconds(10) //10c/s                .repeatForever();  //一直执行        return TriggerBuilder.newTrigger().forJob(clickQuartzDetail())                .withIdentity(CLICK_TASK_IDENTITY)                .withSchedule(scheduleBuilder)                .build();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中的redis序列坑</title>
      <link href="/2019/11/29/springboot%E4%B8%AD%E7%9A%84redis%E5%BA%8F%E5%88%97%E5%9D%91/"/>
      <url>/2019/11/29/springboot%E4%B8%AD%E7%9A%84redis%E5%BA%8F%E5%88%97%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot中的redis序列坑"><a href="#springboot中的redis序列坑" class="headerlink" title="springboot中的redis序列坑"></a>springboot中的redis序列坑</h1><p>当作到博客的点击排行功能的时候，心不甘情不愿的使用起了redis，但是redis存进来的key在我的redisDesktopManage中是这样的</p><p><img src="https://s2.ax1x.com/2019/11/29/QktA6s.png" alt></p><p>我写进去的是一个字符串,这里则是一串Hex.当然，我并不是这样不行，只是这样太不直观了。</p><p>经过排查得知，如果你的redis相关jar包导入的是这个话，就会产生上面的状况</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>这是因为上面的jar默认导入的jdk的序列化机制.</p><p>想要解决上面的问题有两个解决办法：<br>一个就是在我们对redis操作前，现将我们的对象用json序列化，但是这样我们的代码会变得特别臃肿，不符合代码整洁之道。<br>第二个就是写一个配置文件，将redis默认序列化机制换成我们的Jackson序列化</p><p>所以我们需要自定义一个序列化工具，比如说阿里的Fastjson什么的，但是之前开始做的时候好多博客都是下面的这种写法</p><blockquote><p>观前提示，下面的代码是错误的！</p></blockquote><pre><code class="java">import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/11/29 10:46 * Description:redis序列化配置 */@Configurationpublic class RedisConfig {    @Bean    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(redisConnectionFactory);        template.setKeySerializer(jackson2JsonRedisSerializer);        template.setValueSerializer(jackson2JsonRedisSerializer);        template.setHashKeySerializer(jackson2JsonRedisSerializer);        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    }}</code></pre><p>这样我们的数据就会变成这样的啦:</p><p><img src="https://s2.ax1x.com/2019/11/29/QkULpF.png" alt></p><p><img src="https://s2.ax1x.com/2019/12/03/QMUUAS.png" alt></p><p>上面的代码乍一看没什么问题，But好巧不巧，我的业务是直接将一个对象存进去了，结果反序列的时候直接报错！！！</p><p><img src="https://s2.ax1x.com/2019/12/03/QMdjOI.png" alt></p><p>查看一下报错就会看到我们的Jackson2的反序列化工具出错了！！</p><p>一开始我并没有以为是序列化不对，我以为是我的entity没有序列化导致的，所以我在我的类里面实现了序列化。还是不行，后来经过多方查阅得知，Jackson2的锅。</p><h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>既然Jackson2不行，那可以利用阿里的fastjson的序列器。具体代码如下:</p><p>现在我们需要两个序列器一个是StringSerializer和FastJsonSerializer</p><p>StringSerializer是用来序列K的，而后面那个是序列V的。</p><pre><code class="java">public class StringRedisSerializer  implements RedisSerializer&lt;Object&gt; {    private final Charset charset;    private final String target = &quot;\&quot;&quot;;    private final String replacement = &quot;&quot;;    public StringRedisSerializer() {        this(Charset.forName(&quot;UTF8&quot;));    }    public StringRedisSerializer(Charset charset) {        Assert.notNull(charset, &quot;Charset must not be null!&quot;);        this.charset = charset;    }    @Override    public byte[] serialize(Object o) throws SerializationException {        String string = JSON.toJSONString(o);        if (string == null) {            return null;        }        string = string.replace(target, replacement);        return string.getBytes(charset);    }    @Override    public String  deserialize(byte[] bytes) throws SerializationException {        return (bytes == null ? null : new String(bytes, charset));    }}</code></pre><pre><code class="java">public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; {    private static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);    private Class&lt;T&gt; type;    public FastJsonRedisSerializer(Class&lt;T&gt; type) {        super();        this.type = type;    }    @Override    public byte[] serialize(T t)  {        if(null == t){            return new byte[0];        }        try{            return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);        }catch (SerializationException ex){            throw new SerializationException(&quot;Something wrong...&quot; + ex.getMessage(),ex);        }    }    @Override    public T deserialize(byte[] bytes) throws SerializationException {        if (bytes == null || bytes.length == 0) {            return null;        }        try {            String str = new String(bytes, DEFAULT_CHARSET);            return (T) JSON.parseObject(str, type);        } catch (Exception ex) {            throw new SerializationException(&quot;Could not deserialize: &quot; + ex.getMessage(), ex);        }    }}</code></pre><pre><code class="java">@Configurationpublic class RedisConfig {    @Bean    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = new FastJsonRedisSerializer(Object.class);        ParserConfig.getGlobalInstance().addAccept(&quot;run.app.&quot;);        template.setValueSerializer(fastJsonRedisSerializer);        template.setHashValueSerializer(fastJsonRedisSerializer);        template.setKeySerializer(new StringRedisSerializer());        template.setHashKeySerializer(new StringRedisSerializer());        template.afterPropertiesSet();        return template;    }}</code></pre><p>这样取出来的数据就正常啦</p><p><img src="https://s2.ax1x.com/2019/12/03/QM6qsg.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker运维优化</title>
      <link href="/2019/11/27/springboot%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-docker%E8%BF%90%E7%BB%B4/"/>
      <url>/2019/11/27/springboot%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-docker%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="docker运维优化"><a href="#docker运维优化" class="headerlink" title="docker运维优化"></a>docker运维优化</h1><h2 id="springboot访问静态资源"><a href="#springboot访问静态资源" class="headerlink" title="springboot访问静态资源"></a>springboot访问静态资源</h2><p>部署完我的项目之后，在经过一系列的坑之后终于看似正常了。<br>但是，就在我更改完我的头像之后，我的图片突然爆出来了500错误，而且在我的面板上也爆出了这个错误。<br><img src="https://s2.ax1x.com/2019/11/27/QC1awj.png" alt></p><p>经过测试得知,我的jar包是运行在 / 目录下的，而且我在写代码的时候，我的静态资源都是存到 ${user.dir}/img 里面。这就导致了我的img目录变成了’//img’。但是就算是这样，我的图片还是可以写入的，所以问题不是出现在这里，经过多方查阅发现，是我的资源映射写错了。<br>我直接写的是static-locations:file:图片上传地址,这个在windows和linux运行都正确，因为你的运行路径又不是，但是在docker上面就不一样了。</p><p>正确写法应该是:</p><pre><code class="yaml">resources:    static-locations: file:/${web.upload-path},classpath:/META-INF/resources/,classpath:/resources/, classpath:/static/, classpath:/public/</code></pre><p>加一个/就行，翻了一下资料，大概是说加上/表示的是绝对路径。</p><h2 id="nginx刷新网页出现404现象"><a href="#nginx刷新网页出现404现象" class="headerlink" title="nginx刷新网页出现404现象"></a>nginx刷新网页出现404现象</h2><p>之所以出现这个现象，是因为我在匹配路径的时候没有加上这样的代码:<br>  try_files $uri $uri/ /index.html last;<br>上面的代码的意思是  查看本地磁盘文件有没有上面的网页的意思。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> nginx </tag>
            
            <tag> docker </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli2的性能优化</title>
      <link href="/2019/11/25/vue-cli2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/11/25/vue-cli2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-cli2的性能优化"><a href="#vue-cli2的性能优化" class="headerlink" title="vue-cli2的性能优化"></a>vue-cli2的性能优化</h1><p>前几天终于将自己的项目打包到了服务器上，但是由于本人买的阿里云的学生服务器，所有网速慢点。但是最不能忍的是css加载速度直接到了18s!所以才有了这篇文章<br><img src="https://s2.ax1x.com/2019/11/25/Mvw9rF.png" alt></p><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>我们首先在项目上运行</p><pre><code class="bash"> npm run build --report</code></pre><p>运行成功后自动打开 <a href="http://127.0.0.1:8888" target="_blank" rel="noopener">http://127.0.0.1:8888</a><br>我们会看到下面的界面<br><img src="https://s2.ax1x.com/2019/11/25/Mv07kj.png" alt></p><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>由于大部分的游览器已经支持gzip了，所以我的第一步优化就是从gzip入手。</p><p>当我们查看刚才打开的页面并且点击gzip按钮的时候，我们看到数据压缩的大小</p><p><img src="https://s2.ax1x.com/2019/11/25/MvBS74.png" alt></p><p>打开我们的项目，查看我们的config/index.js</p><p>会发现我们里面有productionGzip这个选项，它默认是false的，所以我们需要将这个设置成true,然后执行打包命令。</p><blockquote><p>注意如果提示你少插件安装即可，因为我的版本是vue-cli2，所以插件版本不能过高，这里我推荐一个插件。</p></blockquote><pre><code class="bash">npm install compression-webpack-plugin@1.1.12</code></pre><p>好的，打包之后发布我们可以看到我们页面加载速度已经稍微便快一些了。<br><img src="https://s2.ax1x.com/2019/11/25/Mvhmbn.png" alt></p><p>由于我是部署在nginx上面的，所以我们需要nginx开启一下gzip选项：</p><pre><code class="text">    gzip on;    gzip_min_length 1k;    gzip_buffers 4 16k;    gzip_http_version 1.0;    gzip_comp_level 2;    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;    gzip_vary off;    gzip_disable &quot;MSIE [1-6]\.&quot;;</code></pre><p>gzip选项可以写在http、server、location下面</p><h2 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h2><p>一谈到cdn我就头疼，因为我的项目是vue-cli2的，而且说实话哈，我webpack根本就没学。当时认为直接搭框架干就完了呗，现在想想看，当时的自己真是蠢，早晚都得学。</p><p>好了，我当初再往上看了好多相关的教程。哎呀，这里我总结一下吧。</p><p>首先我们要清楚的一点是,vue如果是将你下载的第三方插件,比如说jquery啥的利用cdn优化的时候，一定要只将那些在vue首页加载的插件弄上cdn，其他的插件弄上cdn后，反而会变慢。</p><p>为啥嘞？<br>问的好！我们搞cdn的时候是将那些cdn链接弄到index.html里面引入的，就像这样:</p><pre><code class="html">&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;逝痕&lt;/title&gt;&lt;/head&gt;</code></pre><p>如果在首页塞上太多的资源链接的话，就会弄得很慢。</p><blockquote><p>还有一件事~，就是按需引入的插件不要用cdn</p></blockquote><p>由于本人的框架用的iview,所以如果利用cdn的话会产生很多bug。<br>所以我把眼光放到了vue、vue-router、vuex这样的插件。</p><p>所以，我们需要先找到对应自己版本的cdn,这里我推荐几个网站：<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a>、<a href="https://unpkg.com" target="_blank" rel="noopener">unpkg</a></p><p>我对照上面的项目状况找到了我的版本，index.html代码如下:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;title&gt;逝痕&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@3.1.2/dist/vuex.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@3.1.3/dist/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>vue-cli2需要改一下webpack配置，我们打开/build/webpack.base.conf</p><p>改动如下:</p><pre><code class="javascript">module.exports = {    externals: {        &#39;vue&#39;: &#39;Vue&#39;,        &#39;vue-router&#39;: &#39;VueRouter&#39;,        &#39;vuex&#39;: &#39;Vuex&#39;    },// ...}</code></pre><p>webpack的配置我推荐你看这个网站:<a href="https://webpack.docschina.org/configuration/externals/" target="_blank" rel="noopener">外部拓展</a></p><p>运行我们的打包命令</p><pre><code class="bash">npm run build --report</code></pre><p>经过cdn我们发现我们的项目是这样的</p><p><img src="https://s2.ax1x.com/2019/11/26/QSedxI.png" alt></p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>cdn搞完了，但是说实话提升效果不是很好。打开我的控制台发现我的网站图片加载需要10s,所以我又将我的重心转到了图片压缩上面。</p><p>这里推荐两个网站:</p><p><a href="http://www.bejson.com/ui/compress_img/" target="_blank" rel="noopener">http://www.bejson.com/ui/compress_img/</a></p><p><a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p><p>压缩之后替换图片即可</p><h2 id="图片渐进式加载"><a href="#图片渐进式加载" class="headerlink" title="图片渐进式加载"></a>图片渐进式加载</h2><h2 id="关闭map资源"><a href="#关闭map资源" class="headerlink" title="关闭map资源"></a>关闭map资源</h2><p>我们打包之后看到我们有很多的map后缀的js,其实这些东西都是可以不要的。</p><p>打开 /config/index.js</p><p>将productionSourceMap设置成false即可</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose实现前后端分离的自动化部署</title>
      <link href="/2019/11/21/docker-compose%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/11/21/docker-compose%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-实现前后端分离的自动化部署"><a href="#docker-实现前后端分离的自动化部署" class="headerlink" title="docker 实现前后端分离的自动化部署"></a>docker 实现前后端分离的自动化部署</h1><p>时隔一个学年，我再一次租起了阿里云服务器(哎呀真香啊)，其实一开始我也是拒绝的，但是由于我的电脑配置日渐落后，连启动一个虚拟机都要等上半天。我就想说：买！咱不受那个窝囊气。</p><p>具体配置是这样的</p><p><img src="https://s2.ax1x.com/2019/11/18/McPwsf.png" alt></p><p>好了，废话不多说，这篇文章是搭建web环境的，看过之前的文章都知道，技术选型肯定就是docker + springboot + vue了</p><h2 id="下载环境"><a href="#下载环境" class="headerlink" title="下载环境"></a>下载环境</h2><p>这里我默认大家docker已经装好了，如果没有装好，请参考我之前的文章<br>我们现在需要下载的是docker-compose</p><pre><code class="bash"># 下载和安装curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 赋予权限chmod +x /usr/local/bin/docker-compose# 检查版本docker-compose -vesion</code></pre><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="https://s2.ax1x.com/2019/11/23/Mbfslq.png" alt></p><p>这是我的项目的所有的工程文件，下面讲解一下这些都是些啥玩意。</p><p>首先介绍一下前后端分别都是我的github项目，地址是 <a href="https://github.com/whoami1231/blog-vue">前端</a>|<a href="https://github.com/whoami1231/blog-java">后端</a>.</p><h2 id="前端准备"><a href="#前端准备" class="headerlink" title="前端准备"></a>前端准备</h2><p>先介绍一下前端文件，也就是web文件夹<br>我们的前端是通过vue打包后部署到nginx，因为要做后端的负载均衡。</p><h3 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h3><p>首先我们需要修改文件，因为我们要部署到docker里面。容器与容器之间会有冲突域产生，localhost是绝对访问不到自己的项目的，所以我们需要将我们请求后端的axios的bashUrl修改一下改成这样-&gt; <a href="http://example.com/server" target="_blank" rel="noopener">http://example.com/server</a></p><blockquote><p>中间的域名可以换成你的服务器ip地址，后面的server是一个声明，好让nginx反向代理到后端</p></blockquote><h3 id="打包项目文件"><a href="#打包项目文件" class="headerlink" title="打包项目文件"></a>打包项目文件</h3><p>然后我们要给我们的前端打包，打开项目根目录然后输入下面的命令</p><pre><code class="bash">npm run build</code></pre><p>我们会得到一个dist文件夹，也就是我们的前端文件[我还没有搞cdn加速，太卑微了]</p><h3 id="编写nginx配置文件-nginx-conf"><a href="#编写nginx配置文件-nginx-conf" class="headerlink" title="编写nginx配置文件 nginx.conf"></a>编写nginx配置文件 nginx.conf</h3><p>具体文件如下:</p><pre><code class="text">worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    client_max_body_size 4m;    upstream eblogserver{        server eblog_server_1:8099 weight=1;        server eblog_server_2:8098 weight=2;    }    sendfile        on;    keepalive_timeout  65;    gzip on;    gzip_min_length 1k;    gzip_buffers 4 16k;    gzip_http_version 1.0;    gzip_comp_level 2;    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;    gzip_vary off;    gzip_disable &quot;MSIE [1-6]\.&quot;;    server {        listen       80;        server_name  localhost;        location / {            try_files $uri $uri/ /index.html last;            root /usr/share/nginx/html;            index  index.html;        }        location ^~ /server/ {            proxy_pass http://eblogserver/;        }    }}</code></pre><blockquote><p>上面的upstream是加权轮转进行负载均衡的意思</p></blockquote><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>具体文件如下</p><pre><code class="bash">FROM nginxCOPY nginx.conf /etc/nginx/nginx.confCOPY ./dist /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="修改源代码-1"><a href="#修改源代码-1" class="headerlink" title="修改源代码"></a>修改源代码</h3><p>因为我这里使用的idea的IDE，所以我直接在这里面打包，但是因为有冲突域的存在，所以我们通过127.0.0.1是访问不到我们的mysql的，所以我们需要修改我们的配置文件，而这里又因为打包的时候需要检查所有的test文件，包括数据库是否可以连接。所以这里就会产生一个很大的冲突，经过度娘得知，我们可以跳过安全检查。</p><p>打开我们的pom.xml，修改里面的properties</p><pre><code class="xml">&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!--添加 --&gt;&lt;/properties&gt;</code></pre><p>然后我们修改我们的数据库连接路径</p><p>url: jdbc:mysql://docker_mysql:3306/eblog?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</p><blockquote><p>这里面的docker_mysql是我们一会启动的mysql的服务</p></blockquote><h3 id="打包jar"><a href="#打包jar" class="headerlink" title="打包jar"></a>打包jar</h3><p>具体操作如下<br><img src="https://s2.ax1x.com/2019/11/23/Mboco8.png" alt></p><h3 id="编写Dockerfile-1"><a href="#编写Dockerfile-1" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>文件代码如下</p><pre><code class="bash"># 继承java 1.8FROM java:8# 容器的操作者MAINTAINER whoami# 数据卷VOLUME /temp# 修改jar包名称ADD app-0.0.1-SNAPSHOT.jar eblog-server.jarRUN bash -c &#39;touch /eblog-server.jar&#39;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;eblog-server.jar&quot;]</code></pre><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><pre><code class="bash">docker build -t eblog-server .</code></pre><blockquote><p>其实这里不用编成镜像也行，只是为了展示不同的构建方法才这么写</p></blockquote><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><p>具体代码如下</p><pre><code class="yml">version: &#39;3&#39;services:    nginx:        restart: always        container_name: nginx        build:            context: ./web            dockerfile: ./Dockerfile        ports:            - 80:80        depends_on:            - eblog_server_1            - eblog_server_2        volumes:            - ./web/log:/var/log/nginx    eblog_server_1:        container_name: eblog_server_1        image: eblog-server        ports:            - 8099:8099        depends_on:            - docker_mysql            - docker_redis        volumes:          - ./server/img:/img    eblog_server_2:        container_name: eblog_server_2        image: eblog-server        ports:            - 8098:8098        depends_on:            - docker_mysql            - docker_redis        volumes:          - ./server/img:/img    docker_mysql:        container_name: docker_mysql        image: mysql:5.6        restart: always        environment:            MYSQL_ROOT_PASSWORD: 123            MYSQL_ROOT_HOST: &#39;%&#39;        ports:            - 3306:3306        volumes:            - ./mysql/data:/var/lib/mysql    docker_redis:      container_name: docker_redis      image: redis      restart: always      command: redis-server /usr/local/etc/redis/redis.conf      ports:        - 6379:6379      volumes:        - ./redis/data:/data        - ./redis/redis.conf:/usr/local/etc/redis/redis.conf</code></pre><p>下面讲解一下文件配置</p><ul><li>version -&gt; 没什么好说的 版本而已</li><li>services -&gt; 需要运行的服务</li><li>nginx,eblog_server_1 .. 标识符</li><li>depends_on -&gt; 等里面的服务启动完成后才会启动</li><li>container_name -&gt; 容器名称</li><li><p>image -&gt; 使用docker里面的镜像</p></li><li><p>build</p></li></ul><p>这个是重点</p><p>如果使用Dockerfile创建镜像的话，比如我们的前端，我们需要利用build先构建镜像，然后再创建容器。<br>而那个context就是构建的目录,我们进入web目录下才会后我们的dockerfile，并且在web目录下才会由我们的nginx.conf文件</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>打包到服务器之后输入下面的命令</p><pre><code class="bash"># 后台运行docker-compose up -d</code></pre><pre><code class="bash"># 前台运行docker-compose up</code></pre><p>运行成功后，打开运行中的服务:</p><p><img src="https://s2.ax1x.com/2019/11/23/MbHMRg.png" alt></p><p>发现运行成功</p><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><pre><code class="bash">dcoker-compose down</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装java和maven</title>
      <link href="/2019/11/18/centos7%E5%AE%89%E8%A3%85java%E5%92%8Cmaven/"/>
      <url>/2019/11/18/centos7%E5%AE%89%E8%A3%85java%E5%92%8Cmaven/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装java和maven"><a href="#Centos7安装java和maven" class="headerlink" title="Centos7安装java和maven"></a>Centos7安装java和maven</h1><h2 id="java教程"><a href="#java教程" class="headerlink" title="java教程"></a>java教程</h2><blockquote><p>由于之前的笔记都是存到了网易云笔记上面，现在都懒得打开那个软件了，现在干脆直接把上面那些有的没的直接搬到这上面来，省时省力。</p></blockquote><p>好了，正片开始</p><p>首先将我们的jdk包[这里我用的是jdk1.8.0的]上传到服务器上面去，之后一步一步敲命令就好了</p><pre><code class="bash">mkdir -p /usr/share/javamv jar包 /usr/share/javatar -zxvf jar包# 修改环境变量vi /etc/profile</code></pre><p>其实关于上面的修改环境变量我更倾向于用xftp,因为他可以直接调用你的物理主机修改服务器上面的文件，I love it….</p><p>在上面的文件的后面加上</p><pre><code class="bash"># java环境变量配置JAVA_HOME=/usr/share/java/jar包名称CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jarPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH</code></pre><p>保存文件后更新一下配置文件</p><pre><code class="bash">source /etc/profile</code></pre><p>验证java是否安装成功</p><pre><code class="bash">java -version</code></pre><p>出现java版本后则代表安装成功</p><h2 id="maven教程"><a href="#maven教程" class="headerlink" title="maven教程"></a>maven教程</h2><p>我们直接在清华镜像里面下载maven压缩包</p><pre><code class="bash">wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</code></pre><p>解压到user/local/ 下面</p><pre><code class="bash">tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /usr/local/maven# 修改环境变量vi /etc/profile# 生效配置文件source /etc/profile</code></pre><p>在配置文件的后面添加</p><pre><code>export PATH=$PATH:/usr/local/maven/bin</code></pre><p>出现下面的情况则代表安装成功<br><a href="https://imgchr.com/i/sn5M26" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/08/sn5M26.png" alt="sn5M26.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库面对高并发的思路</title>
      <link href="/2019/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/2019/11/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E5%AF%B9%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库面对高并发的思路"><a href="#数据库面对高并发的思路" class="headerlink" title="数据库面对高并发的思路"></a>数据库面对高并发的思路</h1><p>这篇文章完全是因为做到了文章点击量的功能的时候，数据库的读写速度已经逐渐满足不了我的项目了[因为有很多的数据库操作嘛]。<br>正一筹莫展的时候，在技术网站上面看到了一篇文章名字叫做”Redis 解决高并发思路”的论文引起了我的注意。<br>redis其实也不是没想过，但是之前看到了一个业界大佬不断的呼吁’stateless’的服务，也就是不要让随随便便的程序附加上一些繁琐的附加程序。比如说java+ mysql就能完成的任务非要加上一些redis、mq啊什么什么的，因为加上那些程序的话你们的后台程序的存活性就会变相对低一些，因为还要考虑到这些附加程序的健康性。</p><h2 id="理念不舍弃，程序照样用"><a href="#理念不舍弃，程序照样用" class="headerlink" title="理念不舍弃，程序照样用"></a>理念不舍弃，程序照样用</h2><p>因为涉及到了文章的点击量了嘛，所以即使就算你的QPS是那小小的个位数字，但是那样来说到服务器里面取文章并且对文章进行各种修饰(带上作者信息啊、评论信息啊、点赞数啊etc..)也对数据库造成了一个不小的压力，所以Redis是解决服务器压力的一大利器！！</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>这里我们就要唠一唠了，数据库如何设计呢？<br>看了好多大佬的文章，大概总结出了这样的一个道理，那就是数据分离。<br>数据是分成了冷热两大数据的，比如说用户信息这种不经常修改的信息就是冷数据，而那些像是用户登录时间和操作啊那些经常进行刷新数据的就是热数据。</p><p>所以我们需要将点赞单独分出来</p><p>也就是我们经常的老三样</p><ul><li>BLOG</li></ul><table><thead><tr><th>id</th><th style="text-align:center">title</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td>文章Id</td><td style="text-align:center">文章名称</td><td style="text-align:center">闲杂文件</td></tr></tbody></table><ul><li>USER</li></ul><table><thead><tr><th>id</th><th style="text-align:center">username</th><th style="text-align:center">pwd</th><th style="text-align:center">salt</th></tr></thead><tbody><tr><td>用户id</td><td style="text-align:center">用户名称</td><td style="text-align:center">密码</td><td style="text-align:center">盐</td></tr></tbody></table><ul><li>USER_CLICK_BLOG</li></ul><table><thead><tr><th style="text-align:center">BLOG_ID</th><th style="text-align:center">USER_ID</th><th style="text-align:center">DATE</th></tr></thead><tbody><tr><td style="text-align:center">文章id</td><td style="text-align:center">用户id</td><td style="text-align:center">时间</td></tr></tbody></table><p>是不是很熟悉？对，就是我们大学经常讲的多对多模型。</p><blockquote><p>这里插一点，经过最近对mybatis逆向工程进行的分析。发现里面有一个可优化的点，就是查询当前表下的所有数据的时候，如果你的表里面只有一个字段作为字段的时候，尽量将代码count(*)改成count(PK)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装与初次使用</title>
      <link href="/2019/11/08/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/08/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker的安装与初次使用"><a href="#Docker的安装与初次使用" class="headerlink" title="Docker的安装与初次使用"></a>Docker的安装与初次使用</h1><p>这几天一直在搞爬虫，偶尔发现一篇帖子发现scrapy可以在Docker里面运行，太好了！正好让我们的spring程序和爬虫相辅相成一起运行，然后让自己的网站变得更好[幻想ing….]</p><p>好了，废话不多说了，本来这个就很简单的，一会还要写另一篇爬虫文章。</p><p>说一下我的Linux环境是centos7<br>docker的内置环境是centos6.5</p><h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><p>首先安装yum-utils</p><pre><code class="bash">yum install -y yum-utils</code></pre><p>然后添加阿里云镜像</p><pre><code class="bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>最后下载docker-ce</p><pre><code class="bash">yum install docker-ce</code></pre><p>安装完成！</p><p>开启开机自启</p><pre><code class="bash">systemctl start docker</code></pre><h2 id="nginx的使用"><a href="#nginx的使用" class="headerlink" title="nginx的使用"></a>nginx的使用</h2><pre><code class="bash"># 细心的你一定会发现，凡是下载命令一定pull，运行命令一定是rundocker pull nginx #下载nginx#  -d 后台 -p 指定端口docker run -d -p 80:80 nginx</code></pre><p>访问本机端口 localhost:8080，看到nginx的欢迎界面，安装完成！</p><h2 id="tomcat的使用"><a href="#tomcat的使用" class="headerlink" title="tomcat的使用"></a>tomcat的使用</h2><p>由于我的项目是jar包格式，所以这里的tomcat只是凑字数的，目的只是看一下怎么样下载镜像和启动</p><pre><code class="bash">docker pull tomcat# 以my_tomcat的名称启动docker run -d -p 8080:8080 --name my_tomcat tomcat</code></pre><p>访问本机端口 localhost:8080，看到tomcat的欢迎界面，安装完成！</p><h2 id="mysql的使用"><a href="#mysql的使用" class="headerlink" title="mysql的使用"></a>mysql的使用</h2><p>这里要说一下由于本人用的是mysql5.6的，而最新的mysql是8.x。我的tomcat会出现连接不上的状况，这是因为8.x的连接算法做出了更改。<br>所以为了方便，我的服务器下载的是mysql5.6的</p><pre><code class="bash">docker pull  mysql:5.6# 这里是密码为xxx的root的mysql开启方法docker run -d -p 3306:3306 - v /usr/local/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xxx mysql</code></pre><p>下面介绍一下-v 和 -e 的作用，首先你可以想象这些容器启动后都是缓存到一个内存里面{这里只是方便大家理解才说是内存中，大家不要误解}，当你关闭之后或者重启里面的数据都会消失。说的高大上一点就是无所做数据持久化，那个-v这个参数就出来了，他是以’:’分隔，其实只要记住’:’,所有参数:左边的都是值得你的物理主机[也就是宿主机]，而右边的就是你的容器。上面的意思就是将本层目录下面的data文件夹来存mysql数据表，启动完是这样的。</p><p><img src="https://s2.ax1x.com/2019/11/23/MbgQxK.png" alt></p><h2 id="redis的使用"><a href="#redis的使用" class="headerlink" title="redis的使用"></a>redis的使用</h2><p>当你的访问量上去的时候，缓存也是必须要上的，不然给数据库的压力是相当的大。</p><pre><code class="bash">docker pull redis</code></pre><p>这里需要说一下,docker的容器运行必须是要有一个前台程序的，不能所有的进程都是守护态。<br>因为我没有搞懂这个，所以一开始我的redis是一直起来就停止了。</p><p>如果对于redis不太了解的话可以看一下这里<a href="https://whoami1231.github.io/2019/04/30/centos7%E5%AE%89%E8%A3%85redis/" target="_blank" rel="noopener">centos下安装redis</a></p><h2 id="docker常用的命令"><a href="#docker常用的命令" class="headerlink" title="docker常用的命令"></a>docker常用的命令</h2><p>看到这里你可能对镜像[image]和容器[container]有了一定的理解，镜像你可以想象成安装包，而容器就是安装包安装完的软件。如果我没有记错的话，一个安装包是可以安装很多此软件的。<br>同样的容器和镜像也是这样，镜像只能有一个版本的(但是不同版本的可以共存)。而容器就可以启动很多了，只要你的端口不冲突，随便起。</p><p>而且docker也有一个特点就是，每一个容器都是一个冲突域[如果你学了计算机网络，那么冲突域一定不陌生]。这个意思就是说，即使你们容器内部端口一样，只要你们的宿主机端口不一致就好。</p><p>那么，我们下面开始讲解一下docker的常用命令。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><pre><code class="bash">docker run xxx:xxx</code></pre><h3 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h3><pre><code class="bash">docker image ls</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><pre><code class="bash">docker rmi xxx</code></pre><h3 id="删除无用镜像"><a href="#删除无用镜像" class="headerlink" title="删除无用镜像"></a>删除无用镜像</h3><blockquote><p>为什么会有这个呢，是因为当你不小心删除了一个有容器且正在运行的镜像的时候，会留下一个名字为<none>的镜像保证当前的容器的正常运行。可是有的时候我们还需要删掉这些来减轻我们的强迫症和空间</none></p></blockquote><pre><code class="bash">docker image prune</code></pre><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><pre><code class="bash">docker run -d -p xxx:xxx -e xx  -v xx:xx --name xxx</code></pre><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><pre><code class="bash">docker stop xxx</code></pre><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><pre><code class="bash">docker rm xxx</code></pre><h3 id="查看当前docker进程"><a href="#查看当前docker进程" class="headerlink" title="查看当前docker进程"></a>查看当前docker进程</h3><pre><code class="bash">docker ps -a</code></pre><h3 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h3><pre><code class="bash">docker exec -it xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 2.x 采用监控模块</title>
      <link href="/2019/11/05/springboot-2-x-%E9%87%87%E7%94%A8%E7%9B%91%E6%8E%A7%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/11/05/springboot-2-x-%E9%87%87%E7%94%A8%E7%9B%91%E6%8E%A7%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot-actuator-prometheus-grafana-实现资源监控"><a href="#springboot-actuator-prometheus-grafana-实现资源监控" class="headerlink" title="springboot + actuator + prometheus + grafana 实现资源监控"></a>springboot + actuator + prometheus + grafana 实现资源监控</h1><p>项目逐渐成型起来了，但是如果打包到服务器上之后，自己不可能时时刻刻关注服务器的状态，这时候舍友小A在一旁和我吐槽：<br>你不用想的很复杂，直接在网上找一个可以时时刻刻监控你自己服务器上的cpu啥的，一有事直接给你发邮件不就好了。</p><p>一语点醒梦中人，说干就干</p><p>百度了一下，好像对于spring boot 2.x最火的版本就是actuator + prometheus + grafana。但是网上的东西，你懂的，云龙混杂。所以，属于自己的才是最好的，接下来就和你们分享一下如何利用上面的数据搭建这个东西，由于博主现在还没有学docker，所以所有的东西都将在window上运行，之后学了docker在补上(咕咕咕)</p><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p>首先对我们的springboot下手，先贴一下pom包</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;            &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;            &lt;version&gt;1.1.1&lt;/version&gt;  &lt;/dependency&gt;</code></pre><p>然后贴一下application.yaml配置文件</p><pre><code class="yaml"># 系统监控management:  endpoint:    metrics:      enabled: true    health:      show-details: always  metrics:    export:      prometheus:        enabled: true  endpoints:    web:      base-path: /monitor      exposure:        include: prometheus</code></pre><blockquote><p>注意里面的 endpoints.web.base-path  这个可以自定义<br>默认是/actuator</p></blockquote><p>启动我们的应用</p><p>访问 <a href="http://HOST:PORT/monitor" target="_blank" rel="noopener">http://HOST:PORT/monitor</a></p><p>我们可以看到这样的数据</p><pre><code class="json">{&quot;_links&quot;:{&quot;self&quot;:{&quot;href&quot;:&quot;http://localhost:8099/monitor&quot;,&quot;templated&quot;:false},&quot;prometheus&quot;:{&quot;href&quot;:&quot;http://localhost:8099/monitor/prometheus&quot;,&quot;templated&quot;:false}}}</code></pre><p>我们打开 <a href="http://HOST:PORT/monitor/prometheus" target="_blank" rel="noopener">http://HOST:PORT/monitor/prometheus</a> 网址 可以看到一大坨数据，好了，配置成功了</p><h2 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h2><p>贴一下网址 <a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a></p><p>下载去上面的官网，官网里面有文档来说明这个软件，本篇博客不多叙述</p><p>安装成功后，修改里面的<strong>prometheus.yml</strong>文件</p><pre><code class="yml">scrape_configs:  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.  - job_name: &#39;prometheus&#39;    static_configs:    - targets: [&#39;localhost:9090&#39;]  - job_name: &#39;eblog&#39;    scrape_interval: 15s    metrics_path: /monitor/prometheus    # metrics_path defaults to &#39;/metrics&#39;    # scheme defaults to &#39;http&#39;.    static_configs:    - targets: [&#39;localhost:8099&#39;]</code></pre><p>我们需要修改的就是job_name(项目名) + metrics_path/targets(网址)</p><p>然后在terminal上输入 prometheus.exe –config.file=prometheus.yml</p><p>访问 <a href="http://localhost:9090" target="_blank" rel="noopener">http://localhost:9090</a></p><p>如果出现下面的界面，就表示我们配置成功了<br><img src="https://s2.ax1x.com/2019/11/05/M9Fkyn.png" alt></p><h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p>别说别的,上官网 <a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p>下载完毕后，请观察<a href="https://grafana.com/docs/installation/windows/" target="_blank" rel="noopener">官网文档</a>的这些话，配置你的grafana<br><img src="https://s2.ax1x.com/2019/11/05/M9F2tS.png" alt></p><p>启动你的软件，然后访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a><br>登陆成功后创建你的data source 和 dashboard<br><img src="https://s2.ax1x.com/2019/11/05/M9F5Xn.png" alt></p><p>由于我们使用的是prometheus，所以我们选择这一项<br><img src="https://s2.ax1x.com/2019/11/05/M9FxXR.png" alt></p><p>接着我们配置他的configure</p><p><img src="https://s2.ax1x.com/2019/11/05/M9kA9e.png" alt></p><p>最后save&amp;Test，保存成功！<br>之后我们需要添加图表，按照下图操作</p><p><img src="https://s2.ax1x.com/2019/11/05/M9kDCF.png" alt></p><p><img src="https://s2.ax1x.com/2019/11/05/M9kogH.png" alt></p><p><img src="https://s2.ax1x.com/2019/11/05/M9kqbt.png" alt></p><p><img src="https://s2.ax1x.com/2019/11/05/M9APrn.png" alt><br>出现数据，配置完成！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy初探</title>
      <link href="/2019/11/05/scrapy%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/11/05/scrapy%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="scrapy-框架下爬取网站图片思想"><a href="#scrapy-框架下爬取网站图片思想" class="headerlink" title="scrapy 框架下爬取网站图片思想"></a>scrapy 框架下爬取网站图片思想</h1><p>最近博客项目也做的差不多了，但是总感觉和别人的比差了点什么，突然有一天想起来了。对啊！我们没有图源啊。<br>但是，按照我的脾气来说，别人的不如自己的，与其将链接指向他们的网站，不如自己画~很显然不现实。<br>最后，我打算拾起大一放弃的python爬虫，我干脆直接在别人的网站上面爬一些就好喽。<br>大一的时候，之所以放弃爬虫单纯以为python做不了什么大项目，现在看来是我单纯了，人家python可以直接装载到docker里面啊！唉，流下了无知的泪水。<br>好了，废话说到这里，我们开始爬虫教程。</p><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>首先要确定自己有相应的模块，也就是scrapy。其实里面还需要另一个模块来着，我给忘了，小事情，只要少什么下什么就好了。<br>具体命令</p><pre><code class="bash">pip install scrapy</code></pre><p>创建工程同样也很简单，这里我们一笔带过</p><pre><code class="bash"># 切换到你想要保存的路径下scrapy startproject app(项目名称)</code></pre><h2 id="框架简单的入门"><a href="#框架简单的入门" class="headerlink" title="框架简单的入门"></a>框架简单的入门</h2><p><img src="https://s2.ax1x.com/2019/11/05/MpG64H.png" alt></p><p>创建工程之后，自动生成了这样的文件，画红线的不要在意。</p><p>下面分析一下工程目录结构：<br>spider/** -&gt; 里面的就是我们的爬虫文件,一开始只有init.py文件其他的都是自己创建的，反正改动最多的就是这里<br>init.py-&gt; 无视，不需要在意</p><p>items.py-&gt; 很重要，我们爬取的东西需要有的POJO存取啊，但是我们不能乱创建POJO文件，只能在items里面创建，这是规定</p><p>middlewares.py -&gt; 新手教程关，暂时请无视</p><p>piplines.py -&gt; 可以无视，里面是写一些存放策略，就是我把一些东西都保存到实体里面了，我想要下载啊，或者把这些存放到数据库里面啊，piplines就是干的这种任务，但是,我为什么说可以无视呢，因为我这里只讲下载图片，图片的话scrapy有默认的pipline(翻译成管道)<br>setting.py -&gt; 可以设置一些爬虫的规则，比如说，请求的header需要加的参数啊，或者是否支持重连啊，还有需要启用的pipline啊(这里认为最重要！)</p><blockquote><p>这上面的内容很重要，请仔细查看</p></blockquote><h2 id="分析爬取的网站"><a href="#分析爬取的网站" class="headerlink" title="分析爬取的网站"></a>分析爬取的网站</h2><p>我这里拿一个美女图片网站分析吧<br><img src="https://s2.ax1x.com/2019/11/05/MpUPw6.png" alt><br>我们可以看到，这里的网站首页有图集，然后图集有a标签指向具体图片，而且点击每个图集后，可以看到每个图集的网址都是有规则的<br><img src="https://s2.ax1x.com/2019/11/05/MpUDtU.png" alt><br>就是example.com/archives/xxx.html</p><p>里面的xxx是随机的数字</p><p>然后里面都是我们想要爬取的小姐姐</p><p>总结一下：</p><p>网址： 静态网址<br>反爬措施： 不知道，有也不会讲怎么应对，下一篇讲<br>目标集中网址：example.com/archives/xxx.html</p><p>这样就简单了</p><h2 id="创建第一只爬虫"><a href="#创建第一只爬虫" class="headerlink" title="创建第一只爬虫"></a>创建第一只爬虫</h2><p>创建爬虫命令</p><p>有两种方式，一种是创建一个基于crawl模板的，一种是不基于模板的，我们先开始第一支</p><pre><code class="bash">scrapy genspider -t crawl grilSpider(爬虫名字) example.com (爬取的网址)</code></pre><p>-t很显然是template的意思</p><p>总之，我们创建了一个爬虫，下面我就开始给他创建规则，就是最起码告诉他怎么爬</p><p>talk is cheap,show your code:</p><pre><code class="python">import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom ..items import AppItemclass GirlspiderSpider(CrawlSpider):    name = &#39;girlSpider&#39;    allowed_domains = [&#39;example.com&#39;]    start_urls = [&#39;http://example.com&#39;]    rules = (        Rule(LinkExtractor(allow=r&#39;http://example.com/archives/\d+.html&#39;), callback=&#39;parse_item&#39;, follow=False),    )    def parse_item(self, response):        print(response.url)        item = AppItem()        item[&#39;image_urls&#39;] =response.xpath(&quot;.//div[@id=&#39;post-content&#39;]/p/img/@src&quot;).extract()        yield item</code></pre><p>下面讲解这些东西是什么意思，首先看上面的import模块，和你们的唯一的不同就是多了最后一行，那个你现在可以忽视，我们一会说</p><p>name 就是我们的爬虫名称<br>allowed_domains 就是爬虫允许爬取的域名，总不能让他爬着爬到了别人的网站里面了吧</p><p>start_urls  里面存放着我们需要爬取的起始网址，每次都会做一个递归爬取。</p><p>rules -&gt; 这个可算是crawl 里面的重点了<br> Rule(LinkExtractor(allow=r’<a href="http://example.com/archives/\d+.html&#39;)" target="_blank" rel="noopener">http://example.com/archives/\d+.html&#39;)</a>, callback=’parse_item’, follow=False)</p><p> 首先我们的网址放在allow属性里，但是你可以看到里面的网址是我们想要爬取的<br>根据上面分析的来说我们需要爬取的就是这种网页，后面调用parse_item函数，这个follow是是否开启递归的意思，就是如果里面如果有下一页的话，我们需要继续从这一页开启跳转到下一页之后接着爬这里由于那个网站很简单，所以就设置成False</p><blockquote><p>上面我们可以总结成根据<a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 开始，爬取<a href="http://example.com/archives/\d+.html" target="_blank" rel="noopener">http://example.com/archives/\d+.html</a> 这种网址来分析和爬取</p></blockquote><h3 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a>items.py</h3><p>这里我们开始创建我们的图片实体，由于我们下载器用scrapy默认的<br>scrapy.pipelines.images.ImagesPipeline下载器，所以我们的实体就是默认的两个属性 image_urls -&gt; 爬取图片的网址，images -&gt; 有就行，不用管</p><p>下面是我们这个爬虫需要用到的实体类</p><pre><code class="python">class AppItem(scrapy.Item):    image_urls = scrapy.Field()    images = scrapy.Field()</code></pre><p>然后我们将这个方法引入到我们的那个爬虫文件里面中，这也就是最后的那句import的作用</p><p>同时我们需要在setting.py打开我们的下载器</p><h3 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h3><pre><code class="python">ITEM_PIPELINES = {   #将下载器放在这里面后面的数字是数序，1000以内的，你随便写    &#39;scrapy.pipelines.images.ImagesPipeline&#39;:300,}# 这个就是那个默认下载器必须要有的，就是图片存储位置，img是文件夹名称，你随便定一个就好IMAGES_STORE = &#39;img&#39;</code></pre><h3 id="爬虫-py"><a href="#爬虫-py" class="headerlink" title="爬虫.py"></a>爬虫.py</h3><p>好了，完成了一系列任务，现在开始解析网页了，这里我直接用xpath语法，不懂的可以取百度了</p><pre><code class="python">def parse_item(self, response):    print(response.url)    item = AppItem()    item[&#39;image_urls&#39;] =response.xpath(&quot;.//div[@id=&#39;post-content&#39;]/p/img/@src&quot;).extract()    yield item</code></pre><p>首先我们实例化一下上面创建的item的函数</p><p>同时我们需要穿进去我们需要爬取的image的url就好了，直接网页定位到图片然后获取所有符合条件的网址，直接给image_urls就好了，下面的yield你把它看成return就可以了</p><h2 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h2><pre><code class="bash">scrapy crawl girlSpider</code></pre><p>执行完毕之后，我们看到我们的爬取的小姐姐了</p><p><img src="https://s2.ax1x.com/2019/11/05/Mpw73F.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Mysql注入的经验</title>
      <link href="/2019/10/23/%E8%AE%B0%E4%B8%80%E6%AC%A1Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2019/10/23/%E8%AE%B0%E4%B8%80%E6%AC%A1Mysql%E6%B3%A8%E5%85%A5%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kali环境下进行wifi密码爆破</title>
      <link href="/2019/10/19/kali%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8Cwifi%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"/>
      <url>/2019/10/19/kali%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%9B%E8%A1%8Cwifi%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-hack-wifi-passwrod-with-Kali"><a href="#How-to-hack-wifi-passwrod-with-Kali" class="headerlink" title="How to hack wifi passwrod with Kali"></a>How to hack wifi passwrod with Kali</h1><p>Before we start,let me tell you  the reason I write  this post with English. </p><p>There are reason why:</p><ul><li>I wana be a postgraduate  of Ocean University 0f China</li><li>Writing English Posts seem to make me  cool I think</li></ul><blockquote><p>And this is my first attempt,I know it’s a shit.</p></blockquote><p>Let’s start!</p><h2 id="Find-your-wirless-Card-‘s-chipset-and-driver-using-airmon-ng"><a href="#Find-your-wirless-Card-‘s-chipset-and-driver-using-airmon-ng" class="headerlink" title="Find your wirless Card ‘s chipset and driver using airmon-ng"></a>Find your wirless Card ‘s chipset and driver using airmon-ng</h2><p>open your terminal,and type <strong>airmon-ng</strong>  bash,like this:</p><p><img src="https://s2.ax1x.com/2019/10/19/Km3nj1.png" alt></p><p>This will show all of wifi cards that can go into monitor mode.</p><p>Usaully, wlan0 and echo are interfaces you can shoose</p><p>as you can see,wlan0 is my labtop ‘s wifi interface.</p><h2 id="Put-your-wifi-interface-into-monitor-mode-using-Arimon-ng"><a href="#Put-your-wifi-interface-into-monitor-mode-using-Arimon-ng" class="headerlink" title="Put your wifi interface into monitor mode using Arimon-ng"></a>Put your wifi interface into monitor mode using Arimon-ng</h2><p>next,type in terminal : <strong>airmon-ng start wlan0</strong></p><p>and type in terminal <strong>ifconfig</strong>.clearly,there is no driver named wlan0 any more,but …. take place of wlan0mon.</p><h3 id="Show-the-list-of-wifi-at-your-location"><a href="#Show-the-list-of-wifi-at-your-location" class="headerlink" title="Show the list of wifi at your location"></a>Show the list of wifi at your location</h3><p>Type in terminal : <strong>airodump-ng wlan0mon</strong></p><p>you can see this:<br><img src="https://s2.ax1x.com/2019/10/19/KmLL4A.png" alt></p><p>next,you should choose the one you most love…and hack it!</p><p>( Remember this,Dont do any illegal things!!!!It’s most impotant.)</p><h3 id="monitor-the-wifi-and-check-if-someone-is-already-Connected"><a href="#monitor-the-wifi-and-check-if-someone-is-already-Connected" class="headerlink" title="monitor the wifi and check if someone is already Connected"></a>monitor the wifi and check if someone is already Connected</h3><p>So,Type in terminal: <strong>airdomp-ng -c (number of channel ) –bssid (the wifi mac adreess) -w (the location of file you want to save)</strong></p><p>here is a sample :</p><p>airodump-ng -c 2 –bssid 00:00:00:00:00:00 -w /root/home/test </p><p><img src="https://s2.ax1x.com/2019/10/19/KmOPEQ.png" alt></p><h3 id="Enter-the-system"><a href="#Enter-the-system" class="headerlink" title="Enter the system"></a>Enter the system</h3><p>Type in terminal <strong>aireplay-ng -0 2 -a (desired router bssid) -c (your own bssid or ethier)  wlan0mon</strong></p><p>And then,you can just waiting for the shakehand between you two,After this,you will do the last thing is Finding the passwrod.</p><p>well, all you can do is,use the default worldlists.It’s in…</p><p><img src="https://s2.ax1x.com/2019/10/19/KmOACn.png" alt></p><p>there.</p><p>And.. rockyou.text is you want.</p><p>so,Type in terminal this : <strong>aircrak-ng -w (the wordlists) (the file last step you created).cap</strong></p><blockquote><p>sometimes,the computer may send error like this:<br> Invalid packet capture length -1735227957 - corrupted file?<br>It’s clearly is we have a wrong cap file,but dont worry ,we can fix this!<br>use pcapfix command like this:</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/19/KmOmuT.png" alt></p><p><img src="https://s2.ax1x.com/2019/10/19/KmOubF.png" alt></p><p>now,waiting for the password!</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> wifi破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali进行arp嗅骗和攻击的一次记录</title>
      <link href="/2019/10/14/kali%E8%BF%9B%E8%A1%8Carp%E5%97%85%E9%AA%97%E5%92%8C%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/14/kali%E8%BF%9B%E8%A1%8Carp%E5%97%85%E9%AA%97%E5%92%8C%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Kali下arp嗅探和攻击的手账"><a href="#Kali下arp嗅探和攻击的手账" class="headerlink" title="Kali下arp嗅探和攻击的手账"></a>Kali下arp嗅探和攻击的手账</h1><p>由于本人打算考网络安全的专硕，所以这几天玩了一次kali。恩，怎么说呢，感触挺深的，特此记录下来</p><h2 id="arp基础"><a href="#arp基础" class="headerlink" title="arp基础"></a>arp基础</h2><p>在我们进行各种高大上的讲解的时候，我们要先清楚一点，我们如何在网上进行各种活动的。<br>比如我们经常用的baidu,我们是如何访问到baidu的服务器的。</p><p>我们可以通过追踪路由来弄清楚这个问题</p><p>windows: tracert<br>linux:traceroute</p><p>通过运行上面的命令我们可以看出数据包的传输过程<br><img src="https://s2.ax1x.com/2019/10/14/KpcYcR.png" alt></p><blockquote><p>由于本人身处深山，所以网络查的可以，上面的图仅供参考</p></blockquote><p>我们可以看到，我们的探测数据包经过了很多路由的转发最终达到了我们的机器上</p><p>并且，这里我们需要引出很重要的东西 – <strong>网关</strong></p><p>网关我们可以这么理解:<br>  相信大家家里都有有线网了吧，我们其实可以把网关看成我们的那个接入网络的光猫路由器。</p><p>  我们所有的数据包都是通过网关这个小东西传输。</p><p>现在，重点来了！！！！</p><blockquote><p>敲黑板</p></blockquote><p>假如，我们在同一个局域网下面，有两台机器，一台是我们自己，一台是需要攻击的机器。</p><p>那么，正常情况下，两台机器都有自己的ip地址 (192.168.x.x)，进行自己正常的网络服务,但是如果我们告诉对方机器现在我就是路由器，而且如果我的机器不能进行端口转发的时候，对面的机器就进不去网了。</p><p>需要注意的一点哈，现在我们告诉了对方机器我们是路由器，但是路由器还是可以给对面机器通信的。</p><p>这一点可以重复上面的操作，就是告诉路由器我们就是对面机器，进行双向嗅探来解决。</p><h2 id="如何进行攻击"><a href="#如何进行攻击" class="headerlink" title="如何进行攻击"></a>如何进行攻击</h2><h3 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h3><p>一、 获取对方信息</p><p>由于这篇博客写的是内网渗透，所以，我们需要扫描当前网络下的其他机器</p><pre><code class="bash">  &gt; ifconfig</code></pre><p><img src="https://s2.ax1x.com/2019/10/16/KiPr90.png" alt></p><p>先查看一下自己ip 里面重要的消息 有网卡和ip</p><p>这里说明一点,一般的话网关的最后一位数字一般都是1</p><pre><code class="bash">  &gt; netdiscover -i [网卡] -r [网关/24]  example:  &gt; netdiscover -i eth0 -r 192.168.3.1/24</code></pre><p>这样就可以获取对方ip，这里我只有一台电脑，我就不放图了</p><p>二、开始进行嗅探</p><pre><code class="bash">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host&gt; arpspoof -i eth0 [对方ip]  网关</code></pre><p>双向嗅探</p><pre><code class="bash">  &gt; arpspoof -i eth0 [对方ip]  网关  &gt; arpspoof -i eth0 [网关]  对方ip</code></pre><blockquote><p>由于kali默认情况下是禁止端口转发的，所以现在的情况下对面机器是断网的</p></blockquote><p>开启端口转发</p><pre><code class="bash">  echo 1&gt; /proc/sys/net/ipv4/ipforward</code></pre><p>1是开启 0是关闭  </p><blockquote><p>proc是目前开机的时候机器的配置，重启的话会重置</p></blockquote><p>抓取对面图片</p><pre><code class="bash">  driftnet -i eth0</code></pre><h3 id="软件嗅探"><a href="#软件嗅探" class="headerlink" title="软件嗅探"></a>软件嗅探</h3><p><img src="https://s2.ax1x.com/2019/10/16/KiFqkd.png" alt></p><p>具体做法</p><p>sniff-&gt;unified sniffing</p><p>host -&gt; hostlist</p><p>host -&gt; scan for host</p><p><img src="https://s2.ax1x.com/2019/10/16/KikuBF.png" alt></p><p>网关IP add to target 1 靶机 add to target 2</p><p>Mitm-&gt;ARP poisoning</p><p>要记住选中第一项 第二项是单项ARP毒缓存 用于靶机会失败报警 单向欺骗网关</p><p>开启driftnet</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 - kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次利用cropperjs修建图片并上传的过程</title>
      <link href="/2019/09/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8cropperjs%E4%BF%AE%E5%BB%BA%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/09/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8cropperjs%E4%BF%AE%E5%BB%BA%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="vuejs和cropperjs所走过的坑"><a href="#vuejs和cropperjs所走过的坑" class="headerlink" title="vuejs和cropperjs所走过的坑"></a>vuejs和cropperjs所走过的坑</h1><blockquote><p>用户上传自定义头像的功能是做完了，但是有的时候自己想要的图片不是这么’正好’，所以决定需要编辑图片</p></blockquote><p>目标已经确定了，用户上传完图片之后打开一个遮罩层,里面用cropper这个插件来编辑，最后将编辑之后的图片传给服务器</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>这个不要多说了，我们已经决定用cropperjs了，但是需要注意一点的是，不要和vue-cropper弄混.<br>cropperjs的github传送门：<a href="https://github.com/fengyuanchen/cropperjs">link</a></p><p>官网上也有文档可以查阅，不过本人的英语现在还是菜鸟级别，所以只能现在记录下来。</p><p>下载cropperjs:</p><pre><code class="bash">npm install cropper --save# orcnpm install cropper --save</code></pre><p>注册组件：</p><blockquote><p>注意这个组件必须要有jquery</p></blockquote><pre><code class="javaScript">import &#39;cropperjs/dist/cropper.css&#39;;import $ from &#39;jquery&#39;import Cropper from &#39;cropperjs&#39;</code></pre><p>一定要注意！！！ 上面这个css文件除非你用cdn在下面的style标签里面引入，像是这个</p><pre><code class="css">&lt;style&gt;@import &quot;https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.5/cropper.min.css&quot;;&lt;/style&gt;</code></pre><p>如果你没有引入css文件的话，就会出现下面的尴尬现象<br><img src="https://s2.ax1x.com/2019/09/01/npjtKO.png" alt><br>而正常的应该是这样</p><p><img src="https://s2.ax1x.com/2019/09/01/npjbsU.png" alt></p><h2 id="使用cropper的正确姿势"><a href="#使用cropper的正确姿势" class="headerlink" title="使用cropper的正确姿势"></a>使用cropper的正确姿势</h2><p>cropperjs需要新建一个cropper对象，所以我们需要cropper变量</p><p>可以看一下目前我的vue关于图片上传这方面的参数</p><pre><code class="bash">  cropper:&quot;&quot;,  # cropper对象，一会需要新建  open：false, # 裁剪图片的模态框，按自己需要添加  idBefore: &quot;&quot;, # img标签里面的src属性  avatar: null  # 需要利用这个变量上传给服务器</code></pre><blockquote><p>需要注意的是，之前我们利用FormData上传图片不是直接上传img的src属性里面的图片么,为什么这次不是直接上传？</p></blockquote><p>因为cropper对象获取编辑之后的图片是base64编码的，我们现在需要上传的是二进制图片</p><ul><li>创建cropper对象</li></ul><p>cropper对象我一开始的时候是在created(){}方法里面创建的，具体代码是这样</p><pre><code class="html">/* html DOM树 */&lt;!-- 照片遮罩层 --&gt;    &lt;Modal        v-model=&quot;open&quot;        @on-ok=&quot;crppper&quot;        title=&quot;建议是200x200规格的哦&quot;        &gt;        &lt;div style=&quot;width:360px;height:360px;&quot;&gt;            &lt;img :src=&quot;idBefore&quot; style=&quot;max-width:100%;height:auto;&quot; id=&quot;avatar&quot; alt=&quot;&quot;&gt;        &lt;/div&gt;    &lt;/Modal&gt;/* 方法 */created(){  let that = this;    let image  = document.getElementById(&quot;avatar&quot;);    this.cropper = new Cropper(image, {           aspectRatio: 1,           zoomable:false,           scalable:false,           movable:false,           minContainerWidth:360,           minContainerHeight:360          });}</code></pre><blockquote><p>但是一直会报错未找到img元素，因为vue的DOM树是在mounted(){}才会加载,created还未加载，所以代码应该是这样</p></blockquote><pre><code class="html">/* html DOM树 */&lt;!-- 照片遮罩层 --&gt;    &lt;Modal        v-model=&quot;open&quot;        @on-ok=&quot;crppper&quot;        title=&quot;建议是200x200规格的哦&quot;        &gt;        &lt;div style=&quot;width:360px;height:360px;&quot;&gt;            &lt;img :src=&quot;idBefore&quot; style=&quot;max-width:100%;height:auto;&quot; id=&quot;avatar&quot; alt=&quot;&quot;&gt;        &lt;/div&gt;    &lt;/Modal&gt;/* 方法 */mounted(){  let that = this;    let image  = document.getElementById(&quot;avatar&quot;);    this.cropper = new Cropper(image, {           aspectRatio: 1,           zoomable:false,           scalable:false,           movable:false,           minContainerWidth:360, # 规定大小           minContainerHeight:360          });}</code></pre><p>需要注意的是,现在的img里面的src只有在用户上传完图片之后才会正常。</p><p>当我们用户上传完图片的时候</p><pre><code class="javaScript">  if(this.cropper){    // 换cropper对象里面的img的src路径    this.cropper.replace(this.idBefore);// 开启遮罩层    this.open = true;  }</code></pre><h2 id="准备上传图片"><a href="#准备上传图片" class="headerlink" title="准备上传图片"></a>准备上传图片</h2><p>裁剪完图片之后,我们需要获取编辑之后的图片，具体代码如下：</p><pre><code class="javaScript">// 遮罩层点了确定按钮之后的函数crppper(){            let that = this;            //这个代码返回值是 HTMLCanvasElement            const canvas = this.cropper.getCroppedCanvas();            // 换成了可以看成了src属性的图片            this.idBefore = canvas.toDataURL(&quot;image/png&quot;);            //  将avatar换成了blob对象             canvas.toBlob(function(blob){                 that.avatar = blob;             });        }</code></pre><p>这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement" target="_blank" rel="noopener">HTMLCanvasElement</a>对象是个重点，具体代码可以看官网。</p><p>由于FormData对象有两个append()方法</p><p>FormData.append(“需要转换成的名称”,变量)</p><p>FormData.append(“需要转换成的名称”,blob变量,”转换成的名称”)</p><p>我们的avatar已经换成了blob对象</p><p>上传具体代码</p><pre><code class="javaScript">userApi.uploadAvatar = (file) =&gt; {    let data = new FormData();    data.append(&quot;avatar&quot;, file, &quot;avatar.jpg&quot;);    return service({        url: `${baseUrl}/updateAvatar`,        data: data,        headers: {            &#39;Content-Type&#39;: &#39;multipart/form-data&#39;        },        method: &#39;post&#39;    })}</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FormData在axios中的骚操作</title>
      <link href="/2019/08/20/FormData%E5%9C%A8axios%E4%B8%AD%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/20/FormData%E5%9C%A8axios%E4%B8%AD%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="FormData在axios中的骚操作"><a href="#FormData在axios中的骚操作" class="headerlink" title="FormData在axios中的骚操作"></a>FormData在axios中的骚操作</h1><p>做一个博客，最起码你要可以更换用户头像吧，不然谁知道你是谁啊。</p><p>当时有过用ajax上传图片的经验，但是这次就不一样了，因为我用了axios的拦截器，详细可以看我另一篇帖子。</p><p>由于我上传图片的方式post，而我在拦截器上的post的请求都自动加上 Content-Type = ‘application/json; charset=utf-8’</p><p>axios拦截器的代码在下面</p><pre><code class="javaScript">service.interceptors.request.use(    config =&gt; {        const token = store.getters.getToken ? store.getters.getToken : localStorage.getItem(&#39;token&#39;);        if (token) {            config.headers[&quot;Authentication&quot;] = token        }        if (config.method === &#39;post&#39; || config.method === &#39;put&#39;) {            // config.data = qs.stringify({...config.data });                config.headers[&#39;Content-Type&#39;] = &#39;application/json; charset=utf-8&#39;;                config.data = JSON.stringify({...config.data })        } else if (config.method === &#39;get&#39;) {            config.headers[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;            config.params = {...config.params }        }        return config;    }, error =&gt; {        return Promise.reject(error);    })</code></pre><p>从上面可以看出来，这个代码是不行的，因为我们上传图片等文件的时候我们需要我们的请求头 Content-Type 是’multipart/form-data’才可以上传成功。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>经过查阅知道，axios不仅可以在拦截器上设置请求头信息，也可以在封装后的请求体上面加入请求头，headers:{}属性，所以，我上传的图片代码是这样</p><pre><code class="javaScript">userApi.uploadAvatar = (file) =&gt; {    let data = new FormData();    data.append(&quot;avatar&quot;, file)    return service({        url: `${baseUrl}/updateAvatar`,        data: data,        headers: {            &#39;Content-Type&#39;: &#39;multipart/form-data&#39;        },        method: &#39;post&#39;    })}</code></pre><p>可以看到，我们加上了请求头，但是这样并没有什么效果，因为我在拦截器上已经设置死了 只要是post方法，必须是另一种请求头，但是如果将拦截器上面的删除掉的话，每个post方法都要加上headers，很麻烦。所以我们可以采取直接照顾特殊方法的方法，直接修改拦截器post部分的代码：</p><pre><code class="javaScript">if (config.method === &#39;post&#39; || config.method === &#39;put&#39;) {            // config.data = qs.stringify({...config.data });            if (config.headers[&#39;Content-Type&#39;] === &#39;multipart/form-data&#39;) {            } else {                config.headers[&#39;Content-Type&#39;] = &#39;application/json; charset=utf-8&#39;;                config.data = JSON.stringify({...config.data })            }        }</code></pre><p>可以看到如果我们的请求头是 config.headers[‘Content-Type’] === ‘multipart/form-data’ 不做任何操作，问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> FormData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot完成图片上传下载的功能</title>
      <link href="/2019/08/19/spring-boot%E5%AE%8C%E6%88%90%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/19/spring-boot%E5%AE%8C%E6%88%90%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot完成图片上传下载功能"><a href="#springboot完成图片上传下载功能" class="headerlink" title="springboot完成图片上传下载功能"></a>springboot完成图片上传下载功能</h1><p>由于我的博客项目最起码用户的更换头像操作要做出来啊，所以这个地方即使是我再怎么不想去碰也是不可能的。所以今天就拿出来唠一唠，这个springboot是如何操作的</p><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>上传这个好说，springMVC如果都学过的话，应该都好理解 MultipartFile这个类，上传文件当然用它了</p><p>我的后端项目路径目前是这样的</p><blockquote><p>D:\code\java\eblog</p></blockquote><p>而我想把图片存到他的子目录 avatar下面<br>也就是：</p><blockquote><p>D:\code\java\eblog\avatar</p></blockquote><p>下面就是一些纯粹的IO读写操作了。<br>首先，要保证我们的文件夹要存在，毕竟有一个avatar呢，所以我们需要在启动这个项目的时候先确定一下是否存在，不存在就创建。</p><blockquote><p>这里提一点，为什么我们不直接在Controller层判断，因为，一遍一遍判断太烦了，还浪费资源，启动的时候检查一遍就OK了</p></blockquote><pre><code class="java">//  启动器代码@Slf4j@Configuration@Order(Ordered.HIGHEST_PRECEDENCE)public class StartLinster implements ApplicationListener&lt;ApplicationEvent&gt; {    @Autowired    TokenService tokenService;    @Override    public void onApplicationEvent(ApplicationEvent applicationEvent) {        String filePath = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;avatar&quot;;        File file = new File(filePath);        if(!file.exists()){            file.mkdirs();        }    }}</code></pre><p>现在，我们有了文件夹，后面我们保存文件就可以了</p><pre><code class="java">@ApiOperation(&quot;上传用户图片&quot;)    @PostMapping(&quot;/updateAvatar&quot;)    public BaseResponse updateProfile(@RequestParam(value = &quot;avatar&quot;,required = true)MultipartFile avatar,                                      HttpServletRequest request){        BaseResponse baseResponse = new BaseResponse();//  获取并创建文件夹        String property = System.getProperty(&quot;user.dir&quot;);        String filePath = property + File.separator + &quot;avatar&quot;;//  随机生成文件名称        String trueFilename = UUID.randomUUID().toString();//  获取本来文件名称        String filename = avatar.getOriginalFilename();// 截取 文件后缀名        String type = filename.indexOf(&quot;.&quot;) != -1 ? filename.substring(filename.lastIndexOf(&quot;.&quot;)+1,filename.length()):null;// 重新构建文件名        String trueFile = null == type ? filePath + File.separator + trueFilename :                filePath + File.separator + trueFilename + &quot;.&quot; + type;        try {          //  重点！！！！  将MultipartFile文件存到普通文件中！！！            avatar.transferTo(new File(trueFile));        } catch (IOException e) {            e.printStackTrace();            baseResponse.setStatus(HttpStatus.BAD_REQUEST.value());            baseResponse.setMessage(&quot;图片上传失败&quot;);            return baseResponse;        }</code></pre><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>下载的话，我一开始是想直接把我的磁盘目录写进数据库中，然后读取的时候直接读，但是这样就暴露了我们的磁盘结构，很不安全，所以不得不放弃，而且也不现实。</p><p>后来，我决定直接创建一个虚拟映射就可以了啊，而且简单的一匹</p><p>只要把我们存到磁盘的文件名称保存到数据库就ok，到时候直接让前端访问我们的这个服务器ip+名称就行了啊</p><p>明白了思路，我们开始设置，其实很简单，在我们的springboot的项目配置中添加两个属性就行</p><pre><code class="yaml">spring:  resources:    static-locations: classpath:/META-INF/resources/,classpath:/resources/, classpath:/static/, classpath:/public/,file:${web.upload-path}web:  upload-path: ${user.dir}/avatar</code></pre><p>这个web.upload-path是我自己定义的，完全可以忽略，上面的那个抄下来就好了，file: 表示是项目的物理磁盘。<br>之后访问 项目ip地址/文件名 就可以访问到了。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybtatis添加数据返回主键</title>
      <link href="/2019/08/15/mybtatis%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/"/>
      <url>/2019/08/15/mybtatis%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="mybtatis添加数据返回主键"><a href="#mybtatis添加数据返回主键" class="headerlink" title="mybtatis添加数据返回主键"></a>mybtatis添加数据返回主键</h1><p>今天心血来潮，想用自己的项目来发布一些博客，可是当我提交成功后，想要访问的时候，突然告诉我找不到？！？<br>吓得我赶紧去查看一下数据库日志，结果发现主键对不上。<br>是这样，我的博客是放在数据库中的，而为了方便，我又将博客分成了两个表，一个表存放博客的基本信息，一个存放博客的内容信息，插入的时候，先存放基本信息返回主键id，然后将id和内容插入到内容表中，本来是没有问题的，后来才发现，逆向工程的insert的语句，返回的不是主键id，而是影响的行数。问题找到了，那么解决他就很简单了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>经过查阅资料发现，主键id是可以返回的，但是会返回给你当初insert进去的对象里面的属性中，不会返回。这也是当然的吧，万一主键约束有多个不就瞎了，你咋返回？</p><p>但是默认的insert是不会返回的，必须保证你的数据库主键是设置成了逐步递增的，而且，还需要下面三个属性：</p><ul><li>useGeneratedKeys=”true” (必要)</li><li>keyProperty=”xx” (必要，你想要返回给对象的属性名称)</li><li>keycolumn=”xx” (非必要，这个是指定数据库中那个是主键)</li></ul><p>将这三个属性写在xml的方法上，像是这样</p><pre><code class="xml">  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;run.app.entity.model.Blog&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &gt;</code></pre><p>然后你的主键就会返回给你这个Blog对象了，大功告成。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录springboot利用pagehepler失效的原因</title>
      <link href="/2019/07/28/%E8%AE%B0%E5%BD%95springboot%E5%88%A9%E7%94%A8pagehepler%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2019/07/28/%E8%AE%B0%E5%BD%95springboot%E5%88%A9%E7%94%A8pagehepler%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="记录springboot利用pagehepler失效的原因"><a href="#记录springboot利用pagehepler失效的原因" class="headerlink" title="记录springboot利用pagehepler失效的原因"></a>记录springboot利用pagehepler失效的原因</h1><p>首先说一下记录这个博客的原因吧，之前用SSM的时候，也用过pageHepler，但是一切也OK,后来打算利用springboot搭建项目的时候在数据量小的时候(也就是数据还没有到分页的时候)也没又出现问题，但是当数据量慢慢增多的时候突然发现了一件事，就是每次利用pageHepler发过去的数据，数据其实传的是全部！！！！</p><p>吓得我赶紧后台debug了一下，没有任何异常原因，经过查询作者的github项目主页的时候发现那么几个错误解决办法，希望对此有帮助。</p><h2 id="pagehepler失效，查询全部数据"><a href="#pagehepler失效，查询全部数据" class="headerlink" title="pagehepler失效，查询全部数据"></a>pagehepler失效，查询全部数据</h2><p>这里我的Springboot是2.1.4版本，Mybatis和pageHelper版本在下面</p><pre><code class="xml">&lt;dependency&gt;           &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;           &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;           &lt;version&gt;1.2.12&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;           &lt;version&gt;2.0.1&lt;/version&gt;       &lt;/dependency&gt;</code></pre><p>在一开始，我查询的博客大多都是说什么版本不对啊，或者没有配置属性啊，这里我澄清一点，版本问题确实有，但是充其量是pagehepler版本太低的问题。而且，版本冲突的时候springboot本身就会报错！还有就是属性问题，根据我的测试，(本人mysql数据库)直接上默认属性就行，根本不需要任何配置。所以说那些博客真的很浪费大家时间。</p><p>那么，这个失效的原因在哪里呢。经过反复的排查，发现了作者这句话，就是PageHepler.startstartPage(pageNum,pageSize);这句话，必须要后面紧跟查询语句，不能插任何逻辑语句，这就很蛋疼了，因为我只前利用SSM的时候就直接在函数的开头写上这句话，防止啥时候忘了。<br>然后加上这句话的时候，返回的数据正常了。。</p><p>正当我以为这个问题解决了的时候，随之出现了第二个bug….</p><h2 id="pageHepler返回的total不正确"><a href="#pageHepler返回的total不正确" class="headerlink" title="pageHepler返回的total不正确"></a>pageHepler返回的total不正确</h2><p>当我兴奋的打开我的网站乱搞的时候，突然发现，数据倒是对了，但是返回值完全对不上，根本就是当前页面的数据总量。吓得我赶紧去翻sql日志，结果日志也显示我已经查询过了。</p><p>得，还得去作者主页。。。</p><p>经过盘了一下主页发现，原来是我查询完了之后，不想暴露一些关键属性，比如外键啊啥的，就利用lambda得stream进行了一次流操作。具体逻辑在这</p><pre><code class="java">// 查询前期操作        Integer blogger_id = userService.getUserIdByToken(token);        BlogExample blogExample = new BlogExample();        BlogExample.Criteria criteria = blogExample.createCriteria();        criteria.andBloggerIdEqualTo(blogger_id);        // 开始查询        PageHelper.startPage(pageNum,pageSize);        List&lt;BlogWithBLOBs&gt; blogWithBLOBs = blogMapper.selectByExampleWithBLOBs(blogExample);// 查询到结果并且处理        blogWithBLOBs =  blogWithBLOBs.stream().map(item-&gt;{return new BlogWithBLOBs(item.getId()                ,item.getStatus(),                item.getTitle(),                item.getSummary(),                item.getReleaseDate(),                item.getNearestModifyDate(),                item.getTagTitle(),                item.getContent(),                item.getContentMd());}).collect(Collectors.toList());// page结构化准备分页数据        PageInfo&lt;BlogWithBLOBs&gt; list = new PageInfo&lt;&gt;(blogWithBLOBs);        DataGrid dataGrid = new DataGrid();        dataGrid.setTotal(list.getTotal());        dataGrid.setRows(list.getList());</code></pre><p>但是作者的主页说过这样一句话<br><img src="https://s2.ax1x.com/2019/07/28/e1eK4P.png" alt></p><p>lambda会让数据丢失，所以total就返回了默认的当前<strong>所有数据</strong>，这也就是为什么我们会看到total返回不正确了，这是人家默认的啊！！！</p><p>还有一点值得注意的就是，作者说我们返回的查询结果其实也是Page属性，也就是PageHepler.start的那个返回值。</p><p>那么现在解决办法就很明显了，我们可以将get的List用一个对象接收，然后对那个对象进行处理。</p><p>或者，放弃利用lambda(不可能)</p>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> pagehepler </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vue传参问题</title>
      <link href="/2019/07/27/%E5%85%B3%E4%BA%8Evue%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/27/%E5%85%B3%E4%BA%8Evue%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于vue传参问题"><a href="#关于vue传参问题" class="headerlink" title="关于vue传参问题"></a>关于vue传参问题</h1><p>传参的时候我比较喜欢利用params方式传参</p><p>比如</p><blockquote><p>标签式传参</p></blockquote><pre><code class="html">&lt;router-link :to=&quot;{name:&#39;xx&#39;,params:{xxx:xxx}}&quot;&gt;&lt;/router-link&gt;</code></pre><blockquote><p>编程式传参</p></blockquote><pre><code class="javaScript">this.$router.push({  name:&#39;xxx&#39;,  params:{    xx:xx,    xx:xx  }  })</code></pre><p>跳转过去的网页利用this.$route.params.xx接收。</p><p>但是一定要注意的一点是,this.$router和this.$route的区别！！！</p><ul><li>this.$router</li></ul><p>router 实例。</p><ul><li>this.$route</li></ul><p>当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iview中table的使用经验</title>
      <link href="/2019/07/26/iview%E4%B8%ADtable%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/"/>
      <url>/2019/07/26/iview%E4%B8%ADtable%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="iview中table的使用经验"><a href="#iview中table的使用经验" class="headerlink" title="iview中table的使用经验"></a>iview中table的使用经验</h1><p>由于iview官网上面的讲解真的是非常的简单，所以像是我这种阿库娅用户真的很不友好，所以这个博客是讲解iview的Table如何和springboot进行后端交互，类似bootStrap-table的那种吧，注意这里没有用render去渲染，因为我是真的不会啊！！！</p><h2 id="前端代码框架编写"><a href="#前端代码框架编写" class="headerlink" title="前端代码框架编写"></a>前端代码框架编写</h2><pre><code class="html">&lt;Table :columns=&quot;managerColumns&quot; :data=&quot;articleData&quot; stripe &gt;            &lt;div slot-scope=&quot;{ row, index }&quot; slot=&quot;action&quot;&gt;                &lt;Button type=&quot;primary&quot;  style=&quot;margin-right: 5px&quot;&gt;编辑&lt;/Button&gt;                &lt;Button type=&quot;error&quot;  &gt;删除&lt;/Button&gt;            &lt;/div&gt;        &lt;/Table&gt;        &lt;!-- 分页列表 --&gt;        &lt;div style=&quot;margin: 10px;overflow: hidden&quot;&gt;            &lt;div style=&quot;float: right;&quot;&gt;                &lt;Page :total=&quot;total&quot;  :current=&quot;pageNum&quot; @on-change=&quot;changepage&quot;                @on-page-size-change=&quot;_nowPageSize&quot;                show-total show-sizer&gt;&lt;/Page&gt;            &lt;/div&gt;</code></pre><p>在前端渲染的是这种样子 =&gt;</p><p><img src="https://s2.ax1x.com/2019/07/26/eu11gO.png" alt></p><p>这里简明的说明里面的属性吧</p><p>首先是Table标签里面的columns是 表头属性  后台的数据是这样的</p><pre><code class="json">managerColumns: [{      title: &#39;标题&#39;,      key: &#39;title&#39;,  },  {      title: &#39;更新时间&#39;,      key: &#39;nearestModifyDate&#39;,  },  {      title: &quot;操作&quot;,      slot: &#39;action&#39;  }],</code></pre><p>然后是data属性，这个就是我们需要从后台需要渲染的数据了。</p><p>在<table>标签里面，我们如果需要进行操作的话，需要用到solt-scope这个属性，具体我也不太清楚，只能说是：可以对应表头的一个东西，其他的照抄就完事了。<br>需要注意的是，如果你用到了slot，那个表头的json一定不能用key,而是用slot.</table></p><p>接下来就是分页的按钮们了</p><p>样式不需要动，唯一确定的是page里面的属性</p><p>total =&gt; 其实就是你从后台获取到的数据总量</p><p>current =&gt; 这个是现在你所在的页数</p>]]></content>
      
      
      <categories>
          
          <category> iview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis的走过的坑</title>
      <link href="/2019/07/26/mybatis%E7%9A%84%E8%B5%B0%E8%BF%87%E7%9A%84%E5%9D%91/"/>
      <url>/2019/07/26/mybatis%E7%9A%84%E8%B5%B0%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis的走过的坑"><a href="#mybatis的走过的坑" class="headerlink" title="mybatis的走过的坑"></a>mybatis的走过的坑</h1><h2 id="mybatis字段映射"><a href="#mybatis字段映射" class="headerlink" title="mybatis字段映射"></a>mybatis字段映射</h2><p>这里说到的字段映射指的是在没有任何配置的时候mybatis和tkmybatis是不能将数据库中的下划线转成java中驼峰命名的<br>我们需要开启设置：</p><pre><code class="yaml">mybatis:  configuration:    map-underscore-to-camel-case: true</code></pre><h2 id="关于MyBatis自增主键那些事"><a href="#关于MyBatis自增主键那些事" class="headerlink" title="关于MyBatis自增主键那些事"></a>关于MyBatis自增主键那些事</h2><p>有于当初利用SSM框架编写Mybatis的时候，mybatis的mapper文件等都是逆向生成的，所以用的时候非常方便，但是除了一点，就是插入数据的时候，主键是必须要写的，但是为了安全和方便(其实懒占主要因素)，否则就会爆出sql语句错误，最后解决办法如下:</p><ol><li>mysql表中要把自增主键的选项打开</li></ol><p>其实大部分人只要打开自增主键就已经OK了，但是有的时候电脑抽风还是报错，那么就需要更改逆向出来的源码了</p><p>找到你想插入的地方<insert id="xxx"></insert></p><p>然后添加这么一个关键字:</p><pre><code class="xml"> &lt;insert id=&quot;insertSelective&quot;   useGeneratedKeys=&quot;true&quot; parameterType=&quot;xxx&quot;&gt;</code></pre><p>这个useGeneratedKeys就是自增主键的意思</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESETFUL四种方式提交区别</title>
      <link href="/2019/07/25/RESETFUL%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/25/RESETFUL%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8F%90%E4%BA%A4%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="RESETFUL四种方式提交区别"><a href="#RESETFUL四种方式提交区别" class="headerlink" title="RESETFUL四种方式提交区别"></a>RESETFUL四种方式提交区别</h1><hr><p>如今，RESETFUL服务特别受开发者的喜欢，因为他更加的结构化。</p><p>那么下面对ReSet的四种请求方法做一个说明=&gt;</p><p>get  =&gt;  我一般会在请求一些资源的时候，比如说分页查询的表格等</p><p>post =&gt; 一般会在安全性较强的地方用，比如说登陆、登出，还有新建某种资源的时候用，比如说新建订单</p><p>put =&gt; 一般在更新某种资源的时候利用</p><p>delete =&gt; 这个没什么说的，就是删除某种资源</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot Filter中无法注入Bean对象的解决办法</title>
      <link href="/2019/07/24/springboot-Filter%E4%B8%AD%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/07/24/springboot-Filter%E4%B8%AD%E6%97%A0%E6%B3%95%E6%B3%A8%E5%85%A5Bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot-Filter中无法注入Bean对象的解决办法"><a href="#springboot-Filter中无法注入Bean对象的解决办法" class="headerlink" title="springboot Filter中无法注入Bean对象的解决办法"></a>springboot Filter中无法注入Bean对象的解决办法</h1><hr><p>这次在项目中编写Token代码逻辑的时候，遇到了一个空指针问题，经过排查发现，Filter里面无法利用@Autowired。<br>所以此次文章用来解决这一问题。</p><p>经过查阅资料发现，spring容器初始化Bean的顺序是Listener-&gt;Filter-&gt;servlet.<br>那么我可以在Listener里面预先加载我们想要的Bean对象，然后经过Filter构造函数将对象传进去。</p><p>下面是具体的代码:</p><p>这个是启动监听器。</p><pre><code class="java">@Slf4j@Configuration@Order(Ordered.HIGHEST_PRECEDENCE)public class StartLinster implements ApplicationListener&lt;ApplicationEvent&gt; {    @Autowired    TokenService tokenService;    @Override    public void onApplicationEvent(ApplicationEvent applicationEvent) {        log.info(&quot;提前注入token&quot;);    }}</code></pre><blockquote><p>里面TokenService是Service层，也是我们想要注入的对象。</p></blockquote><p>这个是Filter启动的相应代码，可以看到，Listener启动顺序是最高的。</p><pre><code class="java">   @Bean   public FilterRegistrationBean&lt;AuthenticationFilter&gt; initAuthenticationFilter(TokenService tokenService){       FilterRegistrationBean&lt;AuthenticationFilter&gt; authenticationFilterFilter = new FilterRegistrationBean&lt;&gt;();       AuthenticationFilter authenticationFilter = new AuthenticationFilter(tokenService);       authenticationFilter.addExcludePatterns(&quot;/api/user/login&quot;);       authenticationFilterFilter.setFilter(authenticationFilter);       authenticationFilterFilter.setOrder(Ordered.LOWEST_PRECEDENCE);       authenticationFilterFilter.addUrlPatterns(&quot;/api/*&quot;);       return authenticationFilterFilter;   }</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aop中获取请求消息和属性</title>
      <link href="/2019/07/23/aop%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/07/23/aop%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="aop中获取请求消息和属性"><a href="#aop中获取请求消息和属性" class="headerlink" title="aop中获取请求消息和属性"></a>aop中获取请求消息和属性</h1><hr><p>这篇博客仅仅提供代码。</p><p>由于我们利用@interface并且搭配上Aspect里面的@annotation可以做到切面的效果，所以我在项目上运用了这项技术，他们的参数是ProceedingJoinPoint joinPoint,并没有HttpServletRequest,但是我们又需要请求头的信息，所以代码如下：</p><pre><code class="java">ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();       HttpServletRequest servletRequest = attributes.getRequest();</code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue+springboot前后端分离中的跨域问题</title>
      <link href="/2019/07/22/vue-springboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/22/vue-springboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%AD%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-springboot前后端分离中的跨域问题"><a href="#vue-springboot前后端分离中的跨域问题" class="headerlink" title="vue+springboot前后端分离中的跨域问题"></a>vue+springboot前后端分离中的跨域问题</h1><p>如今前后端分离已经成为了热门，那么本次话题就是如何解决前后端分离中的跨域问题。</p><p>首先，我们来看一下什么是前后端分离。</p><p><strong>前后端分离</strong>,其实无非来说就是因为项目越来越大，从而让前端工程师和后端工程师不得不分开成为两个具体项目,二者之间只需要按照api来约定，从而大大简化了开发的工程量。</p><h2 id="如何做到前后端分离"><a href="#如何做到前后端分离" class="headerlink" title="如何做到前后端分离"></a>如何做到前后端分离</h2><p>一般来说，前端可以用vue-cli搭建，它可以用webpack进行打包，并且可以利用nginx进行访问。</p><p>后端的话可以利用,spring全家桶，you know what I mean.</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>那么，问题来了，当我们没有用前后端分离的时候，跨域问题一般不存在，或者存在于分布式中，那时候我们可以利用js解决这个问题，但是现在我们可以在后端中着手这个问题。</p><p>解决思路:</p><p>  利用springboot的filter来解决这一问题</p><pre><code class="java">package run.app.config;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/7/8 23:43 * Description: ://TODO ${END} */import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpHeaders;import org.springframework.web.cors.CorsUtils;import org.springframework.web.filter.GenericFilterBean;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Filter for CORS. * 解决跨域问题 * @author johnniang */@Slf4jpublic class CorsFilter extends GenericFilterBean {    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        log.info(&quot;进入&quot;);        HttpServletRequest httpServletRequest = (HttpServletRequest) request;        HttpServletResponse httpServletResponse = (HttpServletResponse) response;        // Set customized header        httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, httpServletRequest.getHeader(HttpHeaders.ORIGIN));        httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, &quot;x-requested-with&quot;);        httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);        httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, &quot;true&quot;);        httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, &quot;3600&quot;);//        todo 没看懂 好像是解决跨越问题        if (!CorsUtils.isPreFlightRequest(httpServletRequest)) {            chain.doFilter(httpServletRequest, httpServletResponse);        }    }}</code></pre><p>上面的是filter的写法，然后我们在注册中心注册一下就好了</p><pre><code class="java">@Slf4j@Configuration@EnableConfigurationProperties(AppProperties.class)public class FilterConfiguration {    @Bean    public FilterRegistrationBean&lt;CorsFilter&gt; initCorsFilter(){        FilterRegistrationBean&lt;CorsFilter&gt; corsFilter = new FilterRegistrationBean&lt;&gt;();        corsFilter.setOrder(Ordered.HIGHEST_PRECEDENCE);        corsFilter.setFilter(new CorsFilter());        corsFilter.addUrlPatterns(&quot;/*&quot;);        return corsFilter;    }}</code></pre><h2 id="后期修改-重要"><a href="#后期修改-重要" class="headerlink" title="后期修改(重要)"></a>后期修改(重要)</h2><p>由于vue默认请求编码格式是content-type为application/x-www-form-urlencoded的数据。<br>但是现在有一个需求是在post请求的时候将content-type修改为application/json; charset=utf-8格式，并且后台利用@RequestBody获取到参数，而且我们都知道这个参数并不能处理application/x-www-form-urlencoded的数据。<br>但是当我利用上面的过滤器的时候，还是出现了禁止访问的现象，跨域问题仍然存在，仔细查看发现是我并不允许application/json格式的对象，所以上面的filter中的请求头应该改成</p><pre><code class="java">httpServletResponse.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</code></pre><p>现在问题解决。</p><h2 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h2><p>如果你打开你的控制台会发现，你的跨域请求会发出两次或者三次，但是只有一次是你真正想要的</p><p>这是你真正的请求<br><img src="https://s2.ax1x.com/2019/07/22/eCyCy4.png" alt></p><p>下面的多出来的请求</p><p><img src="https://s2.ax1x.com/2019/07/22/eCy10A.png" alt></p><h2 id="OPTIONS分析"><a href="#OPTIONS分析" class="headerlink" title="OPTIONS分析"></a>OPTIONS分析</h2><p>那么，这个OPTIONS是什么呢？<br>经过filter发现，我们是允许这个OPTIONS请求的，后来经过google发现，<br>W3C规范：跨域请求中，分为简单请求和复杂请求；所谓的简单请求，需要满足如下几个条件：</p><ul><li>GET，HEAD，POST请求中的一种；</li><li>除了浏览器在请求头上增加的信息（如Connection，User-Agent等），开发者仅可以增加Accept，Accept-Language，Content-Type等；</li><li>Content-Type的取值必须是以下三个：application/x-www-form-urlencoded，multipart/form-data，text/plain。</li></ul><p>在发出复杂请求的之前，就会出现一次OPTIONS请求。<br>OPTIONS请求可以被称作一次嗅探请求，通过这个方法，客户端可以在采取具体的资源请求之前，决定对资源采取何种必要措施。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue请求后端的一般思路</title>
      <link href="/2019/07/22/vue%E8%AF%B7%E6%B1%82%E5%90%8E%E7%AB%AF%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF/"/>
      <url>/2019/07/22/vue%E8%AF%B7%E6%B1%82%E5%90%8E%E7%AB%AF%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="vue请求后端的一般思路"><a href="#vue请求后端的一般思路" class="headerlink" title="vue请求后端的一般思路"></a>vue请求后端的一般思路</h1><p>这里说的vue指的是利用vue-cli搭建的前端项目，并且后端的项目是利用springboot搭建。</p><p>做前后端分离的时候，我们不可避免的会和后端出现交互，那么如何结构化的进行交互是这篇文章的重点。</p><blockquote><p>这里没有采用ajax，而是利用了axios</p></blockquote><h2 id="axios-封装"><a href="#axios-封装" class="headerlink" title="axios 封装"></a>axios 封装</h2><p>首先如果进行交互，那么我们肯定不能只考虑交互成功的时候，肯定也要考虑因为各种因素导致的失败，但是如果每次访问都要考虑同一因素导致的失败就会产生代码冗杂。</p><p>因此，我们可以考虑利用axios的拦截器对一些信息进行统一处理。</p><p>并且如果进行交互，那么vuex也是必须的，所以，如果不熟悉vuex的，要先进行了解。</p><h2 id="下载相应的模块"><a href="#下载相应的模块" class="headerlink" title="下载相应的模块"></a>下载相应的模块</h2><p>首先，现在axios是必须的</p><pre><code class="bash">npm install axios --savenpm install vue-axios --save # vue版的axios的插件npm install qs.js --save # 可以对字符串进行json处理npm install  js-md5 # md5加密</code></pre><h2 id="service-js进行封装"><a href="#service-js进行封装" class="headerlink" title="service.js进行封装"></a>service.js进行封装</h2><p>在我的项目中，我新建了一个util工具包，并且新建了一个service.js来封装axios，具体代码如下:</p><pre><code class="javaScript">import axios from &#39;axios&#39;import qs from &quot;qs&quot;import store from &#39;../store&#39;;import { Message } from &#39;iview&#39;;// axios相应的封装const service = axios.create({    timeout: 5000,    baseURL: &quot;http://localhost:8099&quot;});service.interceptors.request.use(    config =&gt; {        const token = store.state.token;        if (token) {            config.headers[&quot;Authentication&quot;] = token        }        config.method === &#39;post&#39; ?            config.data = qs.stringify({...config.data }) :            config.params = {...config.params };        config.headers[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;        return config;    }, error =&gt; {        return Promise.reject(error);    })service.interceptors.response.use(    response =&gt; {        return response;    },    error =&gt; {      // 这里只是简单的判断了是不是超时，真实的项目肯定还复杂        if (error.message.includes(&#39;timeout&#39;)) { // 判断请求异常信息中是否含有超时timeout字符串            Message.error(&quot;网络连接超时&quot;);            //return Promise.reject(error); // reject这个错误信息        } else {            Message.error(&quot;服务异常！&quot;);        }        return Promise.reject(error);    });export default service</code></pre><h2 id="vuex进行相应的模块封装"><a href="#vuex进行相应的模块封装" class="headerlink" title="vuex进行相应的模块封装"></a>vuex进行相应的模块封装</h2><p>比如说本次的项目中，我们可以写一个user模块，来控制用户登陆。</p><p>代码如下:</p><pre><code class="javaScript">import axios from &#39;axios&#39;import userApi from &#39;@/api/user&#39;const state = {    username: &#39;&#39;,    password: &#39;&#39;,    token: null};const getters = {    getToken: state =&gt; state.token};const mutations = {    setToken: (state, token) =&gt; {        state.token = token    }};const actions = {    login({ commit }, { username, password }) {        return new Promise((resolve, reject) =&gt; {            userApi.login(username, password)                .then(response =&gt; {                    const token = response.data.token;                    commit(&#39;setToken&#39;, token);                    resolve(response)                })                .catch(error =&gt; {                    reject(error)                })        })    }};export default { state, getters, mutations, actions };</code></pre><p>上面的action里面的login方法是单独抽离出来的代码，用来实现登陆功能。</p><h1 id="方法的封装"><a href="#方法的封装" class="headerlink" title="方法的封装"></a>方法的封装</h1><p>为了对应结构化的处理，我们需要将方法单独抽离出来。</p><p>比如此次项目，我们新建一个api文件夹，里面新建一个user.js</p><p>里面具体代码如下:</p><pre><code class="javaScript">import service from &#39;@/util/service&#39;import md5 from &#39;js-md5&#39;const userApi = {}// 登陆函数userApi.login = (username, password) =&gt; {    return service({        url: &#39;/login&#39;,        data: {            username: md5(username),            password: md5(password)        },        method: &#39;post&#39;    })}export default userApi</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iview 制作动态菜单和面包屑</title>
      <link href="/2019/07/20/iview-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95%E5%92%8C%E9%9D%A2%E5%8C%85%E5%B1%91/"/>
      <url>/2019/07/20/iview-%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95%E5%92%8C%E9%9D%A2%E5%8C%85%E5%B1%91/</url>
      
        <content type="html"><![CDATA[<h1 id="iview-制作动态菜单和面包屑"><a href="#iview-制作动态菜单和面包屑" class="headerlink" title="iview 制作动态菜单和面包屑"></a>iview 制作动态菜单和面包屑</h1><p>本次项目搭建的后台是这样的，可以动态生成菜单导航和面包屑，故此记录<br><img src="https://s2.ax1x.com/2019/07/20/ZzOSuq.png" alt></p><ul><li>生成动态菜单</li></ul><p>首先我们直接粘贴iview官网的导航菜单的demo代码</p><p>我的项目结构如下图所示:</p><p><img src="https://s2.ax1x.com/2019/07/20/ZzOV29.png" alt></p><p>首先，菜单的路由表如下:</p><pre><code class="javascript">export default new Router({    mode: &#39;history&#39;,    routes: [{            path: &#39;/index.html&#39;,            meta: { title: &#39;主页&#39; },            component: () =&gt;                import (&#39;@/ivews/index&#39;),            children: [{                path: &#39;status&#39;,                meta: [&quot;主页&quot;, &quot;状态面板&quot;],                component: () =&gt;                    import (&#39;@/components/status&#39;)            }]        },        {            path: &#39;/login.html&#39;,            meta: { title: &#39;登陆&#39; },            component: () =&gt;                import (&#39;@/ivews/login&#39;)        },        {            path: &#39;/&#39;,            redirect: &#39;/index.html&#39;        }    ]})</code></pre><p>vuex状态管理menu.js内容如下:</p><pre><code class="javascript">const state = {    menu: [{            id: 1,            to: &#39;/index.html/status&#39;,            name: &#39;状态面板&#39;,            icon: &#39;md-desktop&#39;        },    ],}const getters = {    menus: state =&gt; state.menu}const mutations = {}const actions = {}export default { state, getters, mutations, actions }</code></pre><p>header-manager.vue里面写的就是导航菜单，具体代码如下：</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;    &lt;Menu mode=&quot;horizontal&quot; :theme=&quot;theme1&quot; &gt;        &lt;MenuItem  v-for=&quot;(menu,index) in menus&quot; :key=&#39;index&#39; :name=&quot;menu.id&quot; :to=&quot;menu.to&quot;&gt;            &lt;Icon :type=&quot;menu.icon&quot; /&gt;            {{menu.name}}        &lt;/MenuItem&gt;    &lt;/Menu&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import {Menu,MenuItem,Submenu,MenuGroup} from &#39;iview&#39; import {mapGetters} from &#39;vuex&#39;    export default {      name: &#39;Header&#39;,        data () {            return {                theme1: &#39;dark&#39;            }        },        components:{          Menu,          MenuItem,          MenuGroup,          Submenu        },        methods: {            query(){                console.log(menus);            }        },        computed: {            ...mapGetters({                menus: &#39;menus&#39;            })        },    }&lt;/script&gt;</code></pre><blockquote><p>总结一下思路就是，根据iview的MenuItem里面的to属性，来对应路由表的地址，从而做到点击之后跳转相应页面的效果，然后根据vuex动态生成当前菜单内容就好了</p></blockquote><ul><li>动态生成面包屑</li></ul><p>本次项目的面包屑主要完成对象当前路径名称的功能，因此，我们可以根据对应当前路由路径来完成，重要代码如下:</p><pre><code class="html">&lt;Breadcrumb  :style=&quot;{margin: &#39;20px 0&#39;}&quot;&gt;        &lt;BreadcrumbItem v-for=&quot;(item,index) in $route.meta&quot; :key=&#39;index&#39;&gt;          {{item}}&lt;/BreadcrumbItem&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue全家桶搭建项目和入门理解</title>
      <link href="/2019/07/07/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/"/>
      <url>/2019/07/07/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="vue全家桶搭建项目和入门理解"><a href="#vue全家桶搭建项目和入门理解" class="headerlink" title="vue全家桶搭建项目和入门理解"></a>vue全家桶搭建项目和入门理解</h1><hr><p>由于目前需要做一个博客项目，所以需要先搭建前端，springboot + vue是一个不错的选择，所以这篇博客写的是我目前对vue的理解。</p><h2 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h2><p>其实这里没有网上说的这么复杂。完全可以这么理解，他们说的一些vue知识属于框架,类似于bootstrap那种的(其实并不是，不过你可以先这么理解)，需要你去理解一些标签啊，语法啊那种东西，然后这个脚手架是你搭建的一个<strong>前端</strong>项目，这里你可以理解成java后端的那种搭环境，比如spring啊什么的。</p><h2 id="初始化vue脚手架-vue-cli-2-x"><a href="#初始化vue脚手架-vue-cli-2-x" class="headerlink" title="初始化vue脚手架(vue-cli 2.x)"></a>初始化vue脚手架(vue-cli 2.x)</h2><p>在保证自己电脑上安装了node.js前提下，我们需要安装vue环境和webpack.</p><pre><code class="bash">npm install vuenpm install -g vue-cli #安装脚手架</code></pre><p>这里的webpack其实就是一个工具将你写的vue打包成html,js,css文件</p><ul><li>安装一个vue-cli项目<pre><code class="bash">vue  init webpack [ProjectName]</code></pre>这里会下载一大堆东西，然后出现一些让你确认的东西，比如说是项目名啊，作者啊，路由啊(这个一会讲)，一直敲回车就ok。</li></ul><ul><li>项目目录结构</li></ul><p>安装完成后，我们的项目结构是这个样子的<br><img src="https://s2.ax1x.com/2019/07/07/ZBb8zt.png" alt></p><p>package.json -&gt; 这个是项目必须的，每次安装插件什么的都需要这个json，你可以把它想象成gradle或者maven</p><p>index.html -&gt; 网页的门面，后面的初始化Vue对象也是初始在了这个地方</p><p>test -&gt; 单元测试，相当于Junit</p><p>static -&gt; 这个是在webpack打包后直接将里面的东西直接转移到了dist/static</p><p>src -&gt; 整个项目基本上你都要在里面写东西</p><p>src-&gt; assets -&gt; 项目的静态资源，存放一些js,css,图片什么的。</p><p>node_modules -&gt; 你下载的一些插件都在里面，比如路由,jQuery</p><p>config -&gt;配置文件包</p><p>build -&gt;项目启动的一些包，比如端口什么的</p><ul><li>项目启动</li></ul><pre><code class="bash">npm run dev # 启动项目npm run build # 将你写的项目打包成html,一般都是在项目写完的时候这么干</code></pre><h2 id="初始化vue脚本-vue-cli-3-x"><a href="#初始化vue脚本-vue-cli-3-x" class="headerlink" title="初始化vue脚本(@vue/cli 3.x)"></a>初始化vue脚本(@vue/cli 3.x)</h2><p> 到我目前开始修改之前vue的博客的时候 vue cli 已经升级到4.x,但是因为4.x是基于Vue 3.x版本的，和我之前使用的Vue2.x有很大的区别。所以现在暂时先使用3.x。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">    npm install @vue/cli 3.11.0    vue -V # 只要不是什么4.x就ok</code></pre><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><pre><code class="bash">    vue create [name]</code></pre><h2 id="安装必要插件"><a href="#安装必要插件" class="headerlink" title="安装必要插件"></a>安装必要插件</h2><ul><li>首先是路由和vuex,由于一开始创建项目的时候提示我们是否安装路由了，所以这里我不需要安装，直接安装vuex.</li></ul><pre><code class="bash">npm install vuex --save # save 是保存到本地的意思</code></pre><blockquote><p>上面都是Vue Cli 2.x 必须安装的，VueCli3 在创建项目时可以自定义。</p></blockquote><h2 id="安装错误处理"><a href="#安装错误处理" class="headerlink" title="安装错误处理"></a>安装错误处理</h2><p>有的时候我们创建vue项目会出现下面的Bug</p><h3 id="vue路由器入门"><a href="#vue路由器入门" class="headerlink" title="vue路由器入门"></a>vue路由器入门</h3><p>我们要清楚，vue里面切换页面是用vue路由来实现的，我们初始创建的项目里面是存在src/router/router.js这个文件，这里面的文件是我们所有配置路由的文件，目前我的里面随便写了一个页面，具体代码如下:</p><p>首先是我们在compnents/下面随便创建一个页面</p><pre><code class="html">&lt;template&gt;    &lt;Input v-model=&quot;value&quot; placeholder=&quot;Enter something...&quot; style=&quot;width: 300px&quot; /&gt;&lt;/template&gt;&lt;script&gt;    export default {        data () {            return {                value: &#39;&#39;            }        }    }&lt;/script&gt;</code></pre><p>上面的代码是抄自iview官网的一个input标签</p><pre><code class="javascript">import Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;import HelloWorld from &#39;@/components/HelloWorld&#39;Vue.use(Router)export default new Router({  mode: &#39;history&#39;,  routes: [    {      path: &#39;/&#39;,      name: &#39;HelloWorld&#39;,      component: ()  =&gt; import(&#39;@/components/HelloWorld&#39;)    },    {      path: &#39;/login&#39;,      name: &#39;login&#39;,      component: () =&gt; import(&#39;@/components/login&#39;)    }  ]})</code></pre><p>mode:’history’是将网页上的#删除掉。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中自定义属性实体类和应用</title>
      <link href="/2019/06/30/springboot%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2019/06/30/springboot%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot中自定义属性实体类和应用"><a href="#springboot中自定义属性实体类和应用" class="headerlink" title="springboot中自定义属性实体类和应用"></a>springboot中自定义属性实体类和应用</h1><p>我们在当初学习SSM的时候学习过@Value这个属性，可以将配置文件中的属性加载到想要加载的类中，这个当然是一个可行的办法,但是如果属性有很多一直写@Value也是一件很麻烦的事情，现在我们可以用<strong>@ConfigurationProperties</strong>和<strong>@EnableConfigurationProperties</strong>这两个注解完成这个问题。</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><ul><li>配置文件如下:</li></ul><pre><code class="yaml">whoami:  auto-scan: false  auto-del: true</code></pre><p>上面的配置文件就相当于一个例子，没有什么作用<br>下面我们写自定义的属性类</p><ul><li>属性类：</li></ul><p>@ConfigurationProperties(prefix = “whoami”)的作用就是将whoami的前缀的配置加载到这个实体类中</p><pre><code class="java">@Data@ConfigurationProperties(&quot;whoami&quot;)public class AppProperties {    private Boolean autoDel = false;    private Boolean autoScan = true;}</code></pre><blockquote><p>在这里我们可以看出来，实体类里面的属性默认值和配置文件正相反，而且配置文件的属性写法是’-‘风格，而自定义文件里面的是驼峰写法，其实只要能对应就完全没问题。</p></blockquote><ul><li>验证一下是否导入</li></ul><p>先说一下@EnableConfigurationProperties的作用，其实就是让@ConfigurationProperties生效</p><pre><code class="java">@Configuration@EnableConfigurationProperties(AppProperties.class)public class FilterConfiguration {    @Autowired    AppProperties appProperties;    @Bean    public FilterRegistrationBean&lt;LogFilter&gt; initLogFilter(){        log.info(&quot;属性配置；{}&quot;,appProperties.getAutoDel());        ...</code></pre><p>上面的代码是一个配置类，我们可以看到，我们在初始化一个过滤器的时候顺便打印了AutoDel这个属性，，运行一下，可以看到打印台的信息</p><p><img src="https://s2.ax1x.com/2019/06/30/ZlXeRs.png" alt></p><p>在这里我们可以看到，打印出来的是我们配置文件的信息。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven导入本地jar包</title>
      <link href="/2019/06/22/maven%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0jar%E5%8C%85/"/>
      <url>/2019/06/22/maven%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0jar%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="maven导入本地jar包的方法"><a href="#maven导入本地jar包的方法" class="headerlink" title="maven导入本地jar包的方法"></a>maven导入本地jar包的方法</h1><p>我们有的时候会找不到maven仓库的地址，只能先下载jar包，然后保存到maven仓库中。或者自己开发的jar包，然后自己导入到maven仓库中。</p><p>比如 我们现在在D盘由一个jar包，我们在命令行中输入</p><pre><code class="bash"># Dfile 文件路径# DgroupId DartifactId jar包信息# Dpackaging 打包方式mvn install:install-file -Dfile=D:\QRCode-3.0.0.jar -DgroupId=QRCode -DartifactId=QRCode -Dversion=3.0.0 -Dpackaging=jar</code></pre>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java写投票脚本自动化初探</title>
      <link href="/2019/06/07/java%E5%86%99%E6%8A%95%E7%A5%A8%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/06/07/java%E5%86%99%E6%8A%95%E7%A5%A8%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java写投票脚本自动化初探"><a href="#java写投票脚本自动化初探" class="headerlink" title="java写投票脚本自动化初探"></a>java写投票脚本自动化初探</h1><p>由于大学里面有一些任务需要投票，而又不想劳烦他人去帮我，所以打算自己写一个脚本来实现自动投票的功能。这里记录一下我的整个过程。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>java8<br>selenium3 实现chrome自动化的jar包<br>AUTolt 模拟键盘操作的软件</p><ul><li>导入selenium3</li></ul><p>这里我用的maven导入的，代码如下：</p><pre><code class="xml">      &lt;dependency&gt;           &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;           &lt;artifactId&gt;selenium-server&lt;/artifactId&gt;           &lt;version&gt;3.141.59&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;       &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;       &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;       &lt;version&gt;3.14.0&lt;/version&gt;   &lt;/dependency&gt;</code></pre><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="https://s2.ax1x.com/2019/06/08/VDUrOx.png" alt></p><h2 id="利用代码启动chrome"><a href="#利用代码启动chrome" class="headerlink" title="利用代码启动chrome"></a>利用代码启动chrome</h2><p>由于我这里是用的chrome实现的自动化，所以我们先要下chrome的<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">启动器</a></p><p><img src="https://s2.ax1x.com/2019/06/08/VDNzdO.png" alt></p><p>我们需要下载对应版本的启动器，不然会失效，首先查看自己的chrome版本，然后打开每个版本的文件夹，里面有notes.txt,显示对应的支持版本范围。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDU8O0.png" alt></p><p>下载好之后随便放到一个位置，后面根据路径引入即可，为了方便我将程序放到我的resource目录下了，如上图所示，代码如下：</p><pre><code class="java">        // 设置webdirver路径  这个BrushTicket是指的这个代码所在的类。        System.setProperty(&quot;webdriver.chrome.driver&quot;, BrushTicket.class.getClassLoader().getResource(&quot;chromedriver.exe&quot;).getPath());// 创建ChromeOptions，options可以设置一些网页请求头啥的        ChromeOptions options = new ChromeOptions();        //        指定本机chrome安装位置        options.setBinary(&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;);          // 创建WebDriver对象         ChromeDriver driver = new ChromeDriver(options);         // 打开那个网站         driver.get(&quot;https://www.wjx.cn/m/36384473.aspx&quot;);</code></pre><p>要记住，这个driver是最核心的类，我们后面根据这个driver在网页上做各种操作</p><h2 id="网页自动点击操作"><a href="#网页自动点击操作" class="headerlink" title="网页自动点击操作"></a>网页自动点击操作</h2><p>这个做法很简单，基本就是定位需要点击的位置，然后点击。</p><p>我截取了一小段代码，基本上所有点击的功能就都会了</p><pre><code class="java"> driver.findElement(By.xpath(&quot;//div[@id=&#39;divSubmit&#39;]/div[2]&quot;)).click();</code></pre><p>嗯哼，这里其实就需要注意一下这个xpath的定位问题，//div[@id=’xxx’],就是定位这个id为啥的元素，其实也可以用通配符，比如说 //* [@id=’xxx’]。后面再像洋葱一样，一层层的扒网页就行。</p><p>这个findElement的返回值是WebElement,这个元素又可以做各种操作，比如取css的属性，或者自己的属性，也可以点击和输入值(sendKeys)</p><h2 id="验证码-未完全解决"><a href="#验证码-未完全解决" class="headerlink" title="验证码(未完全解决)"></a>验证码(未完全解决)</h2><p>本来以为点完各种按钮，提交之后就完事，结果不！突然出现了验证码。</p><p>挣扎了很久，我选择了将验证码下载到本地后，然后解析出验证码这个解决办法。</p><h3 id="解决弹窗问题"><a href="#解决弹窗问题" class="headerlink" title="解决弹窗问题"></a>解决弹窗问题</h3><p>我们没有管验证码直接提交，会弹出一个警告框，我们先解决弹窗，后来发现问卷星的网页结构是，弹窗由一个div构成的，如果没有弹过的时候是没有这个结构的，第二次弹出之前，会将之前的div由display:none属性改回block属性，这样就简单了。具体代码如下：</p><pre><code class="java">/**    * 功能描述: //判断是否由弹出框    * @Param: [driver]    * @Return: boolean    * @Author: WHOAMI    * @Date: 2019/6/8 22:21     */private boolean ifAlert(ChromeDriver driver){       try       {         //定位元素，如果没有这个元素直接报错           WebElement  webElement = driver.findElement(By.xpath(&quot;//div[@id=&#39;alert_box&#39;]&quot;));           Thread.sleep(300);           if(!webElement.getCssValue(&quot;display&quot;).equals(&quot;none&quot;)) {               return true;           }       }       catch (Exception Ex)       {           Ex.printStackTrace();           return false;       }       return false;   }</code></pre><p>根据有没有Alert框判断是不是让我们输入验证码。</p><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><p>首先我们需要利用Action解决右键另存图片这个操作</p><p>具体代码如下：</p><pre><code class="java">  // 这个driver是ChromeDriver      Actions action = new Actions(driver);// 定位到验证码图片的位置      WebElement element = driver.findElement(By.xpath(&quot;//div[@id=&#39;tdCode&#39;]/table/tbody/tr/td[3]/img&quot;));// action移动到指定位置      action.moveToElement(element);// 休眠等待网页反应      Thread.sleep(200);// 这里模拟右键 打开菜单      action.contextClick(element).build().perform();      //模拟键盘操作（这里是移动向下方向键）  这个Robot是java.awt包下面的      Robot robot = new Robot();      Thread.sleep(400);      // 模拟键盘下方向键      robot.keyPress(KeyEvent.VK_DOWN);      Thread.sleep(400);      robot.keyPress(KeyEvent.VK_DOWN);// 模拟回车键      Thread.sleep(400);      robot.keyPress(KeyEvent.VK_ENTER);</code></pre><p><strong>后面需要了解一下java.awt这个包</strong></p><p>由于后面的选择保存位置然后下载操作是selenium3实现不了的，所以我们选择了AUTolt这个软件，<a href="https://www.autoitscript.com/site/autoit/downloads/" target="_blank" rel="noopener">下载网址</a><br>,然后安装即可，这里不再赘述。</p><p>软件安装好之后，是这个样子的</p><p><img src="https://s2.ax1x.com/2019/06/08/VDcYiq.png" alt></p><h4 id="操作AUTolt定位窗口"><a href="#操作AUTolt定位窗口" class="headerlink" title="操作AUTolt定位窗口"></a>操作AUTolt定位窗口</h4><p>先打开游览器准备上面另存为的操作<br><img src="https://s2.ax1x.com/2019/06/08/VDgCYq.png" alt></p><p>定位另存为窗口需要这个数据 Class: 比如上面的窗口时#32770，下面写脚本需要用。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDgklT.png" alt></p><p>定位按钮啊，编辑框啥的需要这个数据 CLassNameNN</p><p><img src="https://s2.ax1x.com/2019/06/08/VDge0J.png" alt></p><blockquote><p>其实我这里为了方便保存图片都是一个名字，而且为了方便都没有删除图片，所以这里出现了一个替换的问题，解决办法其实就是在定位一下替换的窗口和确定按钮就行</p></blockquote><h4 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h4><p>打开写脚本的工具，我的代码是这样的，改改就能用</p><pre><code class="bash">ControlFocus(&quot;另存为&quot;, &quot;&quot;,&quot;Edit1&quot;);ControlFocus(&quot;title&quot;,&quot;text&quot;,controlID) Edit1=Edit instance 1; Wait 10 seconds for the Upload window to appearWinWait(&quot;[CLASS:#32770]&quot;,&quot;&quot;,10); Set input focus to the edit control of Upload window using the handle returned by WinWait  ControlFocus(&quot;另存为&quot;,&quot;&quot;,&quot;Edit1&quot;)  Sleep(1000); Set the File name text on the Edit field  ControlSetText(&quot;另存为&quot;, &quot;&quot;, &quot;Edit1&quot;, &quot;buff.gif&quot;)  Sleep(200); Click on the Open buttonControlClick(&quot;另存为&quot;, &quot;&quot;,&quot;Button2&quot;);ControlFocus(&quot;确认另存为&quot;, &quot;&quot;,&quot;Edit2&quot;) WinWait(&quot;[CLASS:#32770]&quot;,&quot;&quot;,10) sleep(200)ControlClick(&quot;确认&quot;, &quot;&quot;,&quot;Button1&quot;);</code></pre><p>写完脚本后，保存成au3格式的文件，准备合成exe</p><h4 id="合成exe文件"><a href="#合成exe文件" class="headerlink" title="合成exe文件"></a>合成exe文件</h4><p>打开合成exe程序,确定脚本和生成exe路径即可。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDg2As.png" alt></p><h4 id="java引用该文件"><a href="#java引用该文件" class="headerlink" title="java引用该文件"></a>java引用该文件</h4><pre><code class="java">//调用你使用Compile Script to.exe生成的可执行exe文件 这个download.exe就是我生成的exe文件           //对Windows窗体进行操作：更换文件名，并保存到指定文件夹     Runtime.getRuntime().exec(&quot;D:\\code\\java\\download.exe&quot;);//代码等待程序完成在进行接下来的操作。     Thread.sleep(4000);</code></pre><h3 id="验证码去除干扰线"><a href="#验证码去除干扰线" class="headerlink" title="验证码去除干扰线"></a>验证码去除干扰线</h3><p>由于我没有学<strong>openCV</strong>算法，所以我就直接粘代码了。</p><pre><code class="java">/**   * 功能描述: //验证码去除干扰线   * @Param: [sfile：图片文件路径, destDir：文件名字]   * @Return: void   * @Author: WHOAMI   * @Date: 2019/6/8 22:11    */   public static void cleanLinesInImage(File sfile, String destDir)  throws IOException {       File destF = new File(destDir);       if (!destF.exists())       {           destF.mkdirs();       }       BufferedImage bufferedImage = ImageIO.read(sfile);       int h = bufferedImage.getHeight();       int w = bufferedImage.getWidth();       // 灰度化       int[][] gray = new int[w][h];       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               int argb = bufferedImage.getRGB(x, y);               // 图像加亮（调整亮度识别率非常高）               int r = (int) (((argb &gt;&gt; 16) &amp; 0xFF) * 1.1 + 30);               int g = (int) (((argb &gt;&gt; 8) &amp; 0xFF) * 1.1 + 30);               int b = (int) (((argb &gt;&gt; 0) &amp; 0xFF) * 1.1 + 30);               if (r &gt;= 255)               {                   r = 255;               }               if (g &gt;= 255)               {                   g = 255;               }               if (b &gt;= 255)               {                   b = 255;               }               gray[x][y] = (int) Math                       .pow((Math.pow(r, 2.2) * 0.2973 + Math.pow(g, 2.2)                               * 0.6274 + Math.pow(b, 2.2) * 0.0753), 1 / 2.2);           }       }       // 二值化       int threshold = ostu(gray, w, h);       BufferedImage binaryBufferedImage = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_BINARY);       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               if (gray[x][y] &gt; threshold)               {                   gray[x][y] |= 0x00FFFF;               } else               {                   gray[x][y] &amp;= 0xFF0000;               }               binaryBufferedImage.setRGB(x, y, gray[x][y]);           }       }       //去除干扰线条       for(int y = 1; y &lt; h-1; y++){           for(int x = 1; x &lt; w-1; x++){               boolean flag = false ;               if(isBlack(binaryBufferedImage.getRGB(x, y))){                   //左右均为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x-1, y)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x+1, y))){                       flag = true;                   }                   //上下均为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x, y-1))){                       flag = true;                   }                   //斜上下为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x-1, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x+1, y-1))){                       flag = true;                   }                   if(isWhite(binaryBufferedImage.getRGB(x+1, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x-1, y-1))){                       flag = true;                   }                   if(flag){                       binaryBufferedImage.setRGB(x,y,-1);                   }               }           }       }       // 矩阵打印       for (int y = 0; y &lt; h; y++)       {           for (int x = 0; x &lt; w; x++)           {               if (isBlack(binaryBufferedImage.getRGB(x, y)))               {                   System.out.print(&quot;*&quot;);               } else               {                   System.out.print(&quot; &quot;);               }           }           System.out.println();       }       ImageIO.write(binaryBufferedImage, &quot;jpg&quot;, new File(destDir, sfile               .getName()));   }   public static boolean isBlack(int colorInt)   {       Color color = new Color(colorInt);       if (color.getRed() + color.getGreen() + color.getBlue() &lt;= 300)       {           return true;       }       return false;   }   public static boolean isWhite(int colorInt)   {       Color color = new Color(colorInt);       if (color.getRed() + color.getGreen() + color.getBlue() &gt; 300)       {           return true;       }       return false;   }   public static int isBlackOrWhite(int colorInt)   {       if (getColorBright(colorInt) &lt; 30 || getColorBright(colorInt) &gt; 730)       {           return 1;       }       return 0;   }   public static int getColorBright(int colorInt)   {       Color color = new Color(colorInt);       return color.getRed() + color.getGreen() + color.getBlue();   }   public static int ostu(int[][] gray, int w, int h)   {       int[] histData = new int[w * h];       // Calculate histogram       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               int red = 0xFF &amp; gray[x][y];               histData[red]++;           }       }       // Total number of pixels       int total = w * h;       float sum = 0;       for (int t = 0; t &lt; 256; t++)           sum += t * histData[t];       float sumB = 0;       int wB = 0;       int wF = 0;       float varMax = 0;       int threshold = 0;       for (int t = 0; t &lt; 256; t++)       {           wB += histData[t]; // Weight Background           if (wB == 0)               continue;           wF = total - wB; // Weight Foreground           if (wF == 0)               break;           sumB += (float) (t * histData[t]);           float mB = sumB / wB; // Mean Background           float mF = (sum - sumB) / wF; // Mean Foreground           // Calculate Between Class Variance           float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);           // Check if new maximum found           if (varBetween &gt; varMax)           {               varMax = varBetween;               threshold = t;           }       }       return threshold;   }</code></pre><p>粘贴完代码后运行就会在相同的路径下覆盖原来的验证码图片，但是据我测试，这个代码效果不是很理想，所以才是未完成的操作。</p><h2 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h2><p>图片识别我打算利用tess4j。</p><p>maven导入项目</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt;            &lt;artifactId&gt;tess4j&lt;/artifactId&gt;            &lt;version&gt;4.3.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>导入语言包，这一步操作需要我们下载tess4j的源代码，然后解压之后将tessdata移出来，供下面导入。</p><p>接着我们利用tess4j进行图像识别</p><p>我发现根据上面图像处理之后，图像放大10倍后tess4j的识别率是最高的，所以有了下面的代码</p><pre><code class="java">  /**  * 功能描述: //将代码放大10倍  * @Param: [file]  * @Return: java.awt.image.BufferedImage  * @Author: WHOAMI  * @Date: 2019/6/8 22:24   */    private static BufferedImage change(File file){        // 读取图片字节数组        BufferedImage textImage = null;        try{            InputStream in = new FileInputStream(file);            BufferedImage image = ImageIO.read(in);            in.close();            textImage = ImageHelper.convertImageToGrayscale(ImageHelper.getSubImage(image, 0, 0, image.getWidth(), image.getHeight()));  //对图片进行处理            textImage = ImageHelper.getScaledInstance(image, image.getWidth() * 10, image.getHeight() * 10);  //将图片扩大5倍        }catch (IOException e) {            e.printStackTrace();        }        return textImage;    }</code></pre><blockquote><p>接着就是我们的核心代码了</p></blockquote><pre><code class="java">public static String deal(String pathname,String fileName){        //打开需要处理的图片        File imageFile = new File(pathname+&quot;\\&quot;+fileName);        try {          //去干扰线            cleanLinesInImage(imageFile,pathname);        } catch (IOException e) {            e.printStackTrace();        }        //开始图像识别        Tesseract instance = new Tesseract();          // 这是我的语言包的路径        instance.setDatapath(&quot;D:\\code\\java\\ChromeOperation\\tessdata&quot;);        instance.setLanguage(&quot;eng&quot;);//选择字库文件（只需要文件名，不需要后缀名）        //将验证码图片的内容识别为字符串        try {          // 打开处理后的图像            File image = new File(pathname+&quot;\\&quot;+fileName);            String result = instance.doOCR(change(image));          //利用正则表达式过滤掉非法字符            String correct = result.replaceAll(&quot;[^0-9a-zA-Z]J*&quot;,&quot;&quot;);            // 返回正确的字符串            return correct;        } catch (TesseractException e) {            e.printStackTrace();        }        return null;    }</code></pre><h3 id="重复验证"><a href="#重复验证" class="headerlink" title="重复验证"></a>重复验证</h3><p>由于上面的代码并不理想，所以我打算利用死循环直到他输入正确为止，代码如下：</p><pre><code class="java">          while(ifAlert(driver)){               driver.findElement(By.xpath(&quot;//div[@id=&#39;alert_box&#39;]/div[2]/div[2]/div[2]&quot;)).click();               dealImg(driver);           }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> selenium </tag>
            
            <tag> 自动化 </tag>
            
            <tag> orc </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义注解</title>
      <link href="/2019/06/04/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/06/04/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java自定义注解"><a href="#java自定义注解" class="headerlink" title="java自定义注解"></a>java自定义注解</h1><hr><p>这次的文章是我在上次文章的AOP文章遇到一个坑，通过joinPoint得到签名后，获得到他的注解为空，后来发现自己没有加相应的注解，这里记录此次的坑。</p><p>首先我们看一下正确的注释代码</p><pre><code class="java">@Target(ElementType.METHOD)@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Cache {    boolean ifDelete() default false;}</code></pre><p>上次我们的文章的中本来是没有@Target等注解的，但是后来发现，这几个注解的作用是非常大的。</p><h2 id="每个注解的作用"><a href="#每个注解的作用" class="headerlink" title="每个注解的作用"></a>每个注解的作用</h2><p><strong>@Documented</strong></p><p>这个注解的作用就是，在生成javadoc文档的时候，将用过这个这个注解的方法的文档里面也写上这个注解。</p><p><strong>@Retention(Retention.RUNTIME)</strong></p><p>这个注解的作用在我看来就是在编译java代码的时候将这个注解也加上，也就是为什么不加这个注解，我们利用getAnnotation()这个方法等到的注解为null了。</p><p><strong>Target()</strong></p><p>这个注解是我们这个注解是为谁服务的，比如我们上面写的ElementType.METHOD,就是决定我们是为了方法服务的，如果写在类上面，这个注解会失效。</p><p>ElementType后面还有其他类别:</p><ul><li>ANNOTATION_TYPE 注解类型声明</li><li>CONSTRUCTOR 构造方法声明</li><li>FIELD 字段声明（包括枚举常量）</li><li>LOCAL_VARIABLE 局部变量声明</li><li>METHOD 方法声明</li><li>PACKAGE 包声明</li><li>PARAMETER 参数声明</li><li>TYPE 类、接口（包括注解类型）或枚举声明</li><li>TYPE_PARAMETER @since 1.8</li><li>TYPE_USE @since 1.8</li></ul><p><strong>@Inherited</strong><br>这个注解表示，打上这个注解之后，这个类如果被其他类继承后，子类会自动打上这个注解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中aop的尝试</title>
      <link href="/2019/06/03/springboot%E4%B8%ADaop%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
      <url>/2019/06/03/springboot%E4%B8%ADaop%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot中对AOP技术的了解和使用"><a href="#springboot中对AOP技术的了解和使用" class="headerlink" title="springboot中对AOP技术的了解和使用"></a>springboot中对AOP技术的了解和使用</h1><p>我们在项目中如果使用spring的框架的话，aop技术多多少少也接触过，所以打算在这里总结一下AOP的技术核心和常用方法。</p><a id="more"></a><h2 id="AOP的基本使用方法-–-gt-全局AOP监听"><a href="#AOP的基本使用方法-–-gt-全局AOP监听" class="headerlink" title="AOP的基本使用方法 –&gt; 全局AOP监听"></a>AOP的基本使用方法 –&gt; 全局AOP监听</h2><p>我们现在要在Controller层做一个监听，每次进入controller的方法的时候，都启动AOP进行方法检查等操作。</p><p>接下来我们看一下源代码：</p><p>Controller层：</p><pre><code class="java">@RestControllerpublic class PageController {  //这个类在com.demo.controller包下@RequestMapping(&quot;/hello&quot;)   public Map&lt;String,String&gt; helloWorld(){       Map&lt;String,String &gt; map = new HashMap&lt;&gt;();       System.out.println(&quot;代码执行中&quot;);       map.put(&quot;hello&quot;,&quot;world&quot;);       System.out.println(&quot;继续执行&quot;);       return map;   }}</code></pre><p>AOP：</p><pre><code class="java">/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/6/2 16:06 * Description: ://TODO ${END} */@Slf4j@Aspect@Componentpublic class WebLogAspect { @Pointcut(&quot;execution(public * com.demo.controller.*.*(..))&quot;)    private void weblog(){}    @Before(&quot;weblog()&quot;)    private void doBefore(JoinPoint joinPoint) throws Throwable {        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        log.info(&quot;URL: &quot;+request.getRequestURL().toString());        log.info(&quot;Method&quot; + request.getMethod());        log.info(&quot;HTTP_METHOD: &quot;+request.getMethod());        log.info(&quot;IP: &quot;+request.getRemoteAddr());        Enumeration&lt;String&gt; enu = request.getParameterNames();        while (enu.hasMoreElements()) {            String name = enu.nextElement();            log.info(&quot;name:{},value:{}&quot;, name, request.getParameter(name));        }    }    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;weblog()&quot;)    public void doAfterReturning(Object ret) throws Throwable {        log.info(&quot;RESPONSE: &quot; + ret);    }}</code></pre><ul><li>下面讲解一下这个AOP的常用技术</li></ul><p><strong>@Aspect</strong><br>标记这是一个切面，如果没有这个注解，那么这个方法不启动</p><p><strong>Pointcut</strong><br>切点，后面的execution是决定监听哪里的方法</p><p><strong>Befoe</strong><br>前置通知</p><p><strong>After</strong><br>后置通知</p><h2 id="下面是我常用的AOP方法"><a href="#下面是我常用的AOP方法" class="headerlink" title="下面是我常用的AOP方法"></a>下面是我常用的AOP方法</h2><p>利用自定义注解决定切点</p><p>下面我们自定义一个注解</p><pre><code class="java">@Target(ElementType.METHOD)@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Cache {  boolean ifDelete() default false;}</code></pre><p>在我们的Controller层方法上加入这个注解</p><pre><code class="java">@RequestMapping(&quot;/hello&quot;)   @Cache(ifDelete = true)   public Map&lt;String,String&gt; helloWorld(){       Map&lt;String,String &gt; map = new HashMap&lt;&gt;();       System.out.println(&quot;代码执行中&quot;);       map.put(&quot;hello&quot;,&quot;world&quot;);       System.out.println(&quot;继续执行&quot;);       return map;   }</code></pre><p>AOP层：</p><pre><code class="java">@Slf4j@Aspect@Componentpublic class TestAsp {    @Around(&quot;@annotation(com.demo.flag.Cache)&quot;)    public Object testJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {        System.out.println(&quot;进入aop&quot;);        return joinPoint.proceed();        System.out.println(&quot;代码执行aop后&quot;);    }}</code></pre><p>我们访问一下这个地址，结果是这个样子的</p><pre><code class="bash">&gt;进入aop&gt;代码执行中&gt;继续执行&gt;代码执行aop后</code></pre><p>这里不需要PointCut，而是利用@annotation将所有有上面这个注解的方法都会进入这个AOP方法。</p><p>其实这个@Around是一个环绕通知，你可以在这里通过jionPoint获得到访问者IP，变量参数等等。</p><p>这个joinPoint.proceed()方法是让controller方法的必要条件。</p><p>joinPoint.proceed()方法后的代码是处理完方法后需要执行的代码，这样就可以想象成这个Around将controller层的某个方法’包裹’起来了。</p><h2 id="JoinPoint的常用方法"><a href="#JoinPoint的常用方法" class="headerlink" title="JoinPoint的常用方法"></a>JoinPoint的常用方法</h2><ul><li><p>获取到方法的注解</p><pre><code class="java">MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();      Cache annotation = methodSignature.getMethod().getAnnotation(Cache.class);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8中Optional的使用</title>
      <link href="/2019/06/02/java8%E4%B8%ADOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/02/java8%E4%B8%ADOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java8中Optional的使用"><a href="#java8中Optional的使用" class="headerlink" title="java8中Optional的使用"></a>java8中Optional的使用</h1><hr><p>我们在之前的业务开发中，有时候会遇到搜查结果为空的情况，但是返回Null的时候，我们就必须要判断一下是否为null,如果是的话要么throw一个异常或者别的什么操作，例如账号登陆失败的时候。</p><p>这样显得代码非常臃肿，而java8得Optional完美解决了这个问题(主要是空指针问题)。</p><h2 id="创建一个Optional实例"><a href="#创建一个Optional实例" class="headerlink" title="创建一个Optional实例"></a>创建一个Optional实例</h2><pre><code class="java">Optional&lt;String&gt; name2 = Optional.empty();Optional&lt;String&gt; name = Optional.ofNullable(null);Optional&lt;String&gt; name3 = Optional.of(&quot;111&quot;);</code></pre><p>这三个其实区别就是 第一个只是创建一个Optional实例，相当于Null。第二个允许传入一个Null的对象，如果用第三个Optional.of(null)的话，直接会爆出空指针异常。</p><h2 id="获取Optional的值"><a href="#获取Optional的值" class="headerlink" title="获取Optional的值"></a>获取Optional的值</h2><pre><code class="java">User user = new User(&quot;john@gmail.com&quot;,&quot;1234&quot;);User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);User result = Optional.ofNullable(user).orElse(new User);User result2 = Optional.of(user).orElseGet(() -&gt; new User);User result3 = Optional.ofNullable(user)                .orElseThrow(() -&gt; new RuntimeExcetion(&quot;运行出错了&quot;));User result4 = Optional.ofNullable(user).Get();</code></pre><p>下面来讲一下这几个方法的异同</p><p>orElse:有值就返回值，不管有没有值都会执行后面的操作(new 一个对象等等)，如果没有值才会返回结果。</p><p>orElseGet:有值就返回值，没有值才进行后面的表达式操作</p><blockquote><p>如果传入的值都是Null的情况下，两个函数没有区别，但是不是空的情况下，orElseGet显然效率比较高</p></blockquote><p>orElseThrow:有值就返回值,没有值抛用户定义的异常</p><p>Get:有值就返回值,没有值NoSuchElementException。</p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><p>如果对得到的Optional的函数不提前利用isPresent()函数判断里面是否有值的话，就Get函数，<strong>一定</strong>会爆出NoSuchElementException这个异常，不管里面是不是有值，对代码的逻辑产生一定的影响，所以最好还是先判断一下。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE基础知识点</title>
      <link href="/2019/05/24/javaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/05/24/javaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="javaSE基础知识点汇总"><a href="#javaSE基础知识点汇总" class="headerlink" title="javaSE基础知识点汇总"></a>javaSE基础知识点汇总</h1><hr><h2 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a>java数据类型</h2><p>八大基础数据类型： byte,char,short,int,long,float,double,boolean</p><blockquote><p>包装类型是类/对象，默认是Null,而int这种的基础数据类型默认为0(牛客中出现过)</p></blockquote><h2 id="String-详解"><a href="#String-详解" class="headerlink" title="String 详解"></a>String 详解</h2><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><pre><code class="java">A:{    String a = &quot;a&quot;;    String b = &quot;a&quot;;}B:{    String a = new String(&quot;a&quot;);    String b = new String(&quot;a&quot;);}</code></pre><p>上面两个代码块，有区别没？<br>答案肯定是有的，A代码块的执行原理是这样的</p><p>首先在自己线程的栈帧中生成一个引用型变量a,然后再到堆里面的常量池中寻找有没有a的对象，如果有就把地址直接转向那里，如果没有，新建；b也是同理。</p><blockquote><p>注意，java中只要是那种包装数据类型都是创建一个相当于指针的东西。</p></blockquote><p><strong>提示</strong>这个是包装数据类型，如果是char这种的呢？则是直接存在栈中</p><p>B代码块你就考虑只要是new，那肯定是直接再heap里面直接创建一个新的对象啦。</p><h2 id="java编译"><a href="#java编译" class="headerlink" title="java编译"></a>java编译</h2><p>java编译命令: javac xxx.java</p><p>编译后会生成class文件，生成的文件个数和源程序中类的<strong>个数一致</strong>。</p><h2 id="java值传递和引用传递"><a href="#java值传递和引用传递" class="headerlink" title="java值传递和引用传递"></a>java值传递和引用传递</h2><p>网上的教程大多都是参差不齐，这里整理一下我自己的思路。</p><p>值传递： 基本数据类型</p><p>引用传递： String等各种对象，数组。</p><h2 id="Java中Stream的使用"><a href="#Java中Stream的使用" class="headerlink" title="Java中Stream的使用"></a>Java中Stream的使用</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个我们肯定特别熟悉，遍历嘛。但是这里有一个注意的点，Collection包下面的集合都已经实现了forEach方法，也就是说，我们不需要将List对象先转换成stream对象，再用forEach方法</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map对象，他可以做一个对数据的处理，最后return出来的那个东西变成了一个steam流,举个例子</p><pre><code class="java">List&lt;User&gt; users; // 这里是个有好多数据的user列表，我们想吧里面的属性转出两个来怎么办？直接用map// 假设UserChange里面就一个id和name,其他的都删掉了 List&lt;UserChange&gt; lists = users.stream().map(item-&gt;{     xxxxx //去掉那些属性     return A; }).collect(Collections.toList());</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>这个是筛选出来符合filter里面条件的list，这里不举例了</p><h2 id="final关键字的理解"><a href="#final关键字的理解" class="headerlink" title="final关键字的理解"></a>final关键字的理解</h2><p>final如果赋给了变量，证明这个变量是不能修改的<br>但是，要注意，如果给数组附上了final关键字，他的数组元素是可以修改的</p><p>例如：</p><pre><code class="java">public static void main(String args[]){        final  int b[] = {5};        int a[] = {3};        b[0] = 2;        // b = a;  编译错误，因为是final类型        System.out.println(b[0]);    }</code></pre><h2 id="equals-和-之间的区别"><a href="#equals-和-之间的区别" class="headerlink" title="equals 和 == 之间的区别"></a>equals 和 == 之间的区别</h2><p>== 是直接比较地址，一般用来比较8大基本数据类型</p><p>equals则是一般由开发人员复写的，但是如果默认，则会比较他们的值是否一致，equals的源代码是：</p><pre><code class="java">public boolean equals(Object obj) {    return (this == obj);}</code></pre><blockquote><p>但是需要注意一点的是 java中对String的equals写法是这样的,他复写了原始的方法</p></blockquote><pre><code class="java">@Overridepublic boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = count;        if (n == anotherString.count) {            char v1[] = value;            char v2[] = anotherString.value;            int i = offset;            int j = anotherString.offset;            while (n-- != 0) {                if (v1[i++] != v2[j++])                    return false;            }            return true;        }    }    return false;}</code></pre><h2 id="Java-标记跳出外循环"><a href="#Java-标记跳出外循环" class="headerlink" title="Java 标记跳出外循环"></a>Java 标记跳出外循环</h2><pre><code class="java">public static void main(String[] args) {        int i,j;        A:for(i =0 ; i&lt;10;i++){            B:for(j = 0 ;j&lt;10;j++){                break A;            }        }    }</code></pre><p>标记如上文所示，在外层循环上面写上A标记，在内循环里面直接Break 标记，起到goto语句的作用。</p><h2 id="JAVA加载顺序"><a href="#JAVA加载顺序" class="headerlink" title="JAVA加载顺序"></a>JAVA加载顺序</h2><p>父类静态代码块&gt;&gt; 子类静态代码块&gt;&gt; 父类代码块&gt;&gt; 父类构造函数&gt;&gt; 子类代码块&gt;&gt; 子类构造函数</p><ul><li>可以利用反射机制Class.forName(“包名”)理解class的消息</li></ul><h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><p>finalize<br>finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p><p>两种常见的回收机制：</p><ol><li><p>定时回收<br>每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢</p></li><li><p>当垃圾占到某个百分比的时候，进行回收<br>比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。</p></li></ol><p>一般说来 JVM会采用两种机制结合的方式进行垃圾回收。</p><ul><li>java特殊的内存泄漏</li></ul><p>在下面的例子中，for创建的o 对象放入了 al里面，但是 很明显我们在之后就用不到o们了，如果al没有释放的话，这些对象会一直存在</p><pre><code class="java">public class MemoryLeak {    static ArrayList&lt;Object&gt; al = new ArrayList&lt;Object&gt;();    public static void main(String[] args) {        for (int i = 0; i &lt; 100; i++) {            Object o = new Object();            al.add(o);        }    }}</code></pre><h2 id="String-StringBuilder-StringBuffer之间的区别"><a href="#String-StringBuilder-StringBuffer之间的区别" class="headerlink" title="String,StringBuilder,StringBuffer之间的区别"></a>String,StringBuilder,StringBuffer之间的区别</h2><p>String要注意他是一个final，也就是说不可继承的一个常量。</p><p>String Builder线程不安全，但是效率高</p><p>String buffer 线程安全，效率低</p><h2 id="Vector-ArrayList之间的区别"><a href="#Vector-ArrayList之间的区别" class="headerlink" title="Vector,ArrayList之间的区别"></a>Vector,ArrayList之间的区别</h2><ul><li>共同点： vector和arraylist创建一个固定大小的空间</li><li>不同点： </li></ul><p>Vector线程安全,arrayList不安全；每次容量满了之后,arrayList容量扩张50%,Vector扩张一倍。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io知识点整理</title>
      <link href="/2019/05/23/java-io%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2019/05/23/java-io%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="java-io-流的一些知识点整理"><a href="#java-io-流的一些知识点整理" class="headerlink" title="java io 流的一些知识点整理"></a>java io 流的一些知识点整理</h1><hr><h2 id="java流类图总结"><a href="#java流类图总结" class="headerlink" title="java流类图总结"></a>java流类图总结</h2><p><img src="https://s2.ax1x.com/2019/05/23/VPsDmt.png" alt></p><a id="more"></a><h2 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h2><p>字节流(1byte 8bit)处理的是二进制文件，也就是说,二进制文件什么也能处理，比如文字和图片视频什么的。<br>而字符流(1char,2byte,16bit)则只能处理文本类型，但是它可以处理编码问题，例如我们的字节流读取出来的文件是乱码的，就是因为文件的编码问题。</p><blockquote><p>下面是一个读取中文文本的样例。</p></blockquote><pre><code class="java">public static void main(String args[]){        int b; //这里的默认值是0        try {          //这里的f变量是为了后面建立char[]数组读取文件大小            File f = new File(&quot;D:\\\\test.txt&quot;);            //创建字符流            InputStreamReader isr = new InputStreamReader(new FileInputStream(f),&quot;GBK&quot;);            //建立buf ,注意，如果文件中有中文的话，这里的buf里面会多建立空间，因为中文占两个字节空间            char[] buf = new char[(int) f.length()];            int len = isr.read(buf);            String rs = new String(buf,0,len);            isr.close();        }        catch (Exception e) {            System.out.println(&quot;出错了，原因是：&quot;);            System.out.println (e.toString());        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html自适应界面</title>
      <link href="/2019/05/19/html%E8%87%AA%E9%80%82%E5%BA%94%E7%95%8C%E9%9D%A2/"/>
      <url>/2019/05/19/html%E8%87%AA%E9%80%82%E5%BA%94%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="html自适应界面"><a href="#html自适应界面" class="headerlink" title="html自适应界面"></a>html自适应界面</h1><hr><p>学习过bootStarp之后，一直最自适应布局很感兴趣，尤其是BootStarp的栅格系统，所以做了一个html小demo，来记录一下自适应的过程</p><h2 id="重要的css属性-弹性盒子"><a href="#重要的css属性-弹性盒子" class="headerlink" title="重要的css属性 弹性盒子"></a>重要的css属性 弹性盒子</h2><ul><li>display:flex;</li><li>flex-wrap:wrap;</li><li>justify-content:center;</li></ul><p>接下来看一段代码</p><pre><code class="html">&lt;!-- html --&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;service-box&quot;&gt;      &lt;div class=&quot;service-icon&quot;&gt;          &lt;i class=&quot;fa fa-window-restore&quot;&gt;&lt;/i&gt;        &lt;/div&gt;      &lt;div class=&quot;service-title&quot;&gt;          &lt;span&gt;网站商品管理&lt;/span&gt;      &lt;/div&gt;      &lt;div class=&quot;service-desc&quot;&gt;          &lt;span&gt;这是管理网站所有商品功能，在这里可以管理用户上架的所有商品&lt;/span&gt;      &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;!-- css --&gt;&lt;style&gt;.container{  display: flex;  flex-wrap: wrap;  justify-content: center;}.service-box{  max-width: 33.33%;  padding: 10px;  text-align: center;  cursor: pointer;}&lt;/style&gt;</code></pre><p>这是没有加弹性盒子的效果<br><img src="https://s2.ax1x.com/2019/05/19/EjiQln.png" alt></p><p>这是加了弹性盒子的效果 [注意:这里截图的时候屏幕尺寸小于960px]<br><img src="https://s2.ax1x.com/2019/05/19/EjiiQI.png" alt></p><p><strong>分析原因</strong><br>在我看来,这个弹性盒子其实就是让子类可以像是block一样排列起来,并且子类的max-width的百分比决定着他们一排能排几个</p><h2 id="重要的属性-media-and-screen-max-width-960px"><a href="#重要的属性-media-and-screen-max-width-960px" class="headerlink" title="重要的属性 @media and screen(max-width:960px)"></a>重要的属性 @media and screen(max-width:960px)</h2><p>这个语句的意思是 如果屏幕尺寸小于960px那么就执行下面的代码</p><blockquote><p>这个语句由一个前提,那就是这一定是个html:5文件</p></blockquote><pre><code class="html">&lt;!-- html5 必须的属性 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></pre><p>下面看一下实例</p><p>承接上面的css代码</p><pre><code class="css">@media screen and (max-width:960px) {  .service-box{    max-width: 45%;  }}</code></pre><p>因为盒子最大是占据45%,也就是一行只能两行,就能看到上面的图的情况,正常来说,如果用电脑打开那个网页的话,一行会出现三个盒子的</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自适应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ps改变图片特定颜色</title>
      <link href="/2019/05/18/ps%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%89%B9%E5%AE%9A%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/05/18/ps%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%89%B9%E5%AE%9A%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="ps改变图片特定颜色"><a href="#ps改变图片特定颜色" class="headerlink" title="ps改变图片特定颜色"></a>ps改变图片特定颜色</h1><hr><blockquote><p>首先我们看一下我们的原图片，对没错是看门狗的图片</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/18/EOM6B9.jpg" alt></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>现在我们需要吧这个图片修改一下：</p><ul><li>删除图片上面的白边</li><li>将背景色换成透明</li><li>将中间白色logo变成黑色</li><li>改变图片分辨率为200*200</li></ul><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><ol><li>打开ps后Ctrl+j 复制图层，将背景预览关掉</li><li>删除白边的话，这里不再叙述</li><li>由于我们这张图片色差明显，所以我们采用魔棒工具，将背景点选，然后Del删除，现在情况是这样的<br> <img src="https://s2.ax1x.com/2019/05/18/EOMxgS.png" alt></li><li>现在我们需要将图片上的黑色变成别的颜色作为一个temp,之后将白色主体部分变成黑色之后，可以将temp部分变成黑色或者其他颜色</li><li>选择菜单栏 –&gt; 选择 –&gt; 色彩范围 弹出色彩范围的框里面按下图操作<br> <img src="https://s2.ax1x.com/2019/05/18/EOQiEn.png" alt><br> 选择黑色部分，然后确定，之后图片会将那些图片框住</li><li>按ctrl+ u 弹出色相和饱和度框 勾选着色 选择合适的颜色后确认<br> <img src="https://s2.ax1x.com/2019/05/18/EOQ14x.png" alt></li><li>重复上面操作将白色主体部分变成黑色<br><img src="https://s2.ax1x.com/2019/05/18/EOQNKe.png" alt></li><li>选择菜单 -&gt; 图像 -&gt; 图像大小 改变宽度和高度</li><li>导出图片 完工！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Photoshop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photoshop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 利用触发器来实现check约束</title>
      <link href="/2019/05/17/mysql-%E5%88%A9%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0check%E7%BA%A6%E6%9D%9F/"/>
      <url>/2019/05/17/mysql-%E5%88%A9%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0check%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-利用触发器来实现check约束"><a href="#mysql-利用触发器来实现check约束" class="headerlink" title="mysql 利用触发器来实现check约束"></a>mysql 利用触发器来实现check约束</h1><hr><p>由于我用的是mysql5.6.34版本，所以据我的了解来看，mysql对于check约束还是一个摆设。</p><p>但是我们可以利用触发器(trigger)来实现一种类check约束</p><p>下面我们来一个实例：</p><hr><p>我们需要创建一个学生表 sno 主键，sage 年龄在16-20之内</p><p>这个sage就是一个check约束</p><p>首先我们创建我们的studen表</p><pre><code>CREATE TABLE Student (    Sno VARCHAR(3) PRIMARY KEY,    Sage INT ,)ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><p>接着我们创建触发器</p><pre><code># 这个是在插入insert之前触发 指定是在student表CREATE TRIGGER test_student_insert_check BEFORE INSERTON Student FOR EACH ROWBEGIN    DECLARE msg varchar(100);    IF NEW.Sage &lt;= 16 OR NEW.Sage &gt;= 20     THEN        SET msg = CONCAT(&#39;无效的年龄!&#39;);        SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT = msg;    END IF;END;</code></pre><blockquote><p>注意，虽然这样可以做到check的效果，但是还是非常不建议用触发器，因为太慢了，所以我们最好还是在插入之前判断，例如spring的service层。</p></blockquote><blockquote><p>而且，这个插入只是管理insert插入的，更新的话还是不会拦截的，而且我们又不可能在创建一个update触发器，太浪费资源，所以这个博文只是一种思想，并不实用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql使用心得</title>
      <link href="/2019/05/13/mysql%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2019/05/13/mysql%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql使用心得"><a href="#mysql使用心得" class="headerlink" title="mysql使用心得"></a>mysql使用心得</h1><ul><li>对于那种datetime属性的默认值 可以写CURRENT_TIMESTAMP，来填充当前时间。</li></ul><h2 id="对于Join连接的经验"><a href="#对于Join连接的经验" class="headerlink" title="对于Join连接的经验"></a>对于Join连接的经验</h2><p>首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。</p><p>左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。</p><p>外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。</p><p>下面的图：<br><a href="https://imgchr.com/i/rO59w6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/30/rO59w6.png" alt="rO59w6.png"></a></p><blockquote><p>在使用JOIN语句的时候，肯定会用到 ON关键字，这个字段的意思是 将两个表合成一张表的条件，而有的时候又会使用到where关键字，这个关键字则是在组合成临时表之后的筛选。</p></blockquote><pre><code class="sql">SELECT column_name(s)FROM table1LEFT OUTER JOIN table2ON table1.column_name=table2.column_name;</code></pre><p>这里面 的ON关键字就是用来变成一张临时表的条件.</p><h2 id="UNION语句"><a href="#UNION语句" class="headerlink" title="UNION语句"></a>UNION语句</h2><p>首先说一下区别，JOIN使用起来是将结果扩充表的列，相当于纵向；而UNION使用起来必须保证SELECT出来的表结构都是一样的，最后将两个表的结果纵向连接在一起。</p><ul><li><p>UNION 中有去重操作是UNION ALL 和SELECT DISNCT差不多。</p></li><li><p>UNION 中如果使用ORDER BY 字段 必须在<strong>最后一张</strong>表中使用。</p></li></ul><p>、</p><h2 id="日期判断"><a href="#日期判断" class="headerlink" title="日期判断"></a>日期判断</h2><p>有的时候我们会有这样的需求，我们需要查询出最近几天的数据，或者说据当前大于一天的数据。<br>上面两条是两种意思<br>第一条的意思是，今天和昨天算是两天，具体的SQL语句是这样的</p><pre><code class="sql">DATEDIFF(NOW(),&#39;2021-04-20 11:09:00&#39;)</code></pre><p>上面的语句表示的是，现在和2021-04-20距离多少天</p><blockquote><p>注意，如果现在是2021-04-21 0:0:1 也算是1天</p></blockquote><p>第二条是距离现在大于24小时才算是不同天</p><p>具体语句如下：</p><pre><code class="sql">DATE_SUB(CURDATE(),INTERVAL 1 day) &lt;= &#39;2021-04-20 11:09:00&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb做读写分离</title>
      <link href="/2019/05/13/mariadb%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2019/05/13/mariadb%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="mariadb读写分离"><a href="#mariadb读写分离" class="headerlink" title="mariadb读写分离"></a>mariadb读写分离</h1><p>上一次文章我在centos7上安装了mariadb并开启了主从复制模式，这一篇打算利用mycat做读写分离</p><p>mycat现在可以相称像是nginx一样的反向代理，他可以不暴露数据库的ip</p><p>环境：</p><table><thead><tr><th>IP地址</th><th>作用</th></tr></thead><tbody><tr><td>192.168.3.137</td><td>mycat服务器，主数据库</td></tr><tr><td>192.168.3.136</td><td>从数据库</td></tr></tbody></table><h2 id="安装mycat"><a href="#安装mycat" class="headerlink" title="安装mycat"></a>安装mycat</h2><hr><ul><li><p>打开mycat<a href="http://www.mycat.io/" target="_blank" rel="noopener">官网</a>,选择版本下载，我这里是1.6.6</p></li><li><p>将tar包解压到centos下的/usr/local/下</p></li></ul><pre><code>添加环境变量vi /etc/profileexport MYCAT_HOME=/usr/local/mycat# 退出source /etc/profile #使之生效cd /usr/local/mycat/bin./mycat start #启动./mycat status #查看是否启动</code></pre><p><img src="https://s2.ax1x.com/2019/05/13/E4b7VA.png" alt></p><p>一般没什么问题</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><hr><p>首先备份一下两个重要文件，如果弄坏了还可以还原</p><pre><code>cd /usr/local/mycat/confcp ./server.xml ./server.xml.bakcp ./schema.xml ./schema.xml.bak</code></pre><p>配置用户供远程登陆 <strong>server.xml</strong></p><pre><code>vi /usr/local/conf/server.xml </code></pre><p><img src="https://s2.ax1x.com/2019/05/13/E4qP5q.png" alt></p><p>拉到最后，修改里面的用户就行了</p><p>配置需要管理的表 <strong>schema.xml</strong></p><p><img src="https://s2.ax1x.com/2019/05/13/E4LkTA.png" alt></p><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><hr><p>重启一下mycat,查看一下状态是否运行</p><pre><code>./mycat restart./mycat status</code></pre><p>打开window上的navicat 选择连接 注意 这里一定是mysql 不然会报错</p><blockquote><p>注意 mycat的默认端口是8066</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/13/E4Llwj.png" alt></p><p>交易成功！</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7 安装mariadb 并配置主从复制</title>
      <link href="/2019/05/12/centos7%E4%B8%8B%E5%AE%89%E8%A3%85mariadb%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/12/centos7%E4%B8%8B%E5%AE%89%E8%A3%85mariadb%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7下安装mariadb"><a href="#centos7下安装mariadb" class="headerlink" title="centos7下安装mariadb"></a>centos7下安装mariadb</h1><h2 id="卸载已经存在的mariadb"><a href="#卸载已经存在的mariadb" class="headerlink" title="卸载已经存在的mariadb"></a>卸载已经存在的mariadb</h2><hr><p>检查是否已经安装mariadb</p><pre><code>rpm -qa|grep mariadb</code></pre><p>如果存在先卸载掉</p><pre><code>rpm -e --nodeps xxxx</code></pre><a id="more"></a><h2 id="安装mariadb"><a href="#安装mariadb" class="headerlink" title="安装mariadb"></a>安装mariadb</h2><hr><pre><code>yum -y install mariadb mariadb-server #安装systemctl start mariadb # 启动mariadb服务systemctl enable mariadb #设置开机启动</code></pre><h2 id="mariadb简单配置"><a href="#mariadb简单配置" class="headerlink" title="mariadb简单配置"></a>mariadb简单配置</h2><pre><code>mysql_secure_installation #开始简单配置首先是设置密码，会提示输入密码Enter current password for root (enter for none):  --&gt;初次设置直接回车Set root password? [Y/n] --&gt;yNew password:Re-enter new password:其他设置Remove anonymous users? [Y/n] --&gt;是否删除匿名用户 回车Disallow root login remotely? [Y/n] --&gt;是否禁止远程用户 nRemove test database and access to it? [Y/n] --&gt;删除test数据库 回车Reload privilege tables now? [Y/n]  --&gt;是否重新加载权限表 回车</code></pre><h2 id="配置mariadb编码"><a href="#配置mariadb编码" class="headerlink" title="配置mariadb编码"></a>配置mariadb编码</h2><pre><code>vi /etc/my.cnf#在[mysqld]下面添加init_connect=&#39;SET collation_connection = utf_unicode_ci&#39;init_connect=&#39;SET NAMES utf8&#39;character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakevi etc/my.cnf.d/clent.cnf# 在[client]下添加default-character-set=utf8vi etc/my.cnf.d/mysql-clients.cnf#在[mysqld]下添加default-character-set=utf8</code></pre><pre><code>配置完成 重启服务systemctl restart mariadb查看mariadb字符集show variables like &quot;%character%&#39;;show variables like &quot;%collation%&quot;;</code></pre><h2 id="添加外网用户"><a href="#添加外网用户" class="headerlink" title="添加外网用户"></a>添加外网用户</h2><hr><pre><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;123&#39; WITH GRANT OPTION; #配置用户并授权flush privileges; #刷新权限</code></pre><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><pre><code>vi /etc/my.conf# 添加下面两个字段server-id=137 #这个数字随便写log-bin=master-log #我尝试过放到另一个文件夹下，但是由于权限问题，始终启动错误，现在这个二进制文件是在你配置的datadir下面的innodb_file_per_table=on  #跳过主机名解析。在CentOS 6自带的mysql后面的=on不用写skip_name_resolve=on #innodb的每个表是用单独的文件</code></pre><p>启动服务</p><pre><code>systemctl start mariadb      #启动数据库GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO &#39;guest&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;; #创建从服务器用来连接的账号FLUSH PRIVILEGES; #刷新服务器</code></pre><p>查询当前日志情况</p><pre><code>show master status;</code></pre><p>这两个参数供从服务器连接并复制</p><p><img src="https://s2.ax1x.com/2019/05/12/E4phUe.png" alt></p><h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><pre><code>server_id=2relay_log=relay-log         #启用中继日志。在数据目录下有一个relay-kog.info里面保存了当前的中继日志和位置会主节点二进制文件的名字和位置。read_only=on                #禁止用户写入数据，这一项的管理员和复制重放无效。</code></pre><p>启动服务</p><pre><code>mysql&gt; FLUSH TABLES WITH READ LOCK;     #添加全局读锁,只允许读mysql&gt; reset slave;mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.3.137&#39;,MASTER_USER=&#39;guest&#39;,MASTER_PASSWORD=&#39;123&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; #远程连接，将上文查出来的日志文件和位置填写在上面mysql&gt; START SLAVE; #开始线程</code></pre><pre><code>#查询启动情况mysql&gt; SHOW SLAVE STATUS\G;</code></pre><p><img src="https://s2.ax1x.com/2019/05/12/E4p7vt.png" alt></p><blockquote><p>启动成功!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型初窥探</title>
      <link href="/2019/05/12/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/05/12/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java内存模型初探"><a href="#java内存模型初探" class="headerlink" title="java内存模型初探"></a>java内存模型初探</h1><p>jdk1.8以前的内存模型是这样的，</p><p><img src="https://s2.ax1x.com/2019/05/12/EhEDxJ.png" alt></p><p>下面我分析一下他们的作用</p><a id="more"></a><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也叫永久区，一些类的信息：方法名 返回值什么的，常量，静态变量都放在里面，class文件加载</p><p>这是是线程共享的 她其实是放在堆中的永久代中的，但是这个永久代又和堆是隔离的</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="https://s2.ax1x.com/2019/05/12/EhELIf.png" alt></p><p>堆中存放的是new的对象，是jVM中最大的空间</p><p>这个是线程共享的</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="https://s2.ax1x.com/2019/05/12/EhVpss.png" alt></p><p>这个是线程私有的 就是说，一个线程开一个虚拟机栈</p><p>我的理解是每当一个java方法运行的时候，就在当前的虚拟机栈压入一个新的栈帧，运行完之后，出栈</p><h2 id="本地虚拟栈"><a href="#本地虚拟栈" class="headerlink" title="本地虚拟栈"></a>本地虚拟栈</h2><p>本地虚拟栈和虚拟机栈差不多，但是他是为native服务的，我的理解是native是为别的语言服务的，比如java的底层C</p><p>当然也是线程私有</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>我的理解是字节码去执行代码的时候，程序计数器来告诉他们下一句代码是什么，当然也是私有的，每个线程一个程序计数器，来记录代码执行到哪里了。</p><h1 id="jdk1-8后的改版"><a href="#jdk1-8后的改版" class="headerlink" title="jdk1.8后的改版"></a>jdk1.8后的改版</h1><p><img src="https://s2.ax1x.com/2019/05/12/EhQaIs.png" alt></p><p>jdk1.8之后将方法区(永久区)去掉，变成了元数据区。他并没有在堆里面，而是直接在本地内存中。</p><p>堆也变成了这样</p><p><img src="https://s2.ax1x.com/2019/05/12/EhQysU.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的一些常用编程思想</title>
      <link href="/2019/05/09/java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
      <url>/2019/05/09/java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一个文章单纯的是常见的一些编程思想的总结</p></blockquote><a id="more"></a><h1 id="java的一些常用编程思想"><a href="#java的一些常用编程思想" class="headerlink" title="java的一些常用编程思想"></a>java的一些常用编程思想</h1><h2 id="让一个变量重复的-非零即一"><a href="#让一个变量重复的-非零即一" class="headerlink" title="让一个变量重复的 非零即一"></a>让一个变量重复的 非零即一</h2><pre><code class="java">int test = 1;test = test % 2;</code></pre><h2 id="取三个数中间值"><a href="#取三个数中间值" class="headerlink" title="取三个数中间值"></a>取三个数中间值</h2><pre><code class="java">if ((b - a) * (a - c) &gt;= 0) { //如果a是中间数的话 b-a 和 a-c一定是相反数            return a;} else if ((a - b) * (b - c) &gt;= 0) {        return b;} else {        return c;}</code></pre><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><pre><code class="java">//加入一个队列rear有固定的空间，我现在让他循环存储可以用取模算法rear = (rear +1)%MAX</code></pre><h2 id="数据库分表"><a href="#数据库分表" class="headerlink" title="数据库分表"></a>数据库分表</h2><p>假如现在有非常多数据，需要让他们放到不同的表中，可以用到取模算法</p><p>比如  我们有三个表， 在我们知道需要插入的具体id的时候，id%3就是他要存的表。</p><h2 id="判断是否是奇数"><a href="#判断是否是奇数" class="headerlink" title="判断是否是奇数"></a>判断是否是奇数</h2><p>我们通常用的是取模算法，但是还有一种是位与算法</p><pre><code class="java">if(n&amp;1 == 1){    //n就是奇数}</code></pre><h2 id="优雅的将注解和属性值结合起来"><a href="#优雅的将注解和属性值结合起来" class="headerlink" title="优雅的将注解和属性值结合起来"></a>优雅的将注解和属性值结合起来</h2><p>当我们的注解写在我们的属性上面时，如何和实体类的属性一一映射着实是一个比较头疼的问题。<br>这里只提供一种思想去解决，不一定是最好的，但往往很有效。</p><p>首先利用我们的Class.getDeclaredFields将我们的所有Field取出来，然后分别获取它们的注解。然后我们将Field.name()也就是我们的属性名和注解的值关联一下，比如放在同一个实体类里面。最后通过属性名获取到我们的get函数，最后通过代理获取get函数的值,最后做到关联。</p><blockquote><p>需要注意的是，通过反射或者代理获得到的值都是Object值，如何获取到我们get方法里面的类型，这里博主还没有考虑到。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt TCP UDP-多线程笔记</title>
      <link href="/2019/05/08/qt-TCP-UDP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/08/qt-TCP-UDP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="qt-TCP-UDP-多线程解决并发思路"><a href="#qt-TCP-UDP-多线程解决并发思路" class="headerlink" title="qt TCP UDP 多线程解决并发思路"></a>qt TCP UDP 多线程解决并发思路</h1><h2 id="TCP解决思路"><a href="#TCP解决思路" class="headerlink" title="TCP解决思路"></a>TCP解决思路</h2><hr><p>目的：每一个客户端连接都需要QTCPSocket开辟一条新的线程</p><p>解决方法：</p><ol><li><p>分别继承QTCPServer和QTCPSocket来分别实现Server和Socket（我这里是mTCPServer继承QTCPServer,mTCPSoket继承QTCPSokcet）</p></li><li><p>mTCPServer重写incomingConnection来实现socket的自动连接，其实就是不需要connect等待连接，直接进入函数</p><pre><code class="c++">protected: void incomingConnection(qintptr handle);</code></pre><p><img src="https://s2.ax1x.com/2019/05/09/Ecyj3Q.png" alt></p></li><li>重写incomingConnection()函数</li></ol><pre><code class="c++">void MyTcpServer::incomingConnection( qint32 socketDescriptor){    qDebug()&lt;&lt;tr(&quot;有新的连接 :-socketDescriptor-&quot;)&lt;&lt;socketDescriptor;    emit displayAccount(true); //这里是我给主界面发信号,有用户连接    MyTcpSocket *tcptemp = new MyTcpSocket(socketDescriptor);    //初始化线程    QThread *thread = new QThread(tcptemp);    //收到客户端发送的信息    connect(tcptemp,&amp;MyTcpSocket::receiveData,this,&amp;MyTcpServer::receiveDataSlot);    //客户端断开链接    connect(tcptemp,&amp;MyTcpSocket::socketDisconnect,this,&amp;MyTcpServer::disconnectSlot);    //客户端断开链接 关闭线程    connect(tcptemp,&amp;MyTcpSocket::disconnected,thread,&amp;QThread::quit);    //向socket发送信息    // 发送注册信息    connect(this,&amp;MyTcpServer::sendRegisterData,tcptemp,&amp;MyTcpSocket::sendRegisterData);    //将socket移动到子线程运行    tcptemp-&gt;moveToThread(thread);    thread-&gt;start();    //将Qthread放到Map控制    clients-&gt;insert(socketDescriptor,tcptemp);    qDebug()&lt;&lt;tr(&quot;目前客户端数量：&quot;)&lt;&lt;clients-&gt;size();}</code></pre><ol start="4"><li>mTCPSokcet解决相应的信号即可</li></ol><h2 id="多线程UDP解决思路"><a href="#多线程UDP解决思路" class="headerlink" title="多线程UDP解决思路"></a>多线程UDP解决思路</h2><hr><p>UDP的话就比较简单了,最核心的代码是这个</p><pre><code class="c++">/** * function:监听端口 * @brief MyUDPServer::startService */void MyUDPServer::startService(){    //这里监听端口    this-&gt;mUdpSocket = new QUdpSocket(this);    int error =this-&gt;mUdpSocket-&gt;bind(QHostAddress::Any,9999);    qDebug()&lt;&lt;error;    QObject::connect(mUdpSocket,SIGNAL(readyRead()),this,SLOT(readData()));}MyUDPServer::MyUDPServer(QObject *parent):QObject(parent){}/** * function: 多线程读取数据 * @brief MyUDPServer::readData */void MyUDPServer::readData(){    //获取到传来的数据    while(this-&gt;mUdpSocket-&gt;hasPendingDatagrams()){        //获取数据        QByteArray array;        QHostAddress address;        quint16 port;           //根据可读数据来设置空间大小        array.resize(this-&gt;mUdpSocket-&gt;pendingDatagramSize());        this-&gt;mUdpSocket-&gt;readDatagram(array.data(),array.size(),&amp;address,&amp;port); //读取数据        //创建线程        MsgAction *msgAction = new MsgAction(array,address,port);        QThread *thread = new QThread(msgAction);        //需要封装        qDebug()&lt;&lt;QThread::currentThread();        //移动到线程中        msgAction-&gt;moveToThread(thread);        thread-&gt;start();        msgAction-&gt;run();       //发送反馈数据    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> TCP UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装fastDFS</title>
      <link href="/2019/05/03/centos7%E5%AE%89%E8%A3%85fastDFS/"/>
      <url>/2019/05/03/centos7%E5%AE%89%E8%A3%85fastDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7安装fastDFS"><a href="#centos7安装fastDFS" class="headerlink" title="centos7安装fastDFS"></a>centos7安装fastDFS</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr><h3 id="使用的系统软件"><a href="#使用的系统软件" class="headerlink" title="使用的系统软件"></a>使用的系统软件</h3><hr><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>centos</td><td>7.x</td></tr><tr><td>libfatscommon</td><td>FastDFS分离出的一些公用函数包</td></tr><tr><td>FastDFS</td><td>FastDFS本体</td></tr><tr><td>fastdfs-nginx-module</td><td>FastDFS和nginx的关联模块</td></tr><tr><td>nginx</td><td>nginx1.15.4</td></tr></tbody></table><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><hr><pre><code>yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</code></pre><h3 id="磁盘目录"><a href="#磁盘目录" class="headerlink" title="磁盘目录"></a>磁盘目录</h3><hr><table><thead><tr><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>所有安装包</td><td>/usr/local/src</td></tr><tr><td>数据存储位置</td><td>/home/dfs/</td></tr><tr><td>#这里我为了方便把日志什么的都放到了dfs</td></tr></tbody></table><pre><code>mkdir /home/dfs #创建数据存储目录cd /usr/local/src #切换到安装目录准备下载安装包</code></pre><h3 id="安装libfatscommon"><a href="#安装libfatscommon" class="headerlink" title="安装libfatscommon"></a>安装libfatscommon</h3><hr><pre><code>git clone https://github.com/happyfish100/libfastcommon.git --depth 1cd libfastcommon/./make.sh &amp;&amp; ./make.sh install #编译安装</code></pre><h3 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h3><hr><pre><code>cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs.git --depth 1cd fastdfs/./make.sh &amp;&amp; ./make.sh install #编译安装#配置文件准备cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confcp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confcp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/ #供nginx访问使用cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/ #供nginx访问使用</code></pre><h3 id="安装fastdfs-nginx-module"><a href="#安装fastdfs-nginx-module" class="headerlink" title="安装fastdfs-nginx-module"></a>安装fastdfs-nginx-module</h3><hr><pre><code>cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs</code></pre><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><hr><pre><code>wget http://nginx.org/download/nginx-1.15.4.tar.gz #下载nginx压缩包tar -zxvf nginx-1.15.4.tar.gz #解压cd nginx-1.15.4/#添加fastdfs-nginx-module模块./configure --add-module=/usr/local/src/fastdfs-nginx-module/src/make &amp;&amp; make install #编译安装</code></pre><h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><hr><h3 id="tracker配置"><a href="#tracker配置" class="headerlink" title="tracker配置"></a>tracker配置</h3><hr><pre><code>#服务器ip为 192.168.52.1#我建议用ftp下载下来这些文件 本地修改vim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122  # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs  # 存储日志和数据的根目录</code></pre><h3 id="storage配置"><a href="#storage配置" class="headerlink" title="storage配置"></a>storage配置</h3><hr><pre><code>vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000  # storage服务端口（默认23000,一般不修改）base_path=/home/dfs  # 数据和日志文件存储根目录store_path0=/home/dfs  # 第一个存储目录tracker_server=192.168.52.1:22122  # tracker服务器IP和端口http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</code></pre><h3 id="client测试"><a href="#client测试" class="headerlink" title="client测试"></a>client测试</h3><hr><pre><code>vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/dfstracker_server=192.168.52.1:22122    #tracker服务器IP和端口#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz</code></pre><h3 id="配置nginx访问"><a href="#配置nginx访问" class="headerlink" title="配置nginx访问"></a>配置nginx访问</h3><hr><pre><code>vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.1:22122  #tracker服务器IP和端口url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server {    listen       8888;    ## 该端口为storage.conf中的http.server_port相同    server_name  localhost;    location ~/group[0-9]/ {        ngx_fastdfs_module;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {    root   html;    }}#测试下载，用外部浏览器访问刚才已传过的nginx安装包,引用返回的IDhttp://192.168.52.1:8888/group1/M00/00/00/wKgAQ1pysxmAaqhAAA76tz-dVgg.tar.gz#弹出下载单机部署全部跑通</code></pre><h2 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h2><hr><h3 id="tracker配置-1"><a href="#tracker配置-1" class="headerlink" title="tracker配置"></a>tracker配置</h3><hr><pre><code>#服务器ip为 192.168.52.2,192.168.52.3,192.168.52.4#我建议用ftp下载下来这些文件 本地修改vim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122  # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs  # 存储日志和数据的根目录</code></pre><h3 id="storage配置-1"><a href="#storage配置-1" class="headerlink" title="storage配置"></a>storage配置</h3><hr><pre><code>vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000  # storage服务端口（默认23000,一般不修改）base_path=/home/dfs  # 数据和日志文件存储根目录store_path0=/home/dfs  # 第一个存储目录tracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</code></pre><h3 id="client测试-1"><a href="#client测试-1" class="headerlink" title="client测试"></a>client测试</h3><hr><pre><code>vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/moe/dfstracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz</code></pre><h2 id="配置nginx访问-1"><a href="#配置nginx访问-1" class="headerlink" title="配置nginx访问"></a>配置nginx访问</h2><hr><pre><code>vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server {    listen       8888;    ## 该端口为storage.conf中的http.server_port相同    server_name  localhost;    location ~/group[0-9]/ {        ngx_fastdfs_module;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {    root   html;    }}</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><hr><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><hr><pre><code>#不关闭防火墙的话无法使用systemctl stop firewalld.service #关闭systemctl restart firewalld.service #重启</code></pre><h3 id="tracker"><a href="#tracker" class="headerlink" title="tracker"></a>tracker</h3><hr><pre><code>/etc/init.d/fdfs_trackerd start #启动tracker服务/etc/init.d/fdfs_trackerd restart #重启动tracker服务/etc/init.d/fdfs_trackerd stop #停止tracker服务chkconfig fdfs_trackerd on #自启动tracker服务</code></pre><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><hr><pre><code>/etc/init.d/fdfs_storaged start #启动storage服务/etc/init.d/fdfs_storaged restart #重动storage服务/etc/init.d/fdfs_storaged stop #停止动storage服务chkconfig fdfs_storaged on #自启动storage服务</code></pre><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><hr><pre><code>/usr/local/nginx/sbin/nginx #启动nginx/usr/local/nginx/sbin/nginx -s reload #重启nginx/usr/local/nginx/sbin/nginx -s stop #停止nginx</code></pre><h2 id="检测集群"><a href="#检测集群" class="headerlink" title="检测集群"></a>检测集群</h2><hr><pre><code>/usr/bin/fdfs_monitor /etc/fdfs/storage.conf# 会显示会有几台服务器 有3台就会 显示 Storage 1-Storage 3的详细信息</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr><pre><code>tracker_server #有几台服务器写几个group_name #地址的名称的命名bind_addr #服务器ip绑定store_path_count #store_path(数字)有几个写几个store_path(数字) #设置几个储存地址写几个 从0开始</code></pre><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><hr><pre><code>如果不是root 用户 你必须在除了cd的命令之外 全部加sudo如果不是root 用户 编译和安装分开进行 先编译再安装如果上传成功 但是nginx报错404 先检查mod_fastdfs.conf文件中的store_path0是否一致如果nginx无法访问 先检查防火墙 和 mod_fastdfs.conf文件tracker_server是否一致如果不是在/usr/local/src文件夹下安装 可能会编译出错</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> java </tag>
            
            <tag> 文件服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合详解</title>
      <link href="/2019/05/03/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/03/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java集合详解"><a href="#java集合详解" class="headerlink" title="java集合详解"></a>java集合详解</h1><blockquote><p>这里我们分析Collection和Map<br><a href="https://img-blog.csdn.net/20160124221843905" target="_blank" rel="noopener">大图查看详情</a></p></blockquote><h1 id="javaCollection的分析"><a href="#javaCollection的分析" class="headerlink" title="javaCollection的分析"></a>javaCollection的分析</h1><p>Collection是在java.util里面</p><p><a href="https://imgtu.com/i/gS5az4" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/26/gS5az4.jpg" alt="gS5az4.jpg"></a></p><blockquote><p>集合里面是一定是存放对象的，不能存放基本数据类型，像是int,也是先转换成Integer然后在放在集合中。</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><a id="more"></a><ul><li>List是一个接口，而下面有ArrayList和LinkList两个实现类，关于Array和Linkd的区别，详见数据结构。</li><li>List是有顺序的！</li><li>Vector(同步，即线程安全) 非常类似ArrayList，但是Vector是同步的,Vector并不推荐使用，原因：<ul><li>vector是jdk 1.0的东西，非常老</li><li>vector底层使用数组来实现，只能从尾部进行操作，效率特别低</li><li>当需要扩容的时候，会扩容一倍，而ArrayList只扩容50%，很容易导致空间分配不足的问题</li><li>已有的替代品：copyAndWriteList(Jdk1.5的东西)</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>Set也是一个接口，下面有HashSet和TreeSet两个实现类</li><li>HashSet: HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。 里面的对象可能会被打乱，但是效率更高。</li><li>TreeSet: TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。 保证对象的有序性</li><li>Set里面没有重复数据  这样可以去重<br>| 重要方法 | 作用  |<br>| ———– | ————- |<br>| iterator( ) | 主要用于递归集合，返回一个Iterator()对象，利用Iterator()去接收 |</li></ul><blockquote><p>《后期添加》注意：这个Iterator是Collection下面的 。</p></blockquote><h2 id="Deque-amp-amp-Queue"><a href="#Deque-amp-amp-Queue" class="headerlink" title="Deque &amp;&amp; Queue"></a>Deque &amp;&amp; Queue</h2><ul><li>其实Deque是Queue的一个接口，是父子关系</li><li><p>注意他的子接口Deque下面有两个实现类ArrayDeque…</p><p>  <img src="https://s2.ax1x.com/2019/04/28/EQg5N9.png" alt></p></li></ul><ul><li><p>Queue是一个普通队列，详情见数据结构</p></li><li><p>Deque是Queue的子接口，他是一个双端队列，可以支持FIFO(First Input First Output)和LIFO原则。</p></li></ul><h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><ul><li>BlockingQueue阻塞队列:当添加队列的时候，可以去设置等待时间。即当队列满的时候，可以等待，超过等待时间返回false。取队列的时候也可以等待。</li><li>ConcurrentLinkedQueue非阻塞队列，添加和取队列的时候不去等待。</li><li>队列原则</li><li><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</li></ul></li><li><ul><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。　　<blockquote><p>Tips: 非阻塞队列比阻塞队列效率要好，但是确实不安全的</p></blockquote></li></ul></li></ul><hr><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue()"></a>ConcurrentLinkedQueue<e>()</e></h4><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">offer</td><td style="text-align:left">将Object添加到队列的尾部</td></tr><tr><td style="text-align:left">poll</td><td style="text-align:left">从队列头取Object并且将其在队列中删除</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">从队列头取Object并且不将其在队列中删除</td></tr></tbody></table><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="BlockingQueue-Size"><a href="#BlockingQueue-Size" class="headerlink" title="BlockingQueue(Size)"></a>BlockingQueue<e>(Size)</e></h4><p><img src="https://s2.ax1x.com/2019/04/08/A4Oysx.png" alt="常用队列"></p><ul><li><p>ArrayBlockingQueue 数组型队列，必须要指定size</p></li><li><p>linkedBlockingQueue  链表型无界队列，可以指定size</p></li></ul><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">offer()</td><td style="text-align:left">将Object添加到队列的尾部&lt;非阻塞式&gt;</td></tr><tr><td style="text-align:left">offer(Object,time,timeUtil)</td><td style="text-align:left">将Object添加到队列的尾部&lt;阻塞式&gt;,设定队满的时候等待时间</td></tr><tr><td style="text-align:left">poll</td><td style="text-align:left">从队列头取Object并且将其在队列中删除&lt;非阻塞式&gt;</td></tr><tr><td style="text-align:left">poll(Object,time,timeUtil)</td><td style="text-align:left">队列头取Object并且将其在队列中删除&lt;阻塞式&gt;,设定队空的时候等待时间</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">从队列头取Object并且不将其在队列中删除</td></tr></tbody></table><blockquote><p>这里要注意： add()方法和offer方法的区别，add方法在队列满的情况下会抛出一个异常。而offer并不会。|</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装redis</title>
      <link href="/2019/04/30/centos7%E5%AE%89%E8%A3%85redis/"/>
      <url>/2019/04/30/centos7%E5%AE%89%E8%A3%85redis/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7安装redis"><a href="#centos7安装redis" class="headerlink" title="centos7安装redis"></a>centos7安装redis</h1><p>我的安装包版本是redis5.6</p><a id="more"></a><h2 id="准备安装"><a href="#准备安装" class="headerlink" title="准备安装"></a>准备安装</h2><hr><p>安装redis需要gcc环境</p><pre><code>yum install gcc</code></pre><p>准备redis5.6的tar包，我这里离线下载的</p><pre><code># 这里我解压到了桌面 /root/桌面tar -zxvf redis...   #解压</code></pre><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><hr><pre><code>make MALLOC=libcmake install  # 这里会将启动程序安装到 /usr/local/bin下面cd /usr/local/bin./redis-server #测试运行</code></pre><p>如果出现下面的图片则证明启动成功。<img src="https://s2.ax1x.com/2019/04/30/E8A5h6.png" alt></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><hr><p>在/path/下 我这里则是/root/桌面/redis5.6/redis.conf修改下面的变量</p><pre><code>vi redis.conf#下面是修改项 yes的意思就是可以守护态运行 no则是必须前台运行daemonize yesrequirepass 123  #这个是密码 可以自定义#注释下列选项 这样就可以远程连接bind 127.0.0.1</code></pre><p>移动redis.conf到/usr/local/bin下</p><pre><code>cp redis.conf /usr/local/bin</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>cd /usr/local/bin./redis-server redis.conf &amp; # &amp;代表后台启动</code></pre><p>利用本地电脑的redis可视化工具测试连接</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化初探</title>
      <link href="/2019/04/29/mysql%E4%BC%98%E5%8C%96%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/04/29/mysql%E4%BC%98%E5%8C%96%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL优化初探"><a href="#MySQL优化初探" class="headerlink" title="MySQL优化初探"></a>MySQL优化初探</h1><p>这里用的是Mysql5.6.34win64版本</p><h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><p>3F范式</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>垂直分割</p><p>水平分割取模算法</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><a id="more"></a><hr><p>下面是我的配置文件</p><pre><code class="properties"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It&#39;s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]character_set_server = utf8# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_binlog_bin=ON#错误日志#log_error=D:\Program Files\mysql-5.6.34-winx64\data\logs\err.log#全查询日志 #log_output=FILE  #不启用的话慢日志查询会存在数据表中general_log=ongeneral_log_file=query.log#慢查询日志slow_query_log=on   long_query_time=2#时间为2sslow_query_log_file=slowquery.log# These are commonly set, remove the # and set as required. basedir = D:\Program Files\mysql-5.6.34-winx64# 日志存放目录 datadir = D:\Program Files\mysql-5.6.34-winx64\data port = 3306# server_id = .....#二进制日志配置，第二、三行配置最后一个binlog-bin和binlog是不加后缀的文件名，不加后缀的话有妙用server_id=1#log_bin=D:\Program Files\mysql-5.6.34-winx64\data\bin_log\binlog-bin#log_bin_index=D:\Program Files\mysql-5.6.34-winx64\data\bin_log\binlog# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>当数据有重复的时候，如何降低幂等</p><p>唯一索引</p></blockquote><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p>日志配置在上面，将慢查询时间设置好(默认是10秒)，重启mysql服务，之后如果超过设定时间，就会记录在log日志中。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式初探</title>
      <link href="/2019/04/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/04/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java设计模式初探"><a href="#java设计模式初探" class="headerlink" title="java设计模式初探"></a>java设计模式初探</h1><hr><h2 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h2><blockquote><p>我们平常都是通过new一个类来实例化一个对象，但是我们同时可以通过反射机制来构建，并且动态获取类里面的信息 比如说构造函数，方法和属性。</p></blockquote><p>常用的代码像是这个：</p><a id="more"></a><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>Class&lt;?&gt; Class.forName(“全类名”)</td><td>加载该类对象，并且通过这个方法可以获得类的信息</td></tr><tr><td>xxx.newInstance()</td><td>实例化一个对象，这个我一般和上面的代码一起用来实例化对象</td></tr><tr><td>Class.forName(“xx”).getDeclaredxxx</td><td>获得该类的信息</td></tr></tbody></table><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单利模式的共同点就是将构造函数私有化。</li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre><code class="java">public class UserEntity {    private String username;    private static final  UserEntity user = new UserEntity();    static {        System.out.println(&quot;静态代码块&quot;);    }    private UserEntity() {        System.out.println(&quot;默认构造函数&quot;);    }    {        System.out.println(&quot;非静态代码块&quot;);    }    public static UserEntity getInstance(){        return user;    }    public void setUsername(String username){        this.username = username;    }    public String getUsername(){        return username;    }}</code></pre><ul><li>通过对该类进行java反射可以知道，static代码块在Class.forName装载的时候开始执行，而实例化的时候非静态代码块和构造函数开始执行</li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>实体类在需要的时候才创建。</li></ul><pre><code class="java">public class UserEntity {    private String username;    private static UserEntity user;    static {        System.out.println(&quot;静态代码块&quot;);    }    private UserEntity() {        System.out.println(&quot;默认构造函数&quot;);    }    {        System.out.println(&quot;非静态代码块&quot;);    }    /*这里加锁保证线程安全*/    public synchronized static UserEntity getInstance(){        if(user == null){            user = new UserEntity();        }        return user;    }    public void setUsername(String username){        this.username = username;    }    public String getUsername(){        return username;    }}</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="java">public class UserEntity2 {    private UserEntity2() {    }    public static class SingleInstance{        private static final UserEntity2 user = new UserEntity2();    }    public static UserEntity2 getInstance(){       return SingleInstance.user;    }}</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="java">//使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载public class User {    public static User getInstance() {        return SingletonDemo04.INSTANCE.getInstance();    }    private static enum SingletonDemo04 {        INSTANCE;        // 枚举元素为单例        private User user;        private SingletonDemo04() {            System.out.println(&quot;SingletonDemo04&quot;);            user = new User();        }        public User getInstance() {            return user;        }    }    public static void main(String[] args) {        User u1 = User.getInstance();        User u2 = User.getInstance();        System.out.println(u1 == u2);    }}</code></pre><h3 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h3><p>可以看作是对懒汉式的一个改版 </p><pre><code class="java">public class SingletonDemo04 {    private SingletonDemo04 singletonDemo04;    private SingletonDemo04() {    }    public SingletonDemo04 getInstance() {        if (singletonDemo04 == null) {            synchronized (this) {                if (singletonDemo04 == null) {                    singletonDemo04 = new SingletonDemo04();                }            }        }        return singletonDemo04;    }}</code></pre><h3 id="单例模式的选择"><a href="#单例模式的选择" class="headerlink" title="单例模式的选择"></a>单例模式的选择</h3><p>如果不需要延迟加载单例，可以使用<strong>枚举</strong>或者<strong>饿汉式</strong>，相对来说枚举性好于饿汉式。</p><p>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。</p><p>最好使用饿汉式  </p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>工厂模式将实例化的工作从客户手里夺了回来，Spring的依赖反转也是这个道理</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li>简单工厂一般代码不会更改，拓展性差</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQ4BAU.png" alt></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li>工厂方法一般是如果产品非常多的情况下，派生出不同的工厂去实例化不同的产品。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQoDN8.png" alt></p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><blockquote><p>这里分清楚产品族和产品树的关联</p></blockquote><p>在下面的图中，两个产品有关联的实体形成了产品族，一个工厂只生产一个产品族。</p><p>产品树可以理解为由一个接口派生出来的类。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQo4EV.png" alt></p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul><li>这个方法是平时用的蛮多的一个</li><li>其实模板方法就是将子类都利用的方法在父类中写好。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQTdxJ.png" alt></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul><li>Builder 可以根据客户提交的参数自定义产品的零件来产生不同的产品，这也是建造者模式和工厂模式的一个很大的区别。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQ7JOA.png" alt></p><h3 id="建造者的应用场景"><a href="#建造者的应用场景" class="headerlink" title="建造者的应用场景"></a>建造者的应用场景</h3><ul><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</li><li>JAVA 中的 StringBuilder。 </li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。SpringAOP就是代理模式</p><p><img src="https://s2.ax1x.com/2019/04/28/EQ7DSg.png" alt></p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理一般都是将代码写死了，在项目中用的也很少，理解即可。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQ7fYT.png" alt></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>静态代理有很大的缺陷，就是如果像让很多类都就行切面，不可能都去写进Proxy里面，这样动态代理就可以解决这个问题。</p></blockquote><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><pre><code class="java">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象 public class InvocationHandlerImpl implements InvocationHandler {    private Object target;// 这其实业务实现类对象，用来调用具体的业务方法    // 通过构造函数传入目标对象    public InvocationHandlerImpl(Object target) {        this.target = target;    }    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Object result = null;        System.out.println(&quot;调用开始处理&quot;);        result = method.invoke(target, args);        System.out.println(&quot;调用结束处理&quot;);        return result;    }    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException {        // 被代理对象        IUserDao userDao = new UserDao();        InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDao);        ClassLoader loader = userDao.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();        // 主要装载器、一组接口及调用处理动态代理实例        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);        newProxyInstance.save();    }}</code></pre><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>需要asm-all和cglib的jar包</p><pre><code class="java">public class CglibProxy implements MethodInterceptor {    private Object targetObject;    // 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理    public Object getInstance(Object target) {        // 设置需要创建子类的类        this.targetObject = target;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(&quot;开启事物&quot;);        Object result = proxy.invoke(targetObject, args);        System.out.println(&quot;关闭事物&quot;);        // 返回代理对象        return result;    }    public static void main(String[] args) {        CglibProxy cglibProxy = new CglibProxy();        UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDao());        userDao.save();    }}</code></pre><h2 id="门面-外观-模式"><a href="#门面-外观-模式" class="headerlink" title="门面(外观)模式"></a>门面(外观)模式</h2><p>外观模式，其实就是将后面很复杂的方法封装成一个类里面，让客户直接调用封装类里面的方法即可。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQblKH.png" alt></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQqPFP.jpg" alt></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>现实开发中如果我们由一个根据不同情况创建不同实体的情况下，无论是用if-else或者是swith实现，代码是不符合开闭原则的，也就是他的拓展性并不高。</p><p>那么，策略模式，解决了这个问题。其实，他的代码是比之前多了不少，但是这样也同时隐藏后台的核心代码，只将Strategy接口交给了用户，保证了一定的安全性。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQqb0s.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁的深入理解</title>
      <link href="/2019/04/21/%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2019/04/21/%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java锁的深入理解"><a href="#java锁的深入理解" class="headerlink" title="java锁的深入理解"></a>java锁的深入理解</h1><hr><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>这个锁相当于一个递归锁，如果上层代码已经获得到了锁的所有权，那么他的子代码也直接拥有所有权，重入锁的常见有</p><p>Lock锁(轻量级锁) 和 synchronize(重量级锁)</p><blockquote><p>synchronize是根据当前java线程数量，从轻量级锁逐渐变成重量级锁的过程，且此过程不可逆。</p></blockquote><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>相比<a href="http://ifeve.com/locks/" target="_blank" rel="noopener">Java中的锁(Locks in Java)</a>里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。Java5在java.util.concurrent包中已经包含了读写锁。尽管如此，我们还是应该了解其实现背后的原理。</p><p>这里用一段实例来解释读写锁</p><pre><code class="java">public class TestMain {    public static void main(String args[]){        new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    Cache.put(i + &quot;&quot;, i + &quot;&quot;);                }            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    Cache.get(i + &quot;&quot;);                }            }        }).start();    }}class Cache {    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    static Lock r = rwl.readLock();    static Lock w = rwl.writeLock();    // 获取一个key对应的value    public static final Object get(String key) {        r.lock();        try {            System.out.println(&quot;正在做读的操作,key:&quot; + key + &quot; 开始&quot;);            Thread.sleep(100);            Object object = map.get(key);            System.out.println(&quot;正在做读的操作,key:&quot; + key + &quot; 结束&quot;);            System.out.println();            return object;        } catch (InterruptedException e) {        } finally {            r.unlock();        }        return key;    }    // 设置key对应的value，并返回旧有的value    public static final Object put(String key, Object value) {        w.lock();        try {            System.out.println(&quot;正在做写的操作,key:&quot; + key + &quot;,value:&quot; + value + &quot;开始.&quot;);            Thread.sleep(100);            Object object = map.put(key, value);            System.out.println(&quot;正在做写的操作,key:&quot; + key + &quot;,value:&quot; + value + &quot;结束.&quot;);            System.out.println();            return object;        } catch (InterruptedException e) {        } finally {            w.unlock();        }        return value;    }    // 清空所有的内容    public static final void clear() {        w.lock();        try {            map.clear();        } finally {            w.unlock();        }    }}</code></pre><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>这里只是一个描述，乐观锁和CAS无锁机制，他的性能比悲观锁高，因为他并没有利用锁，更不会有死锁问题。</p><p>实现方式：比如在 mysql字段里面添加一个version字段，每次更新字段时都会首先检验version字段和当前版本的匹配问题，就可以做到类似行级锁的效果。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p><h2 id="CAS锁-暂时不研究"><a href="#CAS锁-暂时不研究" class="headerlink" title="CAS锁(暂时不研究)"></a>CAS锁(暂时不研究)</h2><p>（1）与锁相比，使用比较交换compare and Swap（下文简称CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。 </p><p>（2）无锁的好处：</p><p>第一，在高并发的情况下，它比有锁的程序拥有更好的性能；</p><p>第二，它天生就是死锁免疫的。</p><p>就凭借这两个优势，就值得我们冒险尝试使用无锁的并发。</p><p>（3）CAS算法的过程是这样：它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p><p>（4）CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><p>（5）简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。</p><p>（6）在硬件层面，大部分的现代处理器都已经支持原子化的CAS指令。在JDK 5.0以后，虚拟机便可以使用这个指令来实现并发操作和并发数据结构，并且，这种操作在虚拟机中可以说是无处不在。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Future和Callable</title>
      <link href="/2019/04/21/%E6%89%8B%E5%86%99Future%E5%92%8CCallable/"/>
      <url>/2019/04/21/%E6%89%8B%E5%86%99Future%E5%92%8CCallable/</url>
      
        <content type="html"><![CDATA[<h1 id="java-Future和Callable模式"><a href="#java-Future和Callable模式" class="headerlink" title="java Future和Callable模式"></a>java Future和Callable模式</h1><hr><ul><li>我们之前使用的多线程需要在run方法中执行多线程代码，但是run方法有一个致命缺点，就是他的返回值是空。但是，如果我们像要我们如何知道子线程执行完毕呢？没有返回值告诉我们，所以我们需要上面的两种模式。<a id="more"></a><h2 id="Callable模式"><a href="#Callable模式" class="headerlink" title="Callable模式"></a>Callable模式</h2></li></ul><hr><p>其实，Callable就相当于一个有返回值的线程，而Future是一个可以接收Callable的返回值。</p><p>Callable的源代码如下：</p><pre><code class="java">@FunctionalInterfacepublic interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p>他和Runable接口源代码是很相似的。他和Runable的唯一的不同是返回值V是泛型,而Runable是void.</p><p><strong><em>Future常用方法</em></strong></p><p><strong>V get()</strong> <strong>：</strong>获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</p><p><strong>V get(Long timeout , TimeUnit unit)</strong> ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</p><p><strong>boolean isDone()</strong> <strong>：</strong>如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</p><p><strong>boolean isCanceller()</strong> <strong>：</strong>如果任务完成前被取消，则返回true。</p><p><strong>boolean cancel(boolean mayInterruptRunning)</strong> <strong>：</strong>如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。</p><p>通过方法分析我们也知道实际上Future提供了3种功能：（1）能够中断执行中的任务（2）判断任务是否执行完成（3）获取任务执行完成后额结果。</p><hr><p>实例:</p><pre><code class="java">public class TestMain {    public static void main(String[] args) throws InterruptedException, ExecutionException {        ExecutorService executor = Executors.newCachedThreadPool();        Future&lt;Integer&gt; future = executor.submit(new AddNumberTask());        System.out.println(Thread.currentThread().getName() + &quot;线程执行其他任务&quot;);        Integer integer = future.get();        System.out.println(integer);        // 关闭线程池        if (executor != null)            executor.shutdown();    }}class AddNumberTask implements Callable&lt;Integer&gt; {    public AddNumberTask() {    }    @Override    public Integer call() throws Exception {        System.out.println(&quot;####AddNumberTask###call()&quot;);        Thread.sleep(5000);        return 5000;    }}</code></pre><p>Future的好处就是先传给你一个结果,然后等资源全部解析完成之后,再传给你值,相当于ajax的异步.</p><p><img src="https://s2.ax1x.com/2019/04/21/EF0tSO.png" alt></p><h2 id="手写Callable"><a href="#手写Callable" class="headerlink" title="手写Callable"></a>手写Callable</h2><hr><p>仔细一想，这相当于生产者消费者模型。可以用wait和notify来解决。</p><p>核心代码：</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:00 * Description: :/TODO_ */public class FutureCore {    //请求参数    private String arg;    //标识变量    private volatile  boolean FLAG = false;    //返回结果    private String result;    public FutureCore(String arg) {        this.arg = arg;    }    //这里可能会有阻塞，模拟下载    public synchronized void setRequest(){        if(FLAG){            return;        }        System.out.println(&quot;接收网络参数&quot; + arg+&quot;;数据请求中...&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        this.result = &quot;结果&quot;;        FLAG = true;        notify();    }    //返回结果    public synchronized String getResult(){        while (!FLAG){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        return result;    }}</code></pre><p>这里是封装future的类</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:05 * Description: :/TODO_ */public class FutureUtil {    public static FutureCore submit(String arg){        FutureCore futureCore = new FutureCore(arg);        //子线程开始下载资源        new Thread(new Runnable() {            @Override            public void run() {                futureCore.setRequest();            }        }).start();        //直接返回结果        return futureCore;    }}</code></pre><p>测试主函数如下:</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:09 * Description: :/TODO_ */public class ThreadTest {    public static void main(String args[]){        System.out.println(&quot;开始future&quot;);        FutureCore core = FutureUtil.submit(&quot;测试&quot;);        System.out.println(&quot;主线程继续执行&quot;);        System.out.println(core.getResult());    }}</code></pre><p>结果如下：</p><p><img src="https://s2.ax1x.com/2019/04/21/EF0fmj.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm+rabbitmq 分布式实例</title>
      <link href="/2019/04/15/ssm-rabbitmq-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/15/ssm-rabbitmq-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="在分布式架构下利用rabbitmq完成消息队列"><a href="#在分布式架构下利用rabbitmq完成消息队列" class="headerlink" title="在分布式架构下利用rabbitmq完成消息队列"></a>在分布式架构下利用rabbitmq完成消息队列</h1><hr><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><hr><blockquote><p>我们利用rabbit:admin直接代码绑定交换机和队列,这里是开发常用的方法<br>最后我们会利用web端界面实现消息的分发实例</p></blockquote><a id="more"></a><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><hr><h4 id="配置文件详解-1"><a href="#配置文件详解-1" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><hr><ul><li><p>下面是rabbitmq的基础设置</p><pre><code class="xml">&lt;!-- 定义连接工厂 --&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;                             username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;                             virtual-host=&quot;${mq.vh}&quot; /&gt;  &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;  &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;                   exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;</code></pre></li><li><p>定义队列</p></li></ul><pre><code class="xml"> &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;</code></pre><ul><li>定义交换机，这里我们定义topic模式,这里我们绑定队列</li></ul><pre><code class="xml"> &lt;!--topic 模式：发送端不是按固定的routing key发送消息，而是按字符串“匹配”发送，接收端同样如此。 --&gt;&lt;!--durable : 是否持久化 auto-delete：是否自动删除  --&gt;    &lt;rabbit:topic-exchange name=&quot;solrExChange&quot;                           durable=&quot;true&quot; auto-delete=&quot;false&quot;&gt;         &lt;rabbit:bindings&gt;             &lt;!-- 这个pattern是topic特有的通配符模式 --&gt;            &lt;rabbit:binding queue=&quot;chase1&quot; pattern=&quot;item.#&quot;&gt;&lt;/rabbit:binding&gt;        &lt;/rabbit:bindings&gt;    &lt;/rabbit:topic-exchange&gt;</code></pre><ul><li>利用代码同步队列和交换机</li></ul><pre><code class="xml">&lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</code></pre><blockquote><p>注意: 如果这里不写rabbit:admin,也就是说我们利用rabbitmq的web界面手动绑定的话,我们并不需要在交换机上绑定队列和定义队列</p></blockquote><ul><li><p>完成的配置文件</p><ul><li>applicationContext-rabbit.xml</li></ul></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/rabbit    http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入外部数据库的配置文件，location位置填写的是相对位置 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/rabbit.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot;    username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;    virtual-host=&quot;${mq.vh}&quot; /&gt;    &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;    &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;    exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;    &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;    &lt;!--topic 模式：发送端不是按固定的routing key发送消息，而是按字符串“匹配”发送，接收端同样如此。 --&gt;    &lt;rabbit:topic-exchange name=&quot;solrExChange&quot;    durable=&quot;false&quot; auto-delete=&quot;false&quot;&gt;        &lt;rabbit:bindings&gt;            &lt;rabbit:binding queue=&quot;chase1&quot; pattern=&quot;item.#&quot;&gt;&lt;/rabbit:binding&gt;        &lt;/rabbit:bindings&gt;    &lt;/rabbit:topic-exchange&gt;    &lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><hr><pre><code class="java">package com.rabbit.producer.service;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.annotation.Resources;/** * Created with IntelliJ IDEA. * User: WHOAMI * Date: 2019/4/15 * Time: 8:46 * Description: :/TODO_ */@Servicepublic class RabbitService  {    //注入模板    @Autowired    private AmqpTemplate amqpTemplate;    public void SendTest(){        System.out.println(&quot;开始发送消息&quot;);        //这里是代码核心处       amqpTemplate.convertAndSend(&quot;item.message&quot;,&quot;发送消息&quot;);    }}</code></pre><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><hr><h4 id="配置文件详解-2"><a href="#配置文件详解-2" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><hr><ul><li><p>下面是rabbitmq的基础设置</p><pre><code class="xml">&lt;!-- 定义连接工厂 --&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;                             username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;                             virtual-host=&quot;${mq.vh}&quot; /&gt;  &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;  &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;                   exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;</code></pre></li><li><p>定义队列</p></li></ul><pre><code class="xml"> &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;</code></pre><ul><li>利用代码同步队列和交换机</li></ul><pre><code class="xml">&lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</code></pre><ul><li><p>定义消费者</p><pre><code class="xml">&lt;!-- 消息接收者 具体到特定类 --&gt;  &lt;bean id=&quot;Consumer&quot; class=&quot;com.rabbit.consumer.utils.Consumer&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>定义监听器</p></li></ul><pre><code class="xml">&lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象    acknowledeg = &quot;manual&quot;，意为表示该消费者的ack方式为手动 默认为auto--&gt;    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledeg = &quot;manual&quot;&gt;        &lt;rabbit:listener  queues=&quot;chase1&quot;  ref=&quot;Consumer&quot;/&gt;    &lt;/rabbit:listener-container&gt;</code></pre><ul><li>完成配置文件</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/rabbit    http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入外部数据库的配置文件，location位置填写的是相对位置 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/rabbit.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot;    username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;    virtual-host=&quot;${mq.vh}&quot; /&gt;    &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;    &lt;!-- 消息接收者 --&gt;    &lt;bean id=&quot;Consumer&quot; class=&quot;com.rabbit.consumer.utils.Consumer&quot;&gt;&lt;/bean&gt;    &lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象    acknowledeg = &quot;manual&quot;，意为表示该消费者的ack方式为手动--&gt;    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot;&gt;        &lt;rabbit:listener  queues=&quot;chase1&quot;  ref=&quot;Consumer&quot;/&gt;    &lt;/rabbit:listener-container&gt;    &lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><hr><p>我们要定义消费者，那么我们需要实现ChannelAwareMessageListener 和 MessageListener接口</p><ul><li>两个接口源码如下</li></ul><pre><code class="java">public interface MessageListener {    void onMessage(Message message);}public interface ChannelAwareMessageListener {    void onMessage(Message message, Channel channel) throws Exception;}</code></pre><blockquote><p>个人说明： 这两个接口的区别就是 Channel 会手动进行ack</p></blockquote><pre><code class="java">package com.rabbit.consumer.utils;import com.rabbitmq.client.Channel;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.core.ChannelAwareMessageListener;import org.springframework.stereotype.Component;/** * Created with IntelliJ IDEA. * User: WHOAMI * Date: 2019/4/15 * Time: 9:01 * Description: :/TODO_ */@Componentpublic class Consumer implements ChannelAwareMessageListener {    @Override    public void onMessage(Message message, Channel channel) throws Exception {        String msg = new String(message.getBody(),&quot;utf-8&quot;);        //消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);        //ack返回false，并重新回到队列，api里面解释得很清楚//        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);        //true拒绝消息 false确认接受到消息        //channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);        System.out.println(&quot;消费者消费掉了消息:&quot; + msg);    }}</code></pre><h2 id="错误笔记"><a href="#错误笔记" class="headerlink" title="错误笔记"></a>错误笔记</h2><hr><p>注意 ，如果web端里面有配置文件里面声明的交换机或者队列，如果配置文件里面 declare或者auto-delete不相同的时候会爆出500的错误！并且不会绑定数据！</p><p><img src="https://s2.ax1x.com/2019/04/15/Ajj3Mq.png" alt></p><p><img src="https://s2.ax1x.com/2019/04/15/Ajj0zR.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> j2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freemaker传输数据问题</title>
      <link href="/2019/04/13/freemaker%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/13/freemaker%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeMaker传输数据问题"><a href="#FreeMaker传输数据问题" class="headerlink" title="FreeMaker传输数据问题"></a>FreeMaker传输数据问题</h1><hr><ul><li>正常输出方程式 ${XXX}</li><li>如果页面需要字符串，那么我们需要 在变量两边加引号 ‘${XXX}’</li><li>如果传输的是数字，在超出100的时候，会自行加逗号，例如1,400,解决办法： ${XXX?c}</li></ul><a id="more"></a><ul><li><p>如果你的字段是null的话，freemaker直接引用是会报错的<br><img src="https://s2.ax1x.com/2019/04/13/AL5JCF.png" alt></p><p>这样需要你在可能出现错误的字段上加一个判断他是否为空，$(XXX!”啊，这是null”)</p></li></ul><ul><li>其实在判断字符串的时候 例如 &lt;#if sex= “男”&gt; 和 &lt;#if sex== “男”&gt; 是一样的</li></ul>]]></content>
      
      
      <categories>
          
          <category> ssm错误笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误笔记 </tag>
            
            <tag> ssm </tag>
            
            <tag> freemaker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装solr服务</title>
      <link href="/2019/04/12/centos7%E5%AE%89%E8%A3%85solr%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/12/centos7%E5%AE%89%E8%A3%85solr%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7-下安装solr服务"><a href="#centos7-下安装solr服务" class="headerlink" title="centos7 下安装solr服务"></a>centos7 下安装solr服务</h1><h2 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h2><hr><ul><li><p>将jdk扔到linux下，解压</p></li><li><p>修改环境变量</p></li></ul><pre><code># 打开配置文件vim /etc/profile# 在文件末尾添加JAVA_HOME=/usr/local/java/jdk1.8.0_201CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jarPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH#保存并关闭source /etc/profile</code></pre><h2 id="2-安装solr"><a href="#2-安装solr" class="headerlink" title="2. 安装solr"></a>2. 安装solr</h2><hr><ol><li><p>下载solr安装包 [官方网址]:(<a href="http://www.apache.org/dyn/closer.lua/lucene/solr/8.0.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/solr/8.0.0</a>)</p></li><li><p>扔到linux下，解压</p><a id="more"></a></li><li>cd到目录下\bin</li></ol><pre><code> ./solr start -force #默认启动8983端口</code></pre><blockquote><p>注意 ，这里我并没有修改文件限制，linux会限制传输文件大小<br><img src="https://s2.ax1x.com/2019/04/12/AbujvF.png" alt></p><ol start="4"><li>关闭防火墙<pre><code>systemctl stop firewalld</code></pre></li></ol></blockquote><ol start="5"><li>打开游览器，访问 192.168.xx.xx.8983</li></ol><h2 id="3-solr功能介绍"><a href="#3-solr功能介绍" class="headerlink" title="3.solr功能介绍"></a>3.solr功能介绍</h2><hr><p><img src="https://s2.ax1x.com/2019/04/12/AbajBt.png" alt></p><p><img src="https://s2.ax1x.com/2019/04/12/Abdp4S.png" alt></p><h2 id="4-配置solr"><a href="#4-配置solr" class="headerlink" title="4. 配置solr"></a>4. 配置solr</h2><hr><h3 id="配置core环境"><a href="#配置core环境" class="headerlink" title="配置core环境"></a>配置core环境</h3><hr><ul><li><p>打开solr-admin</p></li><li><p>按照下图操作<br><img src="https://s2.ax1x.com/2019/04/12/AbKrxU.png" alt></p></li><li><p>之后会提示错误，因为找不到config和schema文件</p></li><li>打开linux，在%安装目录%/server/configsets/_default/下的conf文件copy到 %安装目录%/server/%core名称%/ 下</li><li>重新创建core</li><li>看到自己的core文件夹下面出现这几个文件，证明安装成功<br><img src="https://s2.ax1x.com/2019/04/12/AbMCLQ.png" alt></li></ul><h3 id="配置中文分词器"><a href="#配置中文分词器" class="headerlink" title="配置中文分词器"></a>配置中文分词器</h3><hr><blockquote><p>其实solr8.0已经自带了中文分词器<br><img src="https://s2.ax1x.com/2019/04/12/AbMuyF.png" alt></p></blockquote><ul><li><p>但是为了业务要求，我们使用IK分词器</p><p>ik可以去maven仓库去下载</p><p><img src="https://s2.ax1x.com/2019/04/12/AbtyfH.png" alt></p></li><li><p>将三个jar包放到%solr安装包%/server/solr-webapp/webapp/WEB-INF/lib/下</p></li><li><p>将剩余的三个文件放到%solr安装包%/server/solr-webapp/webapp/WEB-INF/classes/下[如果没有，自己新建]</p></li><li><p>配置ik 打开%自己CORE%/conf/managed-schema.xml文件</p></li></ul><pre><code>    &lt;!-- ik分词器 --&gt;        &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;        &lt;!-- 索引分词器 --&gt;        &lt;analyzer type=&quot;index&quot; isMaxWordLength=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;        &lt;!-- 查询分词器 --&gt;        &lt;analyzer type=&quot;query&quot; isMaxWordLength=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;        &lt;/fieldType&gt;</code></pre><ul><li>重启 ./solr restart -force</li></ul><h3 id="配置业务域FileType"><a href="#配置业务域FileType" class="headerlink" title="配置业务域FileType"></a>配置业务域FileType</h3><hr><p>打开%自己CORE%/conf/managed-schema.xml文件</p><pre><code>&lt;field name=&quot;item_title&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot;  type=&quot;plong&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_desc&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><p>重启 ./solr restart -forces</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> linux </tag>
            
            <tag> java </tag>
            
            <tag> 搜索服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义线程池</title>
      <link href="/2019/04/08/java%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/04/08/java%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="java线程池"><a href="#java线程池" class="headerlink" title="java线程池"></a>java线程池</h1><h2 id="java初始定义线程"><a href="#java初始定义线程" class="headerlink" title="java初始定义线程"></a>java初始定义线程</h2><p><img src="https://s2.ax1x.com/2019/04/08/A4XAkF.png" alt></p><h2 id="java线程池源码分析"><a href="#java线程池源码分析" class="headerlink" title="java线程池源码分析"></a>java线程池源码分析</h2><p><img src="https://s2.ax1x.com/2019/04/08/A5iM28.png" alt></p><pre><code class="java">/**     * Creates a new {@code ThreadPoolExecutor} with the given initial     * parameters and default rejected execution handler.     *     * @param corePoolSize the number of threads to keep in the pool, even     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set     * @param maximumPoolSize the maximum number of threads to allow in the     *        pool     * @param keepAliveTime when the number of threads is greater than     *        the core, this is the maximum time that excess idle threads     *        will wait for new tasks before terminating.     * @param unit the time unit for the {@code keepAliveTime} argument     * @param workQueue the queue to use for holding tasks before they are     *        executed.  This queue will hold only the {@code Runnable}     *        tasks submitted by the {@code execute} method.     * @param threadFactory the factory to use when the executor     *        creates a new thread     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;     *         {@code corePoolSize &lt; 0}&lt;br&gt;     *         {@code keepAliveTime &lt; 0}&lt;br&gt;     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;     *         {@code maximumPoolSize &lt; corePoolSize}     * @throws NullPointerException if {@code workQueue}     *         or {@code threadFactory} is null     */    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);    }</code></pre><ol><li>corePoolSize 表示常驻核心线程数。如果等于0，则任务执行完成后，没有任何请求进入时销毁线程池的线程；如果大于0，即使本地任务执行完毕，核心线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置的过小会导致线程频繁地创建或销毁。再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。</li><li>maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li></ol><h2 id="合理配置线程数"><a href="#合理配置线程数" class="headerlink" title="合理配置线程数"></a>合理配置线程数</h2><hr><h3 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h3><p>根据需求的不同，可以将技术分成IO密集和CPU密集两种类型。</p><p>IO密集：</p><p>线程中存在大量的阻塞，例如，请求，数据库连接，。。。线程会有大量的等待，这样会有等待时间，那么这个线程就是IO密集型，一般这种类型，配置核心线程数的规则是 core = 2*CPU内核</p><p>CPU密集：</p><p>线程中代码非常多，而且计算的内容非常多，阻塞少，这个就是CPU密集，配置规则是：core = CPU内核。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装rabbitMQ</title>
      <link href="/2019/04/07/centos7%E5%AE%89%E8%A3%85rabbitMQ/"/>
      <url>/2019/04/07/centos7%E5%AE%89%E8%A3%85rabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="centos安装RabbitMQ并配置环境"><a href="#centos安装RabbitMQ并配置环境" class="headerlink" title="centos安装RabbitMQ并配置环境"></a>centos安装RabbitMQ并配置环境</h1><p>之前我在网上搜罗了很多教程，但是大多都很繁琐，要么就是版本太老。</p><p>这里我提供了一个非常简单的方法</p><a id="more"></a><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><hr><p>打开[官网地址]: (<a href="https://www.rabbitmq.com/releases/" target="_blank" rel="noopener">https://www.rabbitmq.com/releases/</a>)  </p><p>如下图：</p><p><img src="https://s2.ax1x.com/2019/04/14/AOb5kR.png" alt></p><ul><li>这里我们需要erlang和rabbitmq-server<ul><li>打开对应网址下载最新的rpm安装包</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr><blockquote><p>将安装包利用xftp传输到linux，注意不要直接拖拽，安装包容易出问题。</p></blockquote><ul><li>在断网的时候安装erlang，因为我的centos7 的yum源会自动安装低版本的erlang。</li></ul><pre><code>yum install xxx  #安装软件yum list installed #查看利用yum安装的所有软件yum remove xxx #卸载软件rpm -ql [rabbitmq-server] #查看软件安装在那里</code></pre><ul><li>在联机的情况下安装rabbitmq，因为他需要安装socat依赖。</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><hr><p>由于我这里是用来做javaweb的消息中间件，所以我需要他可以http访问，所以需要添加插件</p><pre><code>  rabbitmq-plugins enable rabbitmq_management</code></pre><p>启动rabbitmq程序</p><pre><code>rabbitmq-server start</code></pre><p>其他命令</p><pre><code>rabbitmq-server restart #重启rabbitmqctl stop   #停止rabbitmqctl status  #状态</code></pre><blockquote><p>这里插播一条linux命令</p><pre><code>ps -ef|grep xxx  #查询所有xxx的进程kill -9 xxx #杀死进程端口号为xxx的进程</code></pre></blockquote><ul><li>注意！默认guest guest账户已经不能允许在远程登陆，所以我们需要创建账号</li></ul><h2 id="配置rabbitmq"><a href="#配置rabbitmq" class="headerlink" title="配置rabbitmq"></a>配置rabbitmq</h2><hr><p>下面我们创建账号，注意 这时候rabbitmq必须是启动状态</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><hr><pre><code>rabbitmqctl add_user root 111111 #创建账号rabbitmqctl set_user_tags root administrator #设置root为管理员rabbitmqctl list_users #查询所有用户</code></pre><h3 id="ui模式"><a href="#ui模式" class="headerlink" title="ui模式"></a>ui模式</h3><hr><p><img src="https://s2.ax1x.com/2019/04/07/Afjlg1.png" alt="操作"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7下设置静态ip</title>
      <link href="/2019/04/03/centos7%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/"/>
      <url>/2019/04/03/centos7%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux设置固定IP"><a href="#Linux设置固定IP" class="headerlink" title="Linux设置固定IP"></a>Linux设置固定IP</h1><blockquote><p>一般我们想要拿本地的linux当做服务器用来测试，但是我们的ip设置规则时DHCP,即自动分配ip原则，所以为了方便，这里记录了如何固定ip的方法</p></blockquote><p>我们要设置ip，要知道VM的网络适配器有三种原则</p><ul><li>桥接模式</li><li>主机模式</li><li>NAT模式</li></ul><p>我们的真实主机有两块对应的网卡</p><ul><li>VMnet0</li><li>VMnet8<a id="more"></a></li></ul><p>由于我们这里只固定ip，所以别的我们现在先不了解。</p><hr><h2 id="首先设置网关，打开VM的虚拟网络适配器"><a href="#首先设置网关，打开VM的虚拟网络适配器" class="headerlink" title="首先设置网关，打开VM的虚拟网络适配器"></a>首先设置网关，打开VM的虚拟网络适配器</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag94FH.png" alt="网络适配器"></p><p>修改我们的子网ip和子网掩码，注意！上面的框只有里面的3你可以自行修改！</p><h2 id="修改主机的VM网卡-VMnet8"><a href="#修改主机的VM网卡-VMnet8" class="headerlink" title="修改主机的VM网卡 VMnet8"></a>修改主机的VM网卡 VMnet8</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag9pqO.png" alt></p><h2 id="按照下图操作"><a href="#按照下图操作" class="headerlink" title="按照下图操作"></a>按照下图操作</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag9bOf.png" alt="操作"></p><p>其中也是建议只有3更改</p><hr><h2 id="注意linux选择NAT链接后，开始修改IP！"><a href="#注意linux选择NAT链接后，开始修改IP！" class="headerlink" title="注意linux选择NAT链接后，开始修改IP！"></a>注意linux选择NAT链接后，开始修改IP！</h2><hr><pre><code>ip addr#记住画圈的这个文件名，之后会用到</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgClnK.png" alt></p><h2 id="打开下面的文件"><a href="#打开下面的文件" class="headerlink" title="打开下面的文件"></a>打开下面的文件</h2><hr><p>我们首先要知道这里文件夹只要存储的是网卡的相关信息<strong>/etc/sysconfig/network-scripts/</strong></p><pre><code> cd /etc/sysconfig/network-scripts</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgPGrV.png" alt></p><pre><code>vim ifcfg-ens33# 修改下面的两处为#BOOTPROTO=static#ONBOOT=yesONBOOT=no #修改为自动连接#并在下面添加网址等信息IPADDR=192.168.3.135#静态IPGATEWAY=192.168.3.2 #默认网关NETMASK=255.255.255.0 #子网掩码</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgPTqf.png" alt></p><h2 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h2><hr><pre><code>service network restart</code></pre><blockquote><p>重启后如果无法正常上网，可以在配置文件上面写上DNS1=8.8.8.8这一项</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal原理分析</title>
      <link href="/2019/04/02/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/02/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal原理分析"><a href="#ThreadLocal原理分析" class="headerlink" title="ThreadLocal原理分析"></a>ThreadLocal原理分析</h1><p>需求：如果我们引入一个全局变量，但是他的值在每个线程需要互相不影响。</p><blockquote><p>解决办法1:可以根据线程的次数new 几次实体类 ，然后分别装进每个线程中，但是如果线程数量很大并且不确定，这个方法不符合实际。</p></blockquote><blockquote><p>解决办法2：将实体类的变量设置为ThreadLocal类型</p></blockquote><a id="more"></a><h2 id="ThreadLocal案例引入"><a href="#ThreadLocal案例引入" class="headerlink" title="ThreadLocal案例引入"></a>ThreadLocal案例引入</h2><pre><code class="java">package com.Thread.Test;class Local{//一定要初始化变量的值    ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;(){        @Override        protected Integer initialValue() {            return 0;        }    };    public void set(){        this.count.set(this.count.get()+1);    }    public Integer get(){        return count.get();    }}class ThreadTest implements Runnable{    Local local;    public ThreadTest(Local local) {        this.local = local;    }    @Override    public void run() {        for (int i=0;i&lt;3;i++){            local.set();            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+local.get());        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Local local = new Local();        Thread thread1 = new Thread(new ThreadTest(local));        Thread thread2 = new Thread(new ThreadTest(local));        Thread thread3 = new Thread(new ThreadTest(local));        thread1.start();        thread2.start();        thread3.start();    }}</code></pre><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><ul><li>将变量设置成一个Map类型，存的时候，将线程的名字和操作一起存入Map进去，取出来的时候，根据自己的线程名字来取</li></ul><p>set方法源码：</p><pre><code class="java">  public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }</code></pre><p>get方法源码：</p><pre><code class="java">  public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程通信</title>
      <link href="/2019/03/31/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/03/31/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java-生产者与消费者的模型分析"><a href="#java-生产者与消费者的模型分析" class="headerlink" title="java 生产者与消费者的模型分析"></a>java 生产者与消费者的模型分析</h1><ul><li>技术需求： 当生产者更新一条数据后，会立即通知消费者。</li><li>原理分析图</li><li><img src="https://s2.ax1x.com/2019/03/31/Ar7fN4.png" alt="原理图"></li></ul><a id="more"></a><ul><li>这种需求可以看成一种消息队列<br>我们可以利用多线程来开启两个队列，一个是生产者，另一个是消费者。</li></ul><h2 id="利用synchronized-对象锁来实现线程原子性。"><a href="#利用synchronized-对象锁来实现线程原子性。" class="headerlink" title="利用synchronized 对象锁来实现线程原子性。"></a>利用synchronized 对象锁来实现线程原子性。</h2><pre><code class="java">package com.Thread.Test;//消息模型class Msg{    public String data1;    public String data2;}//生产者线程class Producer extends Thread{    private Msg msg;    private int count = 0;    public Producer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                if(count == 0){                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                }else{                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count +1)%2;            }        }    }}//消费者线程class Consumer extends Thread{    private Msg msg;    public Consumer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);            }        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Msg msg = new Msg();        Producer producer = new Producer(msg);        Consumer consumer = new Consumer(msg);        producer.start();        Thread.sleep(300);        consumer.start();    }}</code></pre><p>这里有两个关键点</p><ul><li><strong>为什么要使用对象锁？</strong></li><li>因为如果不利用对象锁的话，这两个线程是不安全的，因为JMM的原因使得线程不可见。</li><li>并且对象锁一定是一致的，不然数据不会同步。</li><li><strong>这个解决方案是否可行？</strong></li><li>并不可以，因为两个线程存在抢占资源锁的情况，所以有可能生产者更新几次资源，但是消费者只显示一次，或者消费者重复显示几次的情况，并不符合我们的预期。</li><li>基于以上两点，我们采用线程通信技术。</li></ul><h2 id="多线程通信常用函数"><a href="#多线程通信常用函数" class="headerlink" title="多线程通信常用函数"></a>多线程通信常用函数</h2><ol><li>wait()函数<br> 该函数基于Object对象，他的作用是，暂时休眠该线程，并且<strong>释放锁资源</strong></li><li>notify()函数<br> 他的作用是唤醒线程池其他线程</li><li>interrupt()函数<br> 将当前正在等待的线程【可以是wait的线程】，直接抛出异常，用来停止线程。<blockquote><p>这两个函数通常都是配套使用，并且一定用在synchronized锁对象的情况下</p></blockquote></li></ol><hr><p>利用上面两个函数进行线程通信</p><pre><code class="java">package com.Thread.Test;//消息模型class Msg{    public String data1;    public String data2;    //假定flag= false 的时候 生产者激活，反之消费者激活    public boolean flag = false;}//生产者线程class Producer extends Thread{    private Msg msg;    private int count = 0;    public Producer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){//                此时生产者线程应该休眠                if(msg.flag){                    try {                        Thread.sleep(1000);                        msg.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                if(count == 0){                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                }else{                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count +1)%2;                msg.flag = true;                //通知其他线程                msg.notify();            }        }    }}class Consumer extends Thread{    private Msg msg;    public Consumer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                if(!msg.flag){                    try {                        Thread.sleep(1000);                        msg.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);                msg.flag = false;                msg.notify();            }        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Msg msg = new Msg();        Producer producer = new Producer(msg);        Consumer consumer = new Consumer(msg);        producer.start();        consumer.start();    }}</code></pre><h2 id="利用Lock锁实现通信"><a href="#利用Lock锁实现通信" class="headerlink" title="利用Lock锁实现通信"></a>利用Lock锁实现通信</h2><p>Lock锁与synchronized的不同之处在于，wait和notify函数对于lock是没有用的</p><p>不多说，上代码</p><pre><code class="java">package com.Thread.Test;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//消息模型class Msg2{    public String data1;    public String data2;    //假定flag= false 的时候 生产者激活，反之消费者激活    public boolean flag = false;    public Lock lock = new ReentrantLock();}//生产者线程class Producer2 extends Thread {    private Msg2 msg;    private int count = 0;    private Condition condition;    public Producer2(Msg2 msg, Condition condition) {        this.msg = msg;        this.condition = condition;    }    @Override    public void run() {        while (true) {            try {                msg.lock.lock();//                此时生产者线程应该休眠                if (msg.flag) {                    try {                        Thread.sleep(1000);                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                if (count == 0) {                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                } else {                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count + 1) % 2;                msg.flag = true;                //通知其他线程                condition.signal();            } catch (Exception e) {                e.printStackTrace();            } finally {                msg.lock.unlock();            }        }    }}class Consumer2 extends Thread{    private Msg2 msg;    private Condition condition;    public Consumer2(Msg2 msg, Condition condition) {        this.msg = msg;        this.condition = condition;    }    @Override    public void run() {        while (true){                try {                    msg.lock.lock();                    if(!msg.flag){                        try {                            Thread.sleep(1000);                            condition.await();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);                    msg.flag = false;                    condition.signal();                }catch (Exception e) {                    e.printStackTrace();                }finally {                    msg.lock.unlock();                }            }        }}public class LockTest {    public static void main(String[] args) throws InterruptedException {        Msg2 msg = new Msg2();        //利用Condition来限定通信        Condition newCondition = msg.lock.newCondition();        Producer2 producer = new Producer2(msg,newCondition);        Consumer2 consumer = new Consumer2(msg,newCondition);        producer.start();        consumer.start();    }}</code></pre><h2 id="如何优雅的停止线程（补充）"><a href="#如何优雅的停止线程（补充）" class="headerlink" title="如何优雅的停止线程（补充）"></a>如何优雅的停止线程（补充）</h2><p>首先，放弃Thread.stop()函数<br>要知道，一些线程都是一些while循环的，即可能是while(true)格式的，这样停止他可以用这样的思路：<br>设置一个boolean的flag，当flag = true的时候正常运行，flag = false的时候停止线程。</p><blockquote><p>这时应该考虑线程可见问题。需要将flag修改为 voliate格式。</p></blockquote><p>但是，如果当前的线程是synchronized锁，并且在wait状态下，flag修改对本线程没有什么影响。因为现在线程已经休眠了。<br>那么可以利用interrupt函数让他抛出异常，然后在catch的代码块上面将flag修改。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm利用ajax上传图片和参数</title>
      <link href="/2019/03/31/ssm%E5%88%A9%E7%94%A8ajax%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2019/03/31/ssm%E5%88%A9%E7%94%A8ajax%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax选择性上传图片"><a href="#Ajax选择性上传图片" class="headerlink" title="Ajax选择性上传图片"></a>Ajax选择性上传图片</h1><ul><li>技术选型:</li><li>bootstrap-fileinput 渲染上传框</li><li>FormData 用于传递参数</li><li>bootstrap 前端渲染</li></ul><a id="more"></a><hr><h2 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h2><blockquote><p>用于后台CMS更新商品的时候，需要上传图片和参数。但是为了节省流量，这里的图片是选择性上传，也就是说，后台分辨不出来，你到底有没有上传图片。</p><ul><li>功能截图：<br><img src="https://s2.ax1x.com/2019/03/31/Arcftf.png" alt="前端功能截图"></li></ul></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="前端代码部分"><a href="#前端代码部分" class="headerlink" title="前端代码部分"></a>前端代码部分</h3><pre><code class="html">&lt;%--编辑的模态框--%&gt;&lt;div class=&quot;modal fade&quot; id=&quot;editContent&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            &lt;div class=&quot;modal-header text-center&quot;&gt;                &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;                &lt;h4 class=&quot;modal-title&quot;&gt;商品信息修改&lt;/h4&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-body&quot;&gt;                &lt;form class=&quot;form-horizontal&quot; id=&quot;editContentForm&quot;&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;编号&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;id&quot;  id=&quot;contentId_update&quot; disabled=&quot;disabled&quot;/&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;内容标题&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;form-control&quot; id=&quot;contentTitle_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;子标题&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;subTitle&quot; class=&quot;form-control&quot; id=&quot;contentSubTitle_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;标题描述&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;titleDesc&quot; class=&quot;form-control&quot; id=&quot;contentTitleDesc_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;链接&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;url&quot; class=&quot;form-control&quot; id=&quot;contentUrl_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group hidden&quot; &gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;所属分类&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;categoryId&quot; class=&quot;form-control&quot; id=&quot;contentCategoryId_update&quot; disabled=&quot;disabled&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;图片&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;file&quot; name=&quot;picFile&quot; id=&quot;contentPic_update&quot; /&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;图片2&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;file&quot; name=&quot;pic2File&quot; id=&quot;contentPic2_update&quot;/&gt;                        &lt;/div&gt;                        &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;内容&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;content&quot; class=&quot;form-control&quot; id=&quot;contentContent_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-footer&quot;&gt;                &lt;div class=&quot;col-sm-12&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default col-sm-5&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-primary pull-right col-sm-5&quot; onclick= &quot;emp_update_btn()&quot;&gt;更新&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;//ajax异步上传function emp_update_btn () {        //没有检验数据是否正确 请注意        var formdata = new FormData($(&quot;#editContentForm&quot;)[0]);        formdata.append(&quot;id&quot;,$(&quot;#contentId_update&quot;).val());        $.ajax({          url:&#39;${pageContext.request.contextPath}/content/updateContent.do&#39;,            type:&#39;post&#39;,            dataType:&#39;json&#39;,            contentType: false,            processData: false,            data:formdata,            success:function (result) {                if(result.result === &quot;success&quot;){                    swal(&quot;成功&quot;,&quot;成功更新数据！&quot;,&quot;success&quot;);                    listAll();                    $(&quot;#editContent&quot;).modal(&quot;hide&quot;);                }            }        });&lt;/script&gt;</code></pre><ul><li>需要注意的是 这里和通常的ajax不一样,他传输的不是一般的JSON对象,而是FormData对象,他的写法也和平常的写法不一样</li><li><img src="https://s2.ax1x.com/2019/03/31/Arge3D.png" alt="ajax注意点"></li><li>关于那个图片到底有没有上传的功能,前端不需要考虑</li></ul><hr><h3 id="后台代码部分"><a href="#后台代码部分" class="headerlink" title="后台代码部分"></a>后台代码部分</h3><pre><code class="java">    @Value(&quot;${FILE_URL}&quot;)    private  String FILE_URL;    /**     * function:更新商品     * @param tbContent     * @param pic     * @param pic2     * @return     */    @RequestMapping(value = &quot;/updateContent.do&quot;)    @ResponseBody    public Map&lt;String,String&gt; updateContent(TbContent tbContent, @RequestParam(value = &quot;picFile&quot;,required = false)MultipartFile pic, @RequestParam(value = &quot;pic2File&quot;,required = false)MultipartFile pic2) throws IOException {        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();        System.out.println(pic + &quot;:&quot;+FILE_URL);        String picFileID = new String();        String pic2FileID =new String();        if(!pic.isEmpty()){             picFileID = FastDFSClient.uploadFile(pic.getInputStream(),pic.getOriginalFilename());            if(picFileID == null){                map.put(&quot;result&quot;,&quot;failed&quot;);                return map;            }            tbContent.setPic(FILE_URL+picFileID);            System.out.println(tbContent.getPic());        }        if(!pic2.isEmpty()){            pic2FileID = FastDFSClient.uploadFile(pic2.getInputStream(),pic2.getOriginalFilename());            if(pic2FileID == null){                map.put(&quot;result&quot;,&quot;failed&quot;);                return map;            }            tbContent.setPic2(pic2FileID);        }        try {            contentService.updateContent(tbContent);        } catch (IOException e) {            e.printStackTrace();            map.put(&quot;result&quot;,&quot;failed&quot;);            return map;        }        map.put(&quot;result&quot;,&quot;success&quot;);        return map;    }}</code></pre><blockquote><p>之前我用TbContent实体类去接收前端参数的时候，会加上@RequestBody,但是会报出400/415错误，因为FormData的编码并不是application/json;charset = utf-8 ，需要把这个注解删除。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> j2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件服务器 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> nginx反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型</title>
      <link href="/2019/03/30/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/03/30/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java内存模型-JMM"><a href="#java内存模型-JMM" class="headerlink" title="java内存模型(JMM)"></a>java内存模型(JMM)</h1><p>+这里来复习一下java多线程的三大特性 ： 原子性，可见性，有序性。</p><ul><li><p><strong>什么是原子性</strong></p></li><li><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。<br>我们操作数据也是如此，比如i = i+1；其中就包括，读取i的值，计算i，写入i。这行代码在Java中是不具备原子性的，则多线程运行肯定会出问题，所以也需要我们使用同步和lock这些东西来确保这个特性了。<br>原子性其实就是保证数据一致、线程安全一部分，<br><strong>这个也可以理解为数据库的事务</strong></p><a id="more"></a></li><li><p><strong>什么是可见性</strong></p></li><li><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></li><li><p>若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。 </p></li><li><p><strong>什么是有序性</strong></p></li><li><p>程序执行的顺序按照代码的先后顺序执行。</p></li><li><p>一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。如下：<br>int a = 10;    //语句1<br>int r = 2;    //语句2<br>a = a + 3;    //语句3<br>r = a*a;     //语句4<br>则因为重排序，他还可能执行顺序为 2-1-3-4，1-3-2-4<br>但绝不可能 2-1-4-3，因为这打破了依赖关系。<br>显然重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。</p></li></ul><ul><li>注意不要将JMM和JVM的内存机制混淆在一起。</li></ul><h2 id="java可见性原理分析"><a href="#java可见性原理分析" class="headerlink" title="java可见性原理分析"></a>java可见性原理分析</h2><ul><li>java多线程内存读写机制<ul><li><img src="https://s2.ax1x.com/2019/03/30/ABcR00.png" alt="java多线程内存读写机制"></li></ul></li></ul><blockquote><p>假如线程在同一时刻拿到副本，并且对这个副本就行自增操作，那么返回回来的变量并没有+2，而是+1，这就暴露了线程不同步问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程安全初窥探</title>
      <link href="/2019/03/29/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/03/29/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java线程安全"><a href="#java线程安全" class="headerlink" title="java线程安全"></a>java线程安全</h1><ul><li>知识点： 线程同步 线程并发</li><li>问题描述：在当处理全局变量的时候，当两个或者以上的线程处理同一个<strong> 全局 </strong>变量的时候，可能会出现冲突问题。<a id="more"></a></li></ul><hr><h2 id="java-同步函数"><a href="#java-同步函数" class="headerlink" title="java 同步函数"></a>java 同步函数</h2><p>首先看一下问题场景</p><pre><code class="java">package com.Thread.Test;/** * 抢票问题的一个案例分析 */class ThreadTrain implements Runnable{    private int TrainCount = 100;    @Override    public void run() {            while (TrainCount&gt;0){                try {                    Thread.sleep(50);                } catch (InterruptedException e) {                    e.printStackTrace();                }                sale();            }    }    private void sale(){        System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);        TrainCount--;    }}public class Main {    public static void main(String[] args) {    //开辟两个线程        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        t2.start();    }}</code></pre><blockquote><p><img src="https://s2.ax1x.com/2019/03/29/A0Gqk6.png" alt="Console ："><br><img src="https://s2.ax1x.com/2019/03/29/A0GHTx.png" alt="Console :"><br>可以看到 上图 会出现两个线程同时贩卖一张票的情况，而且最后会出现贩卖101张票的时候</p></blockquote><ul><li>那么为什么会产生这样的问题呢？<ul><li>原因分析： 是因为两个线程当时同时处于运行状态，那么他们接收的全局变量的value是相等的，那么就会出现贩卖同一张票的情况，这样就会产生线程不安全的情况！</li><li>解决方案分析：就像是购票的原理一样，会对数据库进行锁表，来实现数据同步，java也有锁这种东西</li><li><ul><li>synchronize  —- &gt;自动锁</li></ul></li><li><ul><li>lock  –&gt; jdk1.5 手动锁</li></ul></li></ul></li></ul><h3 id="synchronize-解决代码："><a href="#synchronize-解决代码：" class="headerlink" title="synchronize 解决代码："></a>synchronize 解决代码：</h3><pre><code class="java">package com.Thread.Test;/** * 抢票问题的一个案例分析 */class ThreadTrain implements Runnable{    private int TrainCount = 100;    @Override    public void run() {        while (TrainCount&gt;0){            try {                Thread.sleep(50);            } catch (InterruptedException e) {                e.printStackTrace();            }            sale();        }    }    //synchronized 分成 函数 和标识两个      private synchronized void sale(){ //this锁//        synchronized (this){        //加一个判断 判断最后一张票的两个线程情况        if(TrainCount&gt;0){            System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);            TrainCount--;        }//        }    }}public class Main {    public static void main(String[] args) {        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        t2.start();    }}</code></pre><blockquote><p>synchronize 方法 比较方便，但是拓展性不高，资源占用大</p></blockquote><h3 id="lock锁的解决办法"><a href="#lock锁的解决办法" class="headerlink" title="lock锁的解决办法"></a>lock锁的解决办法</h3><pre><code class="java">package com.Thread.Test;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ThreadTrain implements Runnable{    private int TrainCount = 100;    private Lock lock = new ReentrantLock();    @Override    public void run() {        while (TrainCount&gt;0){            try {                Thread.sleep(50);                sale();            } catch (Exception e) {                e.printStackTrace();            }        }    }    //synchronized 分成 函数 和标识两个    private  void sale(){ //this锁        try {            lock.lock();            if(TrainCount&gt;0){                System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);                TrainCount--;            }        }catch (Exception e) {            e.printStackTrace();        }finally {            lock.unlock();        }    }}public class LockTest {    public static void main(String args[]) throws InterruptedException {        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        Thread.sleep(40);        t2.start();    }}</code></pre><hr><p><img src="https://s2.ax1x.com/2019/03/29/A0RwV0.png" alt="result"></p><ul><li>值得注意的是 如果将函数标识成synchronized锁的话，这个函数只是一个this锁，但是如果使用synchronized函数的话，函数的变量可以定义任何Object类型</li><li>如果是用lock锁的话，如果代码在加锁的过程中，程序崩溃报错，那么这个锁就一直会在锁定状态，所以应该用try catch的时候，在finally加上unlock保证锁的正常运行</li><li>通过锁来实现数据同步，来解决一个像是抢票的并发问题。</li></ul><hr><h2 id="java静态同步函数"><a href="#java静态同步函数" class="headerlink" title="java静态同步函数"></a>java静态同步函数</h2><ul><li>如果将synchroized锁函数名前面加上static 标识限制的时候，那么这个函数不再是一个this锁，而是锁本类的java对象<br>例如<br><code>`</code> java<br>private static synchronized void sale(){ //this锁<br>//        synchronized (this){<pre><code>  //加一个判断 判断最后一张票的两个线程情况  if(TrainCount&gt;0){      System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);      TrainCount--;  }</code></pre></li></ul><p>//        }<br>    }</p><pre><code>是和下面的功能是一样的```java private  void sale(){ //this锁        synchronized (ThreadTrain.class){        //加一个判断 判断最后一张票的两个线程情况        if(TrainCount&gt;0){            System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);            TrainCount--;        }        }    }</code></pre><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>千万不要在数据同步的时候在嵌套一个数据锁，这样可能产生一个线程死锁</li><li>具体代码如下<br><code>`</code>java<br>package com.Thread.Test;</li></ul><p>/**</p><ul><li>抢票问题的一个案例分析<br>*/</li></ul><p>class ThreadTrain implements Runnable{</p><pre><code>private int TrainCount = 100;private Object oj = new Object();public boolean flag = true;@Overridepublic void run() {    if(flag){        while (TrainCount&gt;0){            synchronized (oj){                //加一个判断 判断最后一张票的两个线程情况                sale();            }        }    }else{        while(TrainCount&gt;0){            sale();        }    }}private synchronized void sale(){    synchronized (oj){    //加一个判断 判断最后一张票的两个线程情况    if(TrainCount&gt;0){        try {            Thread.sleep(40);        } catch (Exception e) {        }        System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);        TrainCount--;    }    }}</code></pre><p>}</p><p>public class Main {</p><pre><code>public static void main(String[] args) throws InterruptedException {    ThreadTrain threadTrain = new ThreadTrain();    Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);    Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);    t1.start();    Thread.sleep(40);    threadTrain.flag = false;    t2.start();}</code></pre><p>}</p><p><code>`</code></p><p><img src="https://s2.ax1x.com/2019/03/30/AB6zyn.png" alt="运行结果"></p><blockquote><p>产生原因： 一个线程已经占用了Object锁之后，打算进入this锁。但是第二个线程从flag = false那里的代码块直接占用this锁，从而第一个线程进不去sale()方法，而第二个方法执行sale()方法需要解开Object锁，导致死锁的产生。<br>这就好比是两个好友分别有对方的密码盒，并且都有自己钥匙，但是都不会把钥匙给对方，从而会产生一个谁也打不就开密码盒的尴尬情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java守护线程与非守护线程</title>
      <link href="/2019/03/28/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/28/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java守护线程与非守护线程窥探"><a href="#java守护线程与非守护线程窥探" class="headerlink" title="java守护线程与非守护线程窥探"></a>java守护线程与非守护线程窥探</h1><hr><h2 id="两个线程的基本概念"><a href="#两个线程的基本概念" class="headerlink" title="两个线程的基本概念"></a>两个线程的基本概念</h2><ul><li>守护线程即在后台为用户提供一些基本保障的线程，例如java中的gc线程[垃圾处理机制],他会自动清理一些没有用处的变量空间，处理空间溢出等问题。守护线程会随着main函数的结束而结束。</li><li>非守护线程，也成为用户线程，他是可以由用户自己定义，不会随着main函数的结束而结束，这个特性和守护线程恰恰相反。</li></ul><a id="more"></a><hr><h2 id="守护线程的机制"><a href="#守护线程的机制" class="headerlink" title="守护线程的机制"></a>守护线程的机制</h2><blockquote><p>举一个实例，当手机游览器正在下载文件的时候，如果你将游览器退出，但是那个文件还在继续下载，那个文件还在继续下载，这个下载文件线程就是守护线程。</p></blockquote><ul><li>值得注意的是，当程序的所有用户线程都结束的时候，并且程序中仅仅剩下了一个守护线程，那么JVM就会退出，因为守护线程已经没有什么可以守护的了。</li><li>但是需要一提的是，java中的main函数属于用户线程，并不属于守护线程!!!!</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程初窥探</title>
      <link href="/2019/03/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/03/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><p>多线程的作用就是提高应用程序的运行效率，提高用户的体验。那么，和多线程相近的进程又是什么意思呢？这两个有什么作用呢？</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>打开计算机的任务管理器可以看到里面有很多的应用程序正在运行，那么这些程序就是许许多多的进程。</li><li>进程可以看成一个线程的集合【List】,许许多多的线程合成了一个进程，也就是我们的应用程序。<h3 id="计算机如何进行许多应用程序的？"><a href="#计算机如何进行许多应用程序的？" class="headerlink" title="计算机如何进行许多应用程序的？"></a>计算机如何进行许多应用程序的？</h3></li><li>通过CPU对不同的应用程序进行不停的切换，也就是轮询？给用户了一种很多程序同时进行的假象，但是你打开一个程序很长时间不用，突然打开会有一瞬间的卡顿，这样就能看出他其实并不是和你当前的程序有着相同的地位的。</li><li><img src="http://pp1zup2fb.bkt.clouddn.com/java-1.png" alt="多线程实现原理"></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><strong>多线程</strong></li><li>开辟多线程是为了提高应用程序的运行效率。</li><li>开辟多线程之后，代码将不会从上至下进行。</li><li><ul><li><strong>主线程和子线程</strong></li></ul></li><li>子线程一般都是用类自己定义然后开启，他们的行为将受限于主线程。<h3 id="线程的执行方法"><a href="#线程的执行方法" class="headerlink" title="线程的执行方法"></a>线程的执行方法</h3></li><li>继承Thread方法，并且重写Run方法，然后启动start服务</li><li>实现Runable方法，重写Run方法，并且将线程类交给Thread类去构建。然后start服务</li><li>利用匿名类</li><li>[开发中常用]利用线程池开启服务</li></ul><hr><h3 id="多线程的具体实现"><a href="#多线程的具体实现" class="headerlink" title="多线程的具体实现"></a>多线程的具体实现</h3><ol><li>继承Thread</li></ol><pre><code class="java">/** *  * @classDesc: 功能描述:(创建多线程例子-Thread类 重写run方法) * @author: WHOAMI * @version: v1.0 */class CreateThread extends Thread {    // run方法中编写 多线程需要执行的代码    public void run() {        for (int i = 0; i&lt; 10; i++) {            System.out.println(&quot;i:&quot; + i);        }    }}public class ThreadDemo {    public static void main(String[] args) {        System.out.println(&quot;-----多线程创建开始-----&quot;);        // 1.创建一个线程        CreateThread createThread = new CreateThread();        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法        //3. 如果调用run方法，那么这个类就和普通的类没有区别        System.out.println(&quot;-----多线程创建启动-----&quot;);        createThread.start();        System.out.println(&quot;-----多线程创建结束-----&quot;);    }}</code></pre><ol start="2"><li>实现Runable接口</li></ol><pre><code class="java">/** *  * @classDesc: 功能描述:(创建多线程例子-Thread类 重写run方法) * @author: WHOAMI * @version: v1.0 */class CreateRunnable implements Runnable {    @Override    publicvoid run() {        for (inti = 0; i&lt; 10; i++) {            System.out.println(&quot;i:&quot; + i);        }    }}/** *  * @classDesc: 功能描述:(实现Runnable接口,重写run方法) * @author: WHOAMI * @version: v1.0 */public class ThreadDemo2 {    public static void main(String[] args) {        System.out.println(&quot;-----多线程创建开始-----&quot;);        // 1.创建一个线程        CreateRunnable createThread = new CreateRunnable();        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法        System.out.println(&quot;-----多线程创建启动-----&quot;);        Thread thread = new Thread(createThread);        thread.start();        System.out.println(&quot;-----多线程创建结束-----&quot;);    }}</code></pre><ol start="3"><li>使用匿名内部类</li></ol><pre><code class="java">    //在main函数里面直接写子线程方法     System.out.println(&quot;-----多线程创建开始-----&quot;);         Thread thread = new Thread(new Runnable() {            public void run() {                for (int i = 0; i&lt; 10; i++) {                    System.out.println(&quot;i:&quot; + i);                }            }        });         thread.start();         System.out.println(&quot;-----多线程创建结束-----&quot;);</code></pre><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li>Q:<strong>那么相对于前面两种方法，那种方法比较好?</strong><blockquote><p> A:使用接口比较好，因为java只能实现单继承，但是可以实现多种接口。而且公司开发大多都是面向接口编程。</p></blockquote><h4 id="多线程常用API"><a href="#多线程常用API" class="headerlink" title="多线程常用API"></a>多线程常用API</h4></li></ul><table><thead><tr><th style="text-align:left">常用API</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">start()</td><td style="text-align:left">启动线程</td></tr><tr><td style="text-align:left">CurrentThread()</td><td style="text-align:left">当前线程</td></tr><tr><td style="text-align:left">getID()</td><td style="text-align:left">获取当前线程ID      Thread-编号  该编号从0开始</td></tr><tr><td style="text-align:left">getName()</td><td style="text-align:left">获取当前线程名称</td></tr><tr><td style="text-align:left">sleep(long mill)</td><td style="text-align:left">设置线程执行时间(ms)</td></tr></tbody></table><table><thead><tr><th style="text-align:left">常用线程构造函数</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Thread()</td><td style="text-align:left">分配一个新的Thread对象</td></tr><tr><td style="text-align:left">Thread（String name）</td><td style="text-align:left">分配一个新的Thread 对象，并且指定线程名称</td></tr><tr><td style="text-align:left">Thread(Runable r)</td><td style="text-align:left">分配一个新的Thread对象</td></tr><tr><td style="text-align:left">Thread(Runable r,String name)</td><td style="text-align:left">分配一个新的Thread对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是WHOAMI。欢迎来到我的个人技术博客。</p><blockquote><p>低头做事，抬头装X</p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
